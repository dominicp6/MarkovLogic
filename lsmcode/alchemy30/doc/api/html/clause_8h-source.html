<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Alchemy: src/logic/clause.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_bad0962745a374caf6e9fb10c9087375.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_5fa6dff3c95823d97bd37bbb86c0a4ab.html">logic</a></div>
<h1>clause.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * All of the documentation and software included in the</span>
<a name="l00003"></a>00003 <span class="comment"> * Alchemy Software is copyrighted by Stanley Kok, Parag</span>
<a name="l00004"></a>00004 <span class="comment"> * Singla, Matthew Richardson, Pedro Domingos, Marc</span>
<a name="l00005"></a>00005 <span class="comment"> * Sumner and Hoifung Poon.</span>
<a name="l00006"></a>00006 <span class="comment"> * </span>
<a name="l00007"></a>00007 <span class="comment"> * Copyright [2004-07] Stanley Kok, Parag Singla, Matthew</span>
<a name="l00008"></a>00008 <span class="comment"> * Richardson, Pedro Domingos, Marc Sumner and Hoifung</span>
<a name="l00009"></a>00009 <span class="comment"> * Poon. All rights reserved.</span>
<a name="l00010"></a>00010 <span class="comment"> * </span>
<a name="l00011"></a>00011 <span class="comment"> * Contact: Pedro Domingos, University of Washington</span>
<a name="l00012"></a>00012 <span class="comment"> * (pedrod@cs.washington.edu).</span>
<a name="l00013"></a>00013 <span class="comment"> * </span>
<a name="l00014"></a>00014 <span class="comment"> * Redistribution and use in source and binary forms, with</span>
<a name="l00015"></a>00015 <span class="comment"> * or without modification, are permitted provided that</span>
<a name="l00016"></a>00016 <span class="comment"> * the following conditions are met:</span>
<a name="l00017"></a>00017 <span class="comment"> * </span>
<a name="l00018"></a>00018 <span class="comment"> * 1. Redistributions of source code must retain the above</span>
<a name="l00019"></a>00019 <span class="comment"> * copyright notice, this list of conditions and the</span>
<a name="l00020"></a>00020 <span class="comment"> * following disclaimer.</span>
<a name="l00021"></a>00021 <span class="comment"> * </span>
<a name="l00022"></a>00022 <span class="comment"> * 2. Redistributions in binary form must reproduce the</span>
<a name="l00023"></a>00023 <span class="comment"> * above copyright notice, this list of conditions and the</span>
<a name="l00024"></a>00024 <span class="comment"> * following disclaimer in the documentation and/or other</span>
<a name="l00025"></a>00025 <span class="comment"> * materials provided with the distribution.</span>
<a name="l00026"></a>00026 <span class="comment"> * </span>
<a name="l00027"></a>00027 <span class="comment"> * 3. All advertising materials mentioning features or use</span>
<a name="l00028"></a>00028 <span class="comment"> * of this software must display the following</span>
<a name="l00029"></a>00029 <span class="comment"> * acknowledgment: "This product includes software</span>
<a name="l00030"></a>00030 <span class="comment"> * developed by Stanley Kok, Parag Singla, Matthew</span>
<a name="l00031"></a>00031 <span class="comment"> * Richardson, Pedro Domingos, Marc Sumner and Hoifung</span>
<a name="l00032"></a>00032 <span class="comment"> * Poon in the Department of Computer Science and</span>
<a name="l00033"></a>00033 <span class="comment"> * Engineering at the University of Washington".</span>
<a name="l00034"></a>00034 <span class="comment"> * </span>
<a name="l00035"></a>00035 <span class="comment"> * 4. Your publications acknowledge the use or</span>
<a name="l00036"></a>00036 <span class="comment"> * contribution made by the Software to your research</span>
<a name="l00037"></a>00037 <span class="comment"> * using the following citation(s): </span>
<a name="l00038"></a>00038 <span class="comment"> * Stanley Kok, Parag Singla, Matthew Richardson and</span>
<a name="l00039"></a>00039 <span class="comment"> * Pedro Domingos (2005). "The Alchemy System for</span>
<a name="l00040"></a>00040 <span class="comment"> * Statistical Relational AI", Technical Report,</span>
<a name="l00041"></a>00041 <span class="comment"> * Department of Computer Science and Engineering,</span>
<a name="l00042"></a>00042 <span class="comment"> * University of Washington, Seattle, WA.</span>
<a name="l00043"></a>00043 <span class="comment"> * http://www.cs.washington.edu/ai/alchemy.</span>
<a name="l00044"></a>00044 <span class="comment"> * </span>
<a name="l00045"></a>00045 <span class="comment"> * 5. Neither the name of the University of Washington nor</span>
<a name="l00046"></a>00046 <span class="comment"> * the names of its contributors may be used to endorse or</span>
<a name="l00047"></a>00047 <span class="comment"> * promote products derived from this software without</span>
<a name="l00048"></a>00048 <span class="comment"> * specific prior written permission.</span>
<a name="l00049"></a>00049 <span class="comment"> * </span>
<a name="l00050"></a>00050 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF WASHINGTON</span>
<a name="l00051"></a>00051 <span class="comment"> * AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED</span>
<a name="l00052"></a>00052 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a name="l00053"></a>00053 <span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<a name="l00054"></a>00054 <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY</span>
<a name="l00055"></a>00055 <span class="comment"> * OF WASHINGTON OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,</span>
<a name="l00056"></a>00056 <span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a name="l00057"></a>00057 <span class="comment"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a name="l00058"></a>00058 <span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00059"></a>00059 <span class="comment"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span>
<a name="l00060"></a>00060 <span class="comment"> * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<a name="l00061"></a>00061 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a name="l00062"></a>00062 <span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN</span>
<a name="l00063"></a>00063 <span class="comment"> * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00064"></a>00064 <span class="comment"> * </span>
<a name="l00065"></a>00065 <span class="comment"> */</span>
<a name="l00066"></a>00066 <span class="preprocessor">#ifndef CLAUSE_H_JUN_26_2005</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define CLAUSE_H_JUN_26_2005</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;ext/hash_set&gt;</span>
<a name="l00070"></a>00070 <span class="keyword">using namespace </span>__gnu_cxx;
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00073"></a>00073 <span class="keyword">using namespace </span>std;
<a name="l00074"></a>00074 <span class="preprocessor">#include &lt;climits&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include "domain.h"</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include "hashstring.h"</span>
<a name="l00077"></a>00077 <span class="preprocessor">#include "hashlist.h"</span>
<a name="l00078"></a>00078 <span class="preprocessor">#include "arraysaccessor.h"</span>
<a name="l00079"></a>00079 <span class="preprocessor">#include "powerset.h"</span>
<a name="l00080"></a>00080 <span class="preprocessor">#include "multdarray.h"</span>
<a name="l00081"></a>00081 <span class="preprocessor">#include "hashint.h"</span>
<a name="l00082"></a>00082 <span class="preprocessor">#include "database.h"</span>
<a name="l00083"></a>00083 <span class="preprocessor">#include "predicate.h"</span>
<a name="l00084"></a>00084 <span class="preprocessor">#include "groundpredicate.h"</span>
<a name="l00085"></a>00085 <span class="preprocessor">#include "clausesampler.h"</span>
<a name="l00086"></a>00086 <span class="preprocessor">#include "clausehelper.h"</span>
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="keyword">const</span> <span class="keywordtype">bool</span> useInverseIndex = <span class="keyword">true</span>;
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">/******************************************************************************/</span>
<a name="l00092"></a>00092 <span class="keyword">class </span><a class="code" href="classHashClause.html">HashClause</a>;
<a name="l00093"></a>00093 <span class="keyword">class </span><a class="code" href="classEqualClause.html">EqualClause</a>;
<a name="l00094"></a>00094 <span class="keyword">typedef</span> <a class="code" href="classHashArray.html">HashArray&lt;Clause*, HashClause, EqualClause&gt;</a> <a class="code" href="classHashArray.html">ClauseHashArray</a>;
<a name="l00095"></a>00095 <span class="comment">/******************************************************************************/</span>
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="keyword">class </span><a class="code" href="structAddGroundClauseStruct.html">AddGroundClauseStruct</a>;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 
<a name="l00100"></a>00100   <span class="comment">//Ensure that the dirty_ bit is consistently updated.</span>
<a name="l00101"></a><a class="code" href="classClause.html">00101</a> <span class="keyword">class </span><a class="code" href="classClause.html">Clause</a>
<a name="l00102"></a>00102 {
<a name="l00103"></a><a class="code" href="classClause.html#eb39e2562d53aa71802bf315446d04b5">00103</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classClauseSampler.html">ClauseSampler</a>;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105  <span class="keyword">public</span>: 
<a name="l00106"></a><a class="code" href="classClause.html#5de3babaf26c8410b921155b933ee633">00106</a>   <a class="code" href="classClause.html#5de3babaf26c8410b921155b933ee633">Clause</a>() 
<a name="l00107"></a>00107     : wt_(0), predicates_(new <a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="classPredicate.html">Predicate</a>*&gt;), intArrRep_(NULL),
<a name="l00108"></a>00108       hashCode_(0), dirty_(true), isHardClause_(false),
<a name="l00109"></a>00109       varIdToVarsGroundedType_(NULL), auxClauseData_(NULL) {}
<a name="l00110"></a>00110 
<a name="l00111"></a><a class="code" href="classClause.html#1d4870d92b896ae30a8ce2f81f32e74b">00111</a>   <a class="code" href="classClause.html#5de3babaf26c8410b921155b933ee633">Clause</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; wt) 
<a name="l00112"></a>00112     : wt_(wt), predicates_(new <a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="classPredicate.html">Predicate</a>*&gt;), intArrRep_(NULL),
<a name="l00113"></a>00113       hashCode_(0), dirty_(true), isHardClause_(false),
<a name="l00114"></a>00114       varIdToVarsGroundedType_(NULL), auxClauseData_(NULL) {}
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="classClause.html#178d1c68f8987a27e3cbbc23a3a15cc6">00117</a>   <a class="code" href="classClause.html#5de3babaf26c8410b921155b933ee633">Clause</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>&amp; c)
<a name="l00118"></a>00118   {
<a name="l00119"></a>00119     wt_ = c.<a class="code" href="classClause.html#de380f30d46bc77df6cc4651f5f37858">wt_</a>;
<a name="l00120"></a>00120     predicates_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>;
<a name="l00121"></a>00121     <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>* cpredicates = c.<a class="code" href="classClause.html#31f8cacae5d17c4f7e214b6b42738624">predicates_</a>;
<a name="l00122"></a>00122     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cpredicates-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124       <a class="code" href="classPredicate.html">Predicate</a>* p = (*cpredicates)[i];
<a name="l00125"></a>00125       predicates_-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(<span class="keyword">new</span> <a class="code" href="classPredicate.html">Predicate</a>(*p, <span class="keyword">this</span>));      
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127     dirty_ = c.<a class="code" href="classClause.html#359beec3e68fb38ca561aabaaf502b19">dirty_</a>;
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <span class="keywordflow">if</span> (!dirty_) { assert(noDirtyPredicates()); }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (c.<a class="code" href="classClause.html#85abbf765c5b8abc1d2c166b304e8314">intArrRep_</a>)  intArrRep_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>(*(c.<a class="code" href="classClause.html#85abbf765c5b8abc1d2c166b304e8314">intArrRep_</a>));
<a name="l00132"></a>00132     <span class="keywordflow">else</span>               intArrRep_ = NULL;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     hashCode_ = c.<a class="code" href="classClause.html#f57ee12df5e6be65f9d20fc21a823346">hashCode_</a>;
<a name="l00135"></a>00135     
<a name="l00136"></a>00136     isHardClause_ = c.<a class="code" href="classClause.html#aadbb1543d0fec4f33fcfc206bfca505">isHardClause_</a>;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138     <span class="keywordflow">if</span> (c.<a class="code" href="classClause.html#f8681882eeea5d832b2a0a70092f6af9">varIdToVarsGroundedType_</a>)
<a name="l00139"></a>00139     {
<a name="l00140"></a>00140       varIdToVarsGroundedType_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>;
<a name="l00141"></a>00141       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; c.<a class="code" href="classClause.html#f8681882eeea5d832b2a0a70092f6af9">varIdToVarsGroundedType_</a>-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00142"></a>00142       {
<a name="l00143"></a>00143         <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>* vgt = (*(c.<a class="code" href="classClause.html#f8681882eeea5d832b2a0a70092f6af9">varIdToVarsGroundedType_</a>))[i];
<a name="l00144"></a>00144         varIdToVarsGroundedType_-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(<span class="keyword">new</span> <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>(*vgt));
<a name="l00145"></a>00145       }
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147     <span class="keywordflow">else</span>
<a name="l00148"></a>00148       varIdToVarsGroundedType_ = NULL;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <span class="keywordflow">if</span> (c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>)
<a name="l00151"></a>00151     {
<a name="l00152"></a>00152       auxClauseData_ = <span class="keyword">new</span> <a class="code" href="structAuxClauseData.html">AuxClauseData</a>(c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#dcd4f0e1520fc415acedd56adfe1527f">gain</a>,
<a name="l00153"></a>00153                                          c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#0186961bdb427f1749cd9530506af66a">op</a>,
<a name="l00154"></a>00154                                          c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#d511350b5fb665afc41bdc86282ce46d">removedClauseIdx</a>,
<a name="l00155"></a>00155                                          c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#05905c6de88e3c11ae915c9d1bcc0511">hasBeenExpanded</a>,
<a name="l00156"></a>00156                                          c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#bf085c8733aac3a0796a02b5d6b21ace">lastStepExpanded</a>,
<a name="l00157"></a>00157                                        c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#6f738ca35886fe9f00010bbf58ed944f">lastStepOverMinWeight</a>);
<a name="l00158"></a>00158       <span class="keywordflow">if</span> (c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#138a2790b04219ffb356dd537ef11c35">constTermPtrs</a>) <a class="code" href="classClause.html#f83c212adf37455f3d5d95c09fb9c402">trackConstants</a>();
<a name="l00159"></a>00159       <span class="keywordflow">if</span> (c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#9d29c1b85d5fd3ae4a50b7d3a60df142">cache</a>)
<a name="l00160"></a>00160       {
<a name="l00161"></a>00161         <a class="code" href="classArray.html">Array&lt;Array&lt;Array&lt;CacheCount*&gt;</a>*&gt;*&gt;* cache, * otherCache;
<a name="l00162"></a>00162         cache  = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;Array&lt;CacheCount*&gt;</a>*&gt;*&gt;;
<a name="l00163"></a>00163         otherCache = c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#9d29c1b85d5fd3ae4a50b7d3a60df142">cache</a>;
<a name="l00164"></a>00164 
<a name="l00165"></a>00165         cache-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(otherCache-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(),NULL);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; otherCache-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00168"></a>00168         {
<a name="l00169"></a>00169           (*cache)[i] = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;CacheCount*&gt;</a>*&gt;;
<a name="l00170"></a>00170           (*cache)[i]-&gt;growToSize((*otherCache)[i]-&gt;size(), NULL);
<a name="l00171"></a>00171           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (*otherCache)[i]-&gt;size(); j++)
<a name="l00172"></a>00172           {
<a name="l00173"></a>00173             <a class="code" href="classArray.html">Array&lt;CacheCount*&gt;</a>* ccArr = (*(*otherCache)[i])[j];
<a name="l00174"></a>00174             <span class="keywordflow">if</span> (ccArr == NULL) <span class="keywordflow">continue</span>;
<a name="l00175"></a>00175             (*(*cache)[i])[j] = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;CacheCount*&gt;</a>;
<a name="l00176"></a>00176             (*(*cache)[i])[j]-&gt;growToSize(ccArr-&gt;size());
<a name="l00177"></a>00177             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; ccArr-&gt;size(); k++)
<a name="l00178"></a>00178             {
<a name="l00179"></a>00179               (*(*(*cache)[i])[j])[k] = <span class="keyword">new</span> <a class="code" href="structCacheCount.html">CacheCount</a>((*ccArr)[k]-&gt;g,
<a name="l00180"></a>00180                                                        (*ccArr)[k]-&gt;c,
<a name="l00181"></a>00181                                                        (*ccArr)[k]-&gt;cnt); 
<a name="l00182"></a>00182             }
<a name="l00183"></a>00183           }
<a name="l00184"></a>00184         }
<a name="l00185"></a>00185         auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#9d29c1b85d5fd3ae4a50b7d3a60df142">cache</a> = cache;
<a name="l00186"></a>00186       }
<a name="l00187"></a>00187       
<a name="l00188"></a>00188       auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#9d98d044531e10c7e7a9f7173ef76e0b">prevClauseStr</a> = c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#9d98d044531e10c7e7a9f7173ef76e0b">prevClauseStr</a>;
<a name="l00189"></a>00189       auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#8c894ba3270bbd7805d54862e598cfab">addedPredStr</a> = c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#8c894ba3270bbd7805d54862e598cfab">addedPredStr</a>;
<a name="l00190"></a>00190       auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#933820b5eaa771462db181318b96b3c0">removedPredIdx</a> = c.<a class="code" href="classClause.html#8d1b0f00104def651055376b8bf181f5">auxClauseData_</a>-&gt;<a class="code" href="structAuxClauseData.html#933820b5eaa771462db181318b96b3c0">removedPredIdx</a>;
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192     <span class="keywordflow">else</span>
<a name="l00193"></a>00193       auxClauseData_ = NULL;
<a name="l00194"></a>00194   }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 
<a name="l00197"></a><a class="code" href="classClause.html#780ec87d29ebef4247510c9f5aa36662">00197</a>   <a class="code" href="classClause.html#780ec87d29ebef4247510c9f5aa36662">~Clause</a>() 
<a name="l00198"></a>00198   {
<a name="l00199"></a>00199     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00200"></a>00200       <span class="keyword">delete</span> (*predicates_)[i];
<a name="l00201"></a>00201     <span class="keyword">delete</span> predicates_;
<a name="l00202"></a>00202     <span class="keywordflow">if</span> (intArrRep_) <span class="keyword">delete</span> intArrRep_;
<a name="l00203"></a>00203     <span class="keywordflow">if</span> (varIdToVarsGroundedType_) deleteVarIdToVarsGroundedType();
<a name="l00204"></a>00204     <span class="keywordflow">if</span> (auxClauseData_) <span class="keyword">delete</span> auxClauseData_;
<a name="l00205"></a>00205   }
<a name="l00206"></a>00206 
<a name="l00207"></a>00207   
<a name="l00208"></a>00208     <span class="comment">//returns approximate size in MB, mainly due to cache in auxClauseData_</span>
<a name="l00209"></a><a class="code" href="classClause.html#f90a50ccabc876a7580e00509efc00b9">00209</a>   <span class="keywordtype">double</span> <a class="code" href="classClause.html#f90a50ccabc876a7580e00509efc00b9">sizeMB</a>()<span class="keyword"> const</span>
<a name="l00210"></a>00210 <span class="keyword">  </span>{
<a name="l00211"></a>00211     <span class="keywordtype">double</span> <a class="code" href="classClause.html#f90a50ccabc876a7580e00509efc00b9">sizeMB</a> = (fixedSizeB_ + intArrRep_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()*<span class="keyword">sizeof</span>(int) + 
<a name="l00212"></a>00212                      predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()*<span class="keyword">sizeof</span>(<a class="code" href="classPredicate.html">Predicate</a>*)) /1000000.0;
<a name="l00213"></a>00213     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00214"></a>00214       sizeMB += (*predicates_)[i]-&gt;sizeMB();
<a name="l00215"></a>00215     <span class="keywordflow">if</span> (auxClauseData_ != NULL) sizeMB += auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#44bcc3554dd6b5dd15546bb3e1d76e1d">sizeMB</a>(); 
<a name="l00216"></a>00216     <span class="keywordflow">return</span> sizeMB;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 
<a name="l00220"></a><a class="code" href="classClause.html#e563fd5d879d87eb62549b4e49352d27">00220</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classClause.html#e563fd5d879d87eb62549b4e49352d27">computeFixedSizeB</a>()
<a name="l00221"></a>00221   {
<a name="l00222"></a>00222     fixedSizeB_ = <span class="keyword">sizeof</span>(<a class="code" href="classClause.html">Clause</a>) + <span class="keyword">sizeof</span>(<a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>) +
<a name="l00223"></a>00223                   <span class="keyword">sizeof</span>(<a class="code" href="classArray.html">Array&lt;int&gt;</a>);
<a name="l00224"></a>00224     <span class="comment">//+ sizeof(Array&lt;VarsGroundedType*&gt;); // this is transient</span>
<a name="l00225"></a>00225   }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00228"></a><a class="code" href="classClause.html#a5bceeebd0ca170be3db7edeab97d8ef">00228</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#a5bceeebd0ca170be3db7edeab97d8ef">compress</a>()
<a name="l00229"></a>00229   {
<a name="l00230"></a>00230     predicates_-&gt;<a class="code" href="classArray.html#d076eab62161d62c67aadebcc71e5cb2">compress</a>();
<a name="l00231"></a>00231     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) (*predicates_)[i]-&gt;compress();
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (intArrRep_) intArrRep_-&gt;<a class="code" href="classArray.html#d076eab62161d62c67aadebcc71e5cb2">compress</a>();
<a name="l00233"></a>00233     <span class="keywordflow">if</span> (varIdToVarsGroundedType_) varIdToVarsGroundedType_-&gt;<a class="code" href="classArray.html#d076eab62161d62c67aadebcc71e5cb2">compress</a>();
<a name="l00234"></a>00234     <span class="keywordflow">if</span> (auxClauseData_) auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#e9727a261719aa946dec542c45c162eb">compress</a>();
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 
<a name="l00238"></a><a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">00238</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>(<a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)
<a name="l00239"></a>00239   {
<a name="l00240"></a>00240     <span class="keywordflow">if</span> (<span class="keyword">this</span> == c)  <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00241"></a>00241     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* cArr  = c-&gt;<a class="code" href="classClause.html#37e7d9d1f07d192e7be494c1d94ca450">getIntArrRep</a>();
<a name="l00242"></a>00242     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* myArr = getIntArrRep();
<a name="l00243"></a>00243     <span class="keywordflow">if</span> (myArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() != cArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00244"></a>00244     <span class="keyword">const</span> <span class="keywordtype">int</span>* cItems  = c-&gt;<a class="code" href="classClause.html#37e7d9d1f07d192e7be494c1d94ca450">getIntArrRep</a>()-&gt;<a class="code" href="classArray.html#db9fecfda9dfefea1421efc3ae010049">getItems</a>();
<a name="l00245"></a>00245     <span class="keyword">const</span> <span class="keywordtype">int</span>* myItems = getIntArrRep()-&gt;<a class="code" href="classArray.html#db9fecfda9dfefea1421efc3ae010049">getItems</a>();
<a name="l00246"></a>00246     <span class="keywordflow">return</span> (memcmp(myItems, cItems, myArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()*<span class="keyword">sizeof</span>(int))==0);
<a name="l00247"></a>00247   }
<a name="l00248"></a>00248 
<a name="l00249"></a><a class="code" href="classClause.html#e4145e1a8a0335e532103adec4b44eac">00249</a>   size_t <a class="code" href="classClause.html#e4145e1a8a0335e532103adec4b44eac">hashCode</a>() 
<a name="l00250"></a>00250   {
<a name="l00251"></a>00251     <span class="keywordflow">if</span> (dirty_) computeAndStoreIntArrRep();
<a name="l00252"></a>00252     <span class="keywordflow">return</span> hashCode_;
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 
<a name="l00256"></a><a class="code" href="classClause.html#43b84fdf90e0c961885151ef7679ead0">00256</a>   <span class="keywordtype">int</span> <a class="code" href="classClause.html#43b84fdf90e0c961885151ef7679ead0">getNumPredicates</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); }
<a name="l00257"></a>00257 
<a name="l00258"></a><a class="code" href="classClause.html#e234aafdd6eb6df9db924e254d13f12e">00258</a>   <span class="keywordtype">double</span> <a class="code" href="classClause.html#e234aafdd6eb6df9db924e254d13f12e">getWt</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> wt_; }
<a name="l00259"></a>00259 
<a name="l00260"></a><a class="code" href="classClause.html#be9f5a3ccd9ec0b6c92ecb26d3e7323e">00260</a>   <span class="keyword">const</span> <span class="keywordtype">double</span>* <a class="code" href="classClause.html#be9f5a3ccd9ec0b6c92ecb26d3e7323e">getWtPtr</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;wt_; }
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     <span class="comment">// not setting dirty bit because it does not affect the clause</span>
<a name="l00263"></a><a class="code" href="classClause.html#f80c37e7dfbe0805aad5026ae91cadb4">00263</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#f80c37e7dfbe0805aad5026ae91cadb4">setWt</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; wt) { wt_ = wt; }  
<a name="l00264"></a><a class="code" href="classClause.html#f41d7e407308135c34de2a58338d57e0">00264</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#f41d7e407308135c34de2a58338d57e0">addWt</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; wt) { wt_ += wt;  }
<a name="l00265"></a>00265  
<a name="l00266"></a><a class="code" href="classClause.html#15cb6ef264ac41e535656b8152df02d2">00266</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#15cb6ef264ac41e535656b8152df02d2">setDirty</a>() { dirty_ = <span class="keyword">true</span>; }
<a name="l00267"></a><a class="code" href="classClause.html#1e7974bc95399bd33a2800bd0bde0c20">00267</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#1e7974bc95399bd33a2800bd0bde0c20">isDirty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dirty_; }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269     <span class="comment">// Caller should not delete returned Predicate*.</span>
<a name="l00270"></a><a class="code" href="classClause.html#3b9114866b1e944b818faaf35cf106d3">00270</a>   <a class="code" href="classPredicate.html">Predicate</a>* <a class="code" href="classClause.html#3b9114866b1e944b818faaf35cf106d3">getPredicate</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; idx)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (*predicates_)[idx]; }
<a name="l00271"></a>00271   
<a name="l00272"></a>00272     <span class="comment">// Caller should not delete returned array nor modify its contents.</span>
<a name="l00273"></a><a class="code" href="classClause.html#cc256d935b1e07283188f03b5ac8cd57">00273</a>   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>* <a class="code" href="classClause.html#cc256d935b1e07283188f03b5ac8cd57">getPredicates</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> predicates_; }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 
<a name="l00276"></a><a class="code" href="classClause.html#4482cae4866da4ec4bad3cec28ef6d33">00276</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#4482cae4866da4ec4bad3cec28ef6d33">containsPredicate</a>(<span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; pred)<span class="keyword"> const</span>
<a name="l00277"></a>00277 <span class="keyword">  </span>{
<a name="l00278"></a>00278     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00279"></a>00279       <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>((<a class="code" href="classPredicate.html">Predicate</a>*)pred)) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00280"></a>00280     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00281"></a>00281   }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   
<a name="l00284"></a><a class="code" href="classClause.html#8a3224aca9e923171b45f4f4d05d6dbd">00284</a>   <span class="keywordtype">int</span> <a class="code" href="classClause.html#8a3224aca9e923171b45f4f4d05d6dbd">getNumVariables</a>()<span class="keyword"> const</span>
<a name="l00285"></a>00285 <span class="keyword">  </span>{
<a name="l00286"></a>00286     hash_set&lt;int&gt; intset;
<a name="l00287"></a>00287     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00288"></a>00288       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (*predicates_)[i]-&gt;getNumTerms(); j++)
<a name="l00289"></a>00289       {
<a name="l00290"></a>00290         <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;getTerm(j)-&gt;getType() == Term::VARIABLE)
<a name="l00291"></a>00291           intset.insert((*predicates_)[i]-&gt;getTerm(j)-&gt;getId());
<a name="l00292"></a>00292       }
<a name="l00293"></a>00293     <span class="keywordflow">return</span> intset.size();
<a name="l00294"></a>00294   }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00297"></a><a class="code" href="classClause.html#2cd1cceee97ba8a55b8179c6b4ef3863">00297</a>   <span class="keywordtype">int</span> <a class="code" href="classClause.html#2cd1cceee97ba8a55b8179c6b4ef3863">getNumVariablesAssumeCanonicalized</a>()<span class="keyword"> const</span>
<a name="l00298"></a>00298 <span class="keyword">  </span>{
<a name="l00299"></a>00299     <span class="keywordtype">int</span> minVarId = 0;
<a name="l00300"></a>00300     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00301"></a>00301       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (*predicates_)[i]-&gt;getNumTerms(); j++)
<a name="l00302"></a>00302       {
<a name="l00303"></a>00303         <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;getTerm(j)-&gt;getType() == Term::VARIABLE &amp;&amp;
<a name="l00304"></a>00304             (*predicates_)[i]-&gt;getTerm(j)-&gt;getId() &lt; minVarId)
<a name="l00305"></a>00305           minVarId = (*predicates_)[i]-&gt;getTerm(j)-&gt;getId();
<a name="l00306"></a>00306 
<a name="l00307"></a>00307       }
<a name="l00308"></a>00308     <span class="keywordflow">return</span> -minVarId;
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 
<a name="l00312"></a><a class="code" href="classClause.html#7eb908b452f9e428fc05cc22501c5cb8">00312</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#7eb908b452f9e428fc05cc22501c5cb8">isHardClause</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> isHardClause_; }
<a name="l00313"></a><a class="code" href="classClause.html#8ad74c2a57b735d49c1cd323a0500d9c">00313</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#8ad74c2a57b735d49c1cd323a0500d9c">setIsHardClause</a>(<span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; b) { isHardClause_ = b; }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <span class="comment">// p is stored in MLN and the caller of this function should not delete it.</span>
<a name="l00317"></a><a class="code" href="classClause.html#aada9d311a2d03f5bd6c77884cb30a2e">00317</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#aada9d311a2d03f5bd6c77884cb30a2e">appendPredicate</a>(<a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span>&amp; p) {predicates_-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(p);<a class="code" href="classClause.html#15cb6ef264ac41e535656b8152df02d2">setDirty</a>();}
<a name="l00318"></a>00318 
<a name="l00319"></a>00319     <span class="comment">// after removing a predicate, the clause is no longer canonicalized</span>
<a name="l00320"></a><a class="code" href="classClause.html#eba961a8282233d26f913385ba4d0635">00320</a>   <a class="code" href="classPredicate.html">Predicate</a>* <a class="code" href="classClause.html#eba961a8282233d26f913385ba4d0635">removePredicate</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i) 
<a name="l00321"></a>00321   { 
<a name="l00322"></a>00322     <span class="keywordflow">if</span> (0 &lt;= i &amp;&amp; i &lt; predicates_-&gt;size()) 
<a name="l00323"></a>00323     { <a class="code" href="classClause.html#15cb6ef264ac41e535656b8152df02d2">setDirty</a>(); <span class="keywordflow">return</span> predicates_-&gt;<a class="code" href="classArray.html#f3a485906b00ac44e39f0d402bd09512">removeItemFastDisorder</a>(i); }
<a name="l00324"></a>00324     <span class="keywordflow">return</span> NULL;
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     <span class="comment">//returns true if redundant predicates were removed</span>
<a name="l00329"></a><a class="code" href="classClause.html#b68f1c27c926a07d2a3142b67ece3468">00329</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#b68f1c27c926a07d2a3142b67ece3468">hasRedundantPredicates</a>()
<a name="l00330"></a>00330   {
<a name="l00331"></a>00331     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00332"></a>00332     {
<a name="l00333"></a>00333       <a class="code" href="classPredicate.html">Predicate</a>* ip = (*predicates_)[i];
<a name="l00334"></a>00334       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i+1; j &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l00335"></a>00335       {
<a name="l00336"></a>00336         <a class="code" href="classPredicate.html">Predicate</a>* jp = (*predicates_)[j];
<a name="l00337"></a>00337         <span class="keywordflow">if</span> (jp-&gt;same(ip) &amp;&amp; jp-&gt;getSense() == ip-&gt;getSense()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00338"></a>00338       }
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00341"></a>00341   }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     <span class="comment">//returns true if redundant predicates were removed</span>
<a name="l00345"></a><a class="code" href="classClause.html#1fcdc9f927a60ace551c27c65309181e">00345</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#1fcdc9f927a60ace551c27c65309181e">removeRedundantPredicates</a>()
<a name="l00346"></a>00346   {
<a name="l00347"></a>00347     <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;
<a name="l00348"></a>00348     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00349"></a>00349     {
<a name="l00350"></a>00350       <a class="code" href="classPredicate.html">Predicate</a>* ip = (*predicates_)[i];
<a name="l00351"></a>00351       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i+1; j &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l00352"></a>00352       {
<a name="l00353"></a>00353         <a class="code" href="classPredicate.html">Predicate</a>* jp = (*predicates_)[j];
<a name="l00354"></a>00354         <span class="keywordflow">if</span> (jp-&gt;same(ip) &amp;&amp; jp-&gt;getSense() == ip-&gt;getSense())
<a name="l00355"></a>00355         {
<a name="l00356"></a>00356           predicates_-&gt;<a class="code" href="classArray.html#f3a485906b00ac44e39f0d402bd09512">removeItemFastDisorder</a>(j);
<a name="l00357"></a>00357           changed = <span class="keyword">true</span>;
<a name="l00358"></a>00358           j--;
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360       }
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     <span class="keywordflow">return</span> changed;
<a name="l00363"></a>00363   }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   
<a name="l00366"></a><a class="code" href="classClause.html#6bf930f34c4625d577bef81f94da8edf">00366</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#6bf930f34c4625d577bef81f94da8edf">removeRedundantPredicatesAndCanonicalize</a>()
<a name="l00367"></a>00367   { <span class="keywordflow">if</span> (<a class="code" href="classClause.html#1fcdc9f927a60ace551c27c65309181e">removeRedundantPredicates</a>()) <a class="code" href="classClause.html#edb8a1d73f76a00136e94a852213b3da">canonicalize</a>(); }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369   
<a name="l00370"></a><a class="code" href="classClause.html#edb8a1d73f76a00136e94a852213b3da">00370</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#edb8a1d73f76a00136e94a852213b3da">canonicalize</a>()
<a name="l00371"></a>00371   {
<a name="l00372"></a>00372       <span class="comment">// rename the variables in decreasing order (negative numbers) </span>
<a name="l00373"></a>00373     <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>* vgtArr = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>;
<a name="l00374"></a>00374     createVarIdToVarsGroundedType(vgtArr);
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     sortPredicatesByIdAndSenseAndTerms(0, predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()-1, vgtArr);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     <a class="code" href="classHashArray.html">IntHashArray</a> varAppearOrder;
<a name="l00379"></a>00379     getVarOrder(varAppearOrder);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="keywordtype">int</span> newVarId = 0;
<a name="l00382"></a>00382     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; varAppearOrder.size(); i++)
<a name="l00383"></a>00383     {
<a name="l00384"></a>00384       <span class="keywordtype">int</span> varId = varAppearOrder[i];
<a name="l00385"></a>00385       ++newVarId;
<a name="l00386"></a>00386       <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = (*vgtArr)[varId]-&gt;vars;
<a name="l00387"></a>00387       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)  vars[j]-&gt;setId(-newVarId);
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389     assert(newVarId == varAppearOrder.size());
<a name="l00390"></a>00390 
<a name="l00391"></a>00391     <span class="keywordtype">int</span> i = 0, j = 0;
<a name="l00392"></a>00392     <span class="keywordflow">while</span> (i &lt; predicates_-&gt;size())
<a name="l00393"></a>00393     {
<a name="l00394"></a>00394       <span class="keywordflow">while</span> (++j &lt; predicates_-&gt;size() 
<a name="l00395"></a>00395              &amp;&amp; (*predicates_)[i]-&gt;getId() == (*predicates_)[j]-&gt;getId() 
<a name="l00396"></a>00396              &amp;&amp; (*predicates_)[i]-&gt;getSense() == (*predicates_)[j]-&gt;getSense());
<a name="l00397"></a>00397       <span class="keywordflow">if</span> (i &lt; j-1) sortPredicatesByTerms(i, j-1);
<a name="l00398"></a>00398       i = j;
<a name="l00399"></a>00399     }
<a name="l00400"></a>00400     
<a name="l00401"></a>00401     deleteVarIdToVarsGroundedType(vgtArr);
<a name="l00402"></a>00402     <a class="code" href="classClause.html#15cb6ef264ac41e535656b8152df02d2">setDirty</a>();
<a name="l00403"></a>00403   }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 
<a name="l00406"></a><a class="code" href="classClause.html#11a50b7726333d6acb68a249f7f30afc">00406</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classClause.html#11a50b7726333d6acb68a249f7f30afc">moveTermsFromUnseenToSeen</a>(<a class="code" href="classArray.html">Array&lt;Term*&gt;</a>* <span class="keyword">const</span> &amp; terms,
<a name="l00407"></a>00407                                  <a class="code" href="classHashArray.html">PredicateHashArray</a>&amp; unseenPreds,
<a name="l00408"></a>00408                                  <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; seenPreds)
<a name="l00409"></a>00409   {
<a name="l00410"></a>00410     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; terms-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l00411"></a>00411     {
<a name="l00412"></a>00412       <span class="keywordtype">bool</span> parIsPred;
<a name="l00413"></a>00413       <a class="code" href="classPredicate.html">Predicate</a>* parent = (<a class="code" href="classPredicate.html">Predicate</a>*) (*terms)[j]-&gt;getParent(parIsPred);      
<a name="l00414"></a>00414       assert(parIsPred);
<a name="l00415"></a>00415       <span class="keywordtype">int</span> a;
<a name="l00416"></a>00416       <span class="keywordflow">if</span> ((a=unseenPreds.<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(parent)) &gt;= 0)
<a name="l00417"></a>00417       {
<a name="l00418"></a>00418         <a class="code" href="classPredicate.html">Predicate</a>* par = unseenPreds.<a class="code" href="classHashArray.html#e5e111447c99c8bec8dcb007e9b7816b">removeItemFastDisorder</a>(a);
<a name="l00419"></a>00419         <span class="keywordflow">if</span> (unseenPreds.<a class="code" href="classHashArray.html#d1046d22b480e5aad812d20344b1bf6c">empty</a>()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00420"></a>00420         assert(par == parent);
<a name="l00421"></a>00421         seenPreds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(par);
<a name="l00422"></a>00422       }
<a name="l00423"></a>00423     }
<a name="l00424"></a>00424     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00425"></a>00425   }
<a name="l00426"></a>00426 
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="comment">//Returns true if there is a path of shared variables between any two preds</span>
<a name="l00429"></a><a class="code" href="classClause.html#32a2c0515ff294c905427a80a80c6ccc">00429</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#32a2c0515ff294c905427a80a80c6ccc">checkPredsAreConnected</a>()
<a name="l00430"></a>00430   {
<a name="l00431"></a>00431     <span class="keywordflow">if</span> (predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &lt;= 1) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00432"></a>00432     <a class="code" href="classArray.html">Array&lt;Array&lt;Term*&gt;</a>*&gt;* varIdToTerms = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;Term*&gt;</a>*&gt;;
<a name="l00433"></a>00433     hash_map&lt;int,Array&lt;Term*&gt;*&gt;* constIdToTerms=<span class="keyword">new</span> hash_map&lt;int,Array&lt;Term*&gt;*&gt;;
<a name="l00434"></a>00434     createVarConstIdToTerms(varIdToTerms, constIdToTerms);
<a name="l00435"></a>00435     <a class="code" href="classHashArray.html">PredicateHashArray</a> unseenPreds;
<a name="l00436"></a>00436     <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a> seenPreds;
<a name="l00437"></a>00437     hash_set&lt;int&gt; seenIds;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439     seenPreds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*predicates_)[0]);
<a name="l00440"></a>00440     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) 
<a name="l00441"></a>00441       unseenPreds.<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>((*predicates_)[i]);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     <span class="keywordflow">while</span> (!seenPreds.<a class="code" href="classArray.html#7049e1f4482b7a8589dec0cd73a7cd4b">empty</a>())
<a name="l00444"></a>00444     {
<a name="l00445"></a>00445       <a class="code" href="classPredicate.html">Predicate</a>* curPred = seenPreds.<a class="code" href="classArray.html#217ac5fcd77509d9e3efbc77bc95e11d">removeLastItem</a>();
<a name="l00446"></a>00446       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; curPred-&gt;getNumTerms(); i++) 
<a name="l00447"></a>00447       {
<a name="l00448"></a>00448         <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = curPred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i);
<a name="l00449"></a>00449         <span class="keywordtype">int</span> <span class="keywordtype">id</span> = t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>();
<a name="l00450"></a>00450         <span class="keywordflow">if</span> (seenIds.find(<span class="keywordtype">id</span>) != seenIds.end()) <span class="keywordflow">continue</span>;
<a name="l00451"></a>00451         seenIds.insert(<span class="keywordtype">id</span>);
<a name="l00452"></a>00452 
<a name="l00453"></a>00453         <span class="keywordflow">if</span> (t-&gt;getType() == Term::VARIABLE)
<a name="l00454"></a>00454         {
<a name="l00455"></a>00455           <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>* terms = (*varIdToTerms)[-id];
<a name="l00456"></a>00456           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; terms-&gt;size(); j++)
<a name="l00457"></a>00457           {
<a name="l00458"></a>00458             <span class="keywordtype">bool</span> parIsPred;
<a name="l00459"></a>00459             <a class="code" href="classPredicate.html">Predicate</a>* parent = (<a class="code" href="classPredicate.html">Predicate</a>*) (*terms)[j]-&gt;getParent(parIsPred);
<a name="l00460"></a>00460             assert(parIsPred);
<a name="l00461"></a>00461             <span class="keywordtype">int</span> a;
<a name="l00462"></a>00462             <span class="keywordflow">if</span> ((a=unseenPreds.<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(parent)) &gt;= 0)
<a name="l00463"></a>00463             {
<a name="l00464"></a>00464               <a class="code" href="classPredicate.html">Predicate</a>* par = unseenPreds.<a class="code" href="classHashArray.html#e5e111447c99c8bec8dcb007e9b7816b">removeItemFastDisorder</a>(a);
<a name="l00465"></a>00465               <span class="keywordflow">if</span> (unseenPreds.<a class="code" href="classHashArray.html#d1046d22b480e5aad812d20344b1bf6c">empty</a>()) 
<a name="l00466"></a>00466               {
<a name="l00467"></a>00467                 deleteVarConstIdToTerms(varIdToTerms, constIdToTerms);
<a name="l00468"></a>00468                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00469"></a>00469               }
<a name="l00470"></a>00470               seenPreds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(par);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472               <span class="comment">//commented out: not true if there a duplicate preds in clause</span>
<a name="l00473"></a>00473               <span class="comment">//               e.g. !isMale(p) v isMale(p)</span>
<a name="l00474"></a>00474               <span class="comment">//assert(par == parent);</span>
<a name="l00475"></a>00475             }
<a name="l00476"></a>00476           }
<a name="l00477"></a>00477         }
<a name="l00478"></a>00478         <span class="keywordflow">else</span>
<a name="l00479"></a>00479         <span class="keywordflow">if</span> (t-&gt;getType() == Term::CONSTANT)
<a name="l00480"></a>00480         {
<a name="l00481"></a>00481           <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>* terms = (*constIdToTerms)[id];
<a name="l00482"></a>00482           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; terms-&gt;size(); j++)
<a name="l00483"></a>00483           {
<a name="l00484"></a>00484             <span class="keywordtype">bool</span> parIsPred;
<a name="l00485"></a>00485             <a class="code" href="classPredicate.html">Predicate</a>* parent = (<a class="code" href="classPredicate.html">Predicate</a>*) (*terms)[j]-&gt;getParent(parIsPred);
<a name="l00486"></a>00486             assert(parIsPred);
<a name="l00487"></a>00487             <span class="keywordtype">int</span> a;
<a name="l00488"></a>00488             <span class="keywordflow">if</span> ((a=unseenPreds.<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(parent)) &gt;= 0)
<a name="l00489"></a>00489             {
<a name="l00490"></a>00490               <a class="code" href="classPredicate.html">Predicate</a>* par = unseenPreds.<a class="code" href="classHashArray.html#e5e111447c99c8bec8dcb007e9b7816b">removeItemFastDisorder</a>(a);
<a name="l00491"></a>00491               <span class="keywordflow">if</span> (unseenPreds.<a class="code" href="classHashArray.html#d1046d22b480e5aad812d20344b1bf6c">empty</a>()) 
<a name="l00492"></a>00492               {
<a name="l00493"></a>00493                 deleteVarConstIdToTerms(varIdToTerms, constIdToTerms);
<a name="l00494"></a>00494                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00495"></a>00495               }
<a name="l00496"></a>00496               seenPreds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(par);
<a name="l00497"></a>00497                 <span class="comment">//commented out: not true if there a duplicate preds in clause</span>
<a name="l00498"></a>00498                 <span class="comment">//               e.g. !isMale(p) v isMale(p)</span>
<a name="l00499"></a>00499               <span class="comment">//assert(par == parent);</span>
<a name="l00500"></a>00500             }
<a name="l00501"></a>00501           }
<a name="l00502"></a>00502         }
<a name="l00503"></a>00503       } <span class="comment">// for each term of curPred</span>
<a name="l00504"></a>00504     } <span class="comment">// while (!seenPreds.empty())</span>
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     assert(!unseenPreds.<a class="code" href="classHashArray.html#d1046d22b480e5aad812d20344b1bf6c">empty</a>());
<a name="l00507"></a>00507     deleteVarConstIdToTerms(varIdToTerms, constIdToTerms);
<a name="l00508"></a>00508     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00509"></a>00509   }
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 
<a name="l00512"></a><a class="code" href="classClause.html#8e66f3aafd52b1ae0c9862d759b703d8">00512</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#8e66f3aafd52b1ae0c9862d759b703d8">canonicalizeWithoutVariables</a>()
<a name="l00513"></a>00513   {
<a name="l00514"></a>00514     sortPredicatesByIdAndSenseAndTerms(0, predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()-1, NULL);
<a name="l00515"></a>00515     <span class="keywordtype">int</span> i = 0, j = 0;
<a name="l00516"></a>00516     <span class="keywordflow">while</span> (i &lt; predicates_-&gt;size())
<a name="l00517"></a>00517     {
<a name="l00518"></a>00518       <span class="keywordflow">while</span> (++j &lt; predicates_-&gt;size() 
<a name="l00519"></a>00519              &amp;&amp; (*predicates_)[i]-&gt;getId() == (*predicates_)[j]-&gt;getId() 
<a name="l00520"></a>00520              &amp;&amp; (*predicates_)[i]-&gt;getSense() == (*predicates_)[j]-&gt;getSense());
<a name="l00521"></a>00521       <span class="keywordflow">if</span> (i &lt; j-1) sortPredicatesByTerms(i, j-1);
<a name="l00522"></a>00522       i = j;
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524     <a class="code" href="classClause.html#15cb6ef264ac41e535656b8152df02d2">setDirty</a>();
<a name="l00525"></a>00525   }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527   
<a name="l00528"></a><a class="code" href="classClause.html#cd89f78c621311b5f07210583eb8f608">00528</a>   <a class="code" href="structAuxClauseData.html">AuxClauseData</a>* <a class="code" href="classClause.html#cd89f78c621311b5f07210583eb8f608">getAuxClauseData</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> auxClauseData_; }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 
<a name="l00531"></a><a class="code" href="classClause.html#0842266a31b9ec5952daeb55d8fe3e45">00531</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#0842266a31b9ec5952daeb55d8fe3e45">setAuxClauseData</a>(<a class="code" href="structAuxClauseData.html">AuxClauseData</a>* <span class="keyword">const</span>&amp; acd ) 
<a name="l00532"></a>00532   { 
<a name="l00533"></a>00533     <span class="keywordflow">if</span> (auxClauseData_ == acd) <span class="keywordflow">return</span>;
<a name="l00534"></a>00534     <span class="keywordflow">if</span> (auxClauseData_) <span class="keyword">delete</span> auxClauseData_;
<a name="l00535"></a>00535     auxClauseData_ = acd;
<a name="l00536"></a>00536   }
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 
<a name="l00539"></a><a class="code" href="classClause.html#f42e759f9c39dcb7d8a8014a603ef480">00539</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#f42e759f9c39dcb7d8a8014a603ef480">newAuxClauseData</a>() 
<a name="l00540"></a>00540   {<span class="keywordflow">if</span> (auxClauseData_) <span class="keyword">delete</span> auxClauseData_; auxClauseData_=<span class="keyword">new</span> <a class="code" href="structAuxClauseData.html">AuxClauseData</a>;}
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 
<a name="l00543"></a><a class="code" href="classClause.html#4a7469bfafba62f78b5866533778b99e">00543</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classClause.html#4a7469bfafba62f78b5866533778b99e">setClauseSampler</a>(<a class="code" href="classClauseSampler.html">ClauseSampler</a>* <span class="keyword">const</span> &amp; cs) 
<a name="l00544"></a>00544   { <span class="keywordflow">if</span> (clauseSampler_) <span class="keyword">delete</span> clauseSampler_; clauseSampler_ = cs; }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546 
<a name="l00547"></a><a class="code" href="classClause.html#de632516c187cb1078bb9eb605b4d1c4">00547</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classClauseSampler.html">ClauseSampler</a>* <a class="code" href="classClause.html#de632516c187cb1078bb9eb605b4d1c4">getClauseSampler</a>() { <span class="keywordflow">return</span> clauseSampler_; }
<a name="l00548"></a>00548   
<a name="l00549"></a>00549 
<a name="l00550"></a><a class="code" href="classClause.html#a77a39136edd846f6581b1973ddb9577">00550</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#a77a39136edd846f6581b1973ddb9577">containsConstants</a>()<span class="keyword"> const</span>
<a name="l00551"></a>00551 <span class="keyword">  </span>{
<a name="l00552"></a>00552     <span class="keywordflow">return</span> (auxClauseData_ &amp;&amp; auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#138a2790b04219ffb356dd537ef11c35">constTermPtrs</a> &amp;&amp; 
<a name="l00553"></a>00553             auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#138a2790b04219ffb356dd537ef11c35">constTermPtrs</a>-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &gt; 0);
<a name="l00554"></a>00554   }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <span class="comment">//auxClauseData_ must have been set to a valid AuxClauseData object</span>
<a name="l00558"></a><a class="code" href="classClause.html#f83c212adf37455f3d5d95c09fb9c402">00558</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#f83c212adf37455f3d5d95c09fb9c402">trackConstants</a>()
<a name="l00559"></a>00559   {
<a name="l00560"></a>00560     <span class="keywordflow">if</span> (auxClauseData_ == NULL) auxClauseData_ = <span class="keyword">new</span> <a class="code" href="structAuxClauseData.html">AuxClauseData</a>; 
<a name="l00561"></a>00561     <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>*&amp; constTermPtrs = auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#138a2790b04219ffb356dd537ef11c35">constTermPtrs</a>;
<a name="l00562"></a>00562     <span class="keywordflow">if</span> (constTermPtrs) constTermPtrs-&gt;<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l00563"></a>00563     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00564"></a>00564     {
<a name="l00565"></a>00565       <a class="code" href="classPredicate.html">Predicate</a>* p = (*predicates_)[i];
<a name="l00566"></a>00566       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; p-&gt;getNumTerms(); j++)
<a name="l00567"></a>00567       {
<a name="l00568"></a>00568         <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = p-&gt;getTerm(j);
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (t-&gt;getType() == Term::CONSTANT)
<a name="l00570"></a>00570         {
<a name="l00571"></a>00571           <span class="keywordflow">if</span> (constTermPtrs == NULL) constTermPtrs = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>;
<a name="l00572"></a>00572           constTermPtrs-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((<a class="code" href="classTerm.html">Term</a>*)t);
<a name="l00573"></a>00573         }
<a name="l00574"></a>00574       }
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576   }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="comment">//auxClauseData_ must have been set to a valid AuxClauseData object  </span>
<a name="l00580"></a><a class="code" href="classClause.html#4d37c58ac00519b50ab58f38e2211ef2">00580</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#4d37c58ac00519b50ab58f38e2211ef2">newCache</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numDomains, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numPreds)
<a name="l00581"></a>00581   {
<a name="l00582"></a>00582     assert(auxClauseData_);
<a name="l00583"></a>00583     auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#9582852676c0fbcb3fe12bfa6891a156">deleteCache</a>();
<a name="l00584"></a>00584     auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#9d29c1b85d5fd3ae4a50b7d3a60df142">cache</a> = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;Array&lt;CacheCount*&gt;</a>*&gt;*&gt;;
<a name="l00585"></a>00585     auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#9d29c1b85d5fd3ae4a50b7d3a60df142">cache</a>-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numDomains, NULL);
<a name="l00586"></a>00586     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numDomains; i++)
<a name="l00587"></a>00587     {
<a name="l00588"></a>00588       (*auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#9d29c1b85d5fd3ae4a50b7d3a60df142">cache</a>)[i] = <span class="keyword">new</span> <a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="classArray.html">Array&lt;CacheCount*&gt;</a>*&gt;;
<a name="l00589"></a>00589       (*auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#9d29c1b85d5fd3ae4a50b7d3a60df142">cache</a>)[i]-&gt;growToSize(numPreds, NULL);
<a name="l00590"></a>00590     }
<a name="l00591"></a>00591   }
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   
<a name="l00594"></a><a class="code" href="classClause.html#fdbd3f430d505104dfb2681a31f6c905">00594</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#fdbd3f430d505104dfb2681a31f6c905">translateConstants</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; orig, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span>&amp; nnew)
<a name="l00595"></a>00595   {
<a name="l00596"></a>00596     <span class="keywordflow">if</span> (auxClauseData_ == NULL || auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#138a2790b04219ffb356dd537ef11c35">constTermPtrs</a> == NULL) <span class="keywordflow">return</span>;
<a name="l00597"></a>00597 
<a name="l00598"></a>00598     <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>* constTermPtrs = auxClauseData_-&gt;<a class="code" href="structAuxClauseData.html#138a2790b04219ffb356dd537ef11c35">constTermPtrs</a>;
<a name="l00599"></a>00599     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; constTermPtrs-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00600"></a>00600     {
<a name="l00601"></a>00601       <a class="code" href="classTerm.html">Term</a>* t = (*constTermPtrs)[i];
<a name="l00602"></a>00602       <span class="keywordtype">int</span> newId = nnew-&gt;<a class="code" href="classDomain.html#f38c0be29eaffb326073219c18db170c">getConstantId</a>(orig-&gt;<a class="code" href="classDomain.html#05654c441be6afb1ef378d19f3ca0acc">getConstantName</a>(t-&gt;getId()));
<a name="l00603"></a>00603       t-&gt;setId(newId);
<a name="l00604"></a>00604       <span class="keywordflow">if</span> (newId &lt; 0)
<a name="l00605"></a>00605       {
<a name="l00606"></a>00606         cout &lt;&lt; <span class="stringliteral">"ERROR: in Clause::translateConstants(). Failed to translate "</span>
<a name="l00607"></a>00607              &lt;&lt;orig-&gt;<a class="code" href="classDomain.html#05654c441be6afb1ef378d19f3ca0acc">getConstantName</a>(t-&gt;getId())&lt;&lt;<span class="stringliteral">" from one domain to another."</span>
<a name="l00608"></a>00608              &lt;&lt; <span class="stringliteral">"Check that the constant exists in all domains."</span> &lt;&lt; endl;
<a name="l00609"></a>00609         exit(-1);                                      
<a name="l00610"></a>00610       }
<a name="l00611"></a>00611     }
<a name="l00612"></a>00612   }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614     <span class="comment">//Returns a map from typeId to variable ids. ReturnedArray[typeId] is NULL</span>
<a name="l00615"></a>00615     <span class="comment">//if there are no variables for the corresponding typeId.</span>
<a name="l00616"></a>00616     <span class="comment">//Caller is responsible for deleting the return Array and its contents.</span>
<a name="l00617"></a><a class="code" href="classClause.html#dfa141dd10b1ecc91699419ef4a58351">00617</a>   <a class="code" href="classArray.html">Array&lt;Array&lt;int&gt;</a>*&gt;* <a class="code" href="classClause.html#dfa141dd10b1ecc91699419ef4a58351">getTypeIdToVarIdsMapAndSmallestVarId</a>(<span class="keywordtype">int</span>&amp; smallestVarId)
<a name="l00618"></a>00618   {
<a name="l00619"></a>00619     smallestVarId = 0;
<a name="l00620"></a>00620     hash_set&lt;int&gt; intSet;
<a name="l00621"></a>00621     <a class="code" href="classArray.html">Array&lt;Array&lt;int&gt;</a>*&gt;* arr = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;int&gt;</a>*&gt;;
<a name="l00622"></a>00622     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00623"></a>00623     {
<a name="l00624"></a>00624       <a class="code" href="classPredicate.html">Predicate</a>* pred = (*predicates_)[i];
<a name="l00625"></a>00625       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; pred-&gt;getNumTerms(); j++)
<a name="l00626"></a>00626       {
<a name="l00627"></a>00627         <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = pred-&gt;getTerm(j);
<a name="l00628"></a>00628         <span class="keywordflow">if</span> (t-&gt;getType() == Term::VARIABLE)
<a name="l00629"></a>00629         {
<a name="l00630"></a>00630           <span class="keywordtype">int</span> varId = t-&gt;getId();
<a name="l00631"></a>00631           <span class="keywordflow">if</span> (intSet.find(varId) != intSet.end()) <span class="keywordflow">continue</span>;
<a name="l00632"></a>00632           intSet.insert(varId);
<a name="l00633"></a>00633 
<a name="l00634"></a>00634           <span class="keywordtype">int</span> typeId = pred-&gt;getTermTypeAsInt(j); 
<a name="l00635"></a>00635           <span class="keywordflow">if</span> (typeId &gt;= arr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()) arr-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(typeId+1, NULL);
<a name="l00636"></a>00636           <span class="keywordflow">if</span> ((*arr)[typeId] == NULL) (*arr)[typeId] = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>;
<a name="l00637"></a>00637           (*arr)[typeId]-&gt;append(varId); 
<a name="l00638"></a>00638           
<a name="l00639"></a>00639           <span class="keywordflow">if</span> (varId &lt; smallestVarId) smallestVarId = varId;
<a name="l00640"></a>00640         }
<a name="l00641"></a>00641       }
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643     <span class="keywordflow">return</span> arr;
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 
<a name="l00647"></a><a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">00647</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">sortByLen</a>(<a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>&amp; ca) { <a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">sortByLen</a>(ca, 0, ca.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()-1); } 
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 
<a name="l00650"></a><a class="code" href="classClause.html#cd135e8f20dd347da05e49b92d5cf055">00650</a>   <span class="keyword">static</span> string <a class="code" href="classClause.html#cd135e8f20dd347da05e49b92d5cf055">getOpAsString</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; op)
<a name="l00651"></a>00651   {
<a name="l00652"></a>00652     <span class="keywordflow">if</span> (op == OP_ADD)             <span class="keywordflow">return</span> <span class="stringliteral">"OP_ADD"</span>;
<a name="l00653"></a>00653     <span class="keywordflow">if</span> (op == OP_REPLACE_ADDPRED) <span class="keywordflow">return</span> <span class="stringliteral">"OP_REPLACE_ADDPRED"</span>;
<a name="l00654"></a>00654     <span class="keywordflow">if</span> (op == OP_REPLACE_REMPRED) <span class="keywordflow">return</span> <span class="stringliteral">"OP_REPLACE_REMPRED"</span>;
<a name="l00655"></a>00655     <span class="keywordflow">if</span> (op == OP_REMOVE)          <span class="keywordflow">return</span> <span class="stringliteral">"OP_REMOVE"</span>;
<a name="l00656"></a>00656     <span class="keywordflow">if</span> (op == OP_REPLACE)         <span class="keywordflow">return</span> <span class="stringliteral">"OP_REPLACE"</span>;
<a name="l00657"></a>00657     <span class="keywordflow">if</span> (op == OP_NONE)            <span class="keywordflow">return</span> <span class="stringliteral">"OP_NONE"</span>;
<a name="l00658"></a>00658     <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
<a name="l00659"></a>00659   }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661 
<a name="l00662"></a><a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">00662</a>   ostream&amp; <a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span>&amp; domain, 
<a name="l00663"></a>00663                  <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; withWt, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; asInt, 
<a name="l00664"></a>00664                  <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; withStrVar)<span class="keyword"> const</span>
<a name="l00665"></a>00665 <span class="keyword">  </span>{
<a name="l00666"></a>00666     <span class="keywordflow">if</span> (withWt) out &lt;&lt; wt_ &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668     <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a> eqPreds;
<a name="l00669"></a>00669     <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a> internalPreds;
<a name="l00670"></a>00670     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00671"></a>00671     {
<a name="l00672"></a>00672       <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;isEqualPred()) 
<a name="l00673"></a>00673         eqPreds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*predicates_)[i]);
<a name="l00674"></a>00674       <span class="keywordflow">else</span>
<a name="l00675"></a>00675       <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;isInternalPred()) 
<a name="l00676"></a>00676         internalPreds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*predicates_)[i]);
<a name="l00677"></a>00677       <span class="keywordflow">else</span>
<a name="l00678"></a>00678       {
<a name="l00679"></a>00679         <span class="keywordflow">if</span> (asInt)           (*predicates_)[i]-&gt;printAsInt(out);
<a name="l00680"></a>00680         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (withStrVar) (*predicates_)[i]-&gt;printWithStrVar(out, domain);
<a name="l00681"></a>00681         <span class="keywordflow">else</span>                 (*predicates_)[i]-&gt;print(out,domain);
<a name="l00682"></a>00682         <span class="keywordflow">if</span> (i &lt; predicates_-&gt;size()-1 || !eqPreds.<a class="code" href="classArray.html#7049e1f4482b7a8589dec0cd73a7cd4b">empty</a>() ||
<a name="l00683"></a>00683                 !internalPreds.<a class="code" href="classArray.html#7049e1f4482b7a8589dec0cd73a7cd4b">empty</a>()) out &lt;&lt; <span class="stringliteral">" v "</span>;
<a name="l00684"></a>00684       }
<a name="l00685"></a>00685     }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; eqPreds.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689       <span class="keywordflow">if</span> (asInt)           eqPreds[i]-&gt;printAsInt(out);
<a name="l00690"></a>00690       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (withStrVar) eqPreds[i]-&gt;printWithStrVar(out,domain);
<a name="l00691"></a>00691       <span class="keywordflow">else</span>                 eqPreds[i]-&gt;print(out,domain);
<a name="l00692"></a>00692       out &lt;&lt; ((i != eqPreds.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()-1 || !internalPreds.<a class="code" href="classArray.html#7049e1f4482b7a8589dec0cd73a7cd4b">empty</a>())?<span class="stringliteral">" v "</span>:<span class="stringliteral">""</span>);      
<a name="l00693"></a>00693     }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; internalPreds.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00696"></a>00696     {
<a name="l00697"></a>00697       <span class="keywordflow">if</span> (asInt)           internalPreds[i]-&gt;printAsInt(out);
<a name="l00698"></a>00698       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (withStrVar) internalPreds[i]-&gt;printWithStrVar(out,domain);
<a name="l00699"></a>00699       <span class="keywordflow">else</span>                 internalPreds[i]-&gt;print(out,domain);
<a name="l00700"></a>00700       out &lt;&lt; ((i!=internalPreds.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()-1)?<span class="stringliteral">" v "</span>:<span class="stringliteral">""</span>);      
<a name="l00701"></a>00701     }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     <span class="keywordflow">return</span> out;
<a name="l00704"></a>00704   }
<a name="l00705"></a>00705 
<a name="l00706"></a>00706 
<a name="l00707"></a><a class="code" href="classClause.html#87c1f626f3546d8c4cd4cf36cb7eb55b">00707</a>   ostream&amp; <a class="code" href="classClause.html#87c1f626f3546d8c4cd4cf36cb7eb55b">printAsInt</a>(ostream&amp; out)<span class="keyword"> const</span>
<a name="l00708"></a>00708 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(out, NULL, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>); }
<a name="l00709"></a>00709 
<a name="l00710"></a><a class="code" href="classClause.html#653b3cab89d7dea02ab74d483e091454">00710</a>   ostream&amp; <a class="code" href="classClause.html#653b3cab89d7dea02ab74d483e091454">printWithoutWt</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)<span class="keyword"> const</span>
<a name="l00711"></a>00711 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(out, domain, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   ostream&amp; 
<a name="l00714"></a><a class="code" href="classClause.html#fabbb591aeffad815add408b4cf3ae9a">00714</a>   <a class="code" href="classClause.html#fabbb591aeffad815add408b4cf3ae9a">printWithoutWtWithStrVar</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)<span class="keyword"> const</span>
<a name="l00715"></a>00715 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(out, domain, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>); }
<a name="l00716"></a>00716 
<a name="l00717"></a><a class="code" href="classClause.html#e0b4ccdb2433c116fcfeb1de59a9c8ec">00717</a>   ostream&amp; <a class="code" href="classClause.html#e0b4ccdb2433c116fcfeb1de59a9c8ec">printWithWtAndStrVar</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span>&amp; domain)<span class="keyword"> const</span>
<a name="l00718"></a>00718 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(out, domain, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>); }
<a name="l00719"></a>00719 
<a name="l00720"></a><a class="code" href="classClause.html#14f7d6ed92da91e6803a0f7bbf24ba42">00720</a>   ostream&amp; <a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span>&amp; domain)<span class="keyword"> const</span>
<a name="l00721"></a>00721 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(out, domain, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); }
<a name="l00722"></a>00722     
<a name="l00723"></a><a class="code" href="classClause.html#8d5777a1666a4a5f1473bfaa9c367a6d">00723</a>   ostream&amp; <a class="code" href="classClause.html#8d5777a1666a4a5f1473bfaa9c367a6d">printWithoutWtWithStrVarAndPeriod</a>(ostream&amp; out, 
<a name="l00724"></a>00724                                               <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span>&amp; domain)<span class="keyword"> const</span>
<a name="l00725"></a>00725 <span class="keyword">  </span>{
<a name="l00726"></a>00726     <a class="code" href="classClause.html#fabbb591aeffad815add408b4cf3ae9a">printWithoutWtWithStrVar</a>(out, domain);
<a name="l00727"></a>00727     <span class="keywordflow">if</span> (isHardClause_) out &lt;&lt; <span class="stringliteral">"."</span>;
<a name="l00728"></a>00728     <span class="keywordflow">return</span> out;
<a name="l00729"></a>00729   }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 
<a name="l00732"></a>00732  <span class="keyword">private</span>:
<a name="l00733"></a>00733   <span class="keyword">static</span> <span class="keywordtype">int</span> comparePredicatesByIdAndSenseAndTerms(
<a name="l00734"></a>00734                              <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; l, 
<a name="l00735"></a>00735                                              <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; r,
<a name="l00736"></a>00736                                  <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>* <span class="keyword">const</span> &amp; vgtArr)
<a name="l00737"></a>00737   {
<a name="l00738"></a>00738     <span class="keywordflow">if</span> (l-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>() &lt; r-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>()) <span class="keywordflow">return</span> -1;
<a name="l00739"></a>00739     <span class="keywordflow">if</span> (l-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>() &gt; r-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>()) <span class="keywordflow">return</span> 1;
<a name="l00740"></a>00740     <span class="keywordflow">if</span> (l-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>() &amp;&amp; !(r-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>())) <span class="keywordflow">return</span> -1;
<a name="l00741"></a>00741     <span class="keywordflow">if</span> (!(l-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>()) &amp;&amp; r-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>()) <span class="keywordflow">return</span> 1;
<a name="l00742"></a>00742     assert(l-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>() == r-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>());
<a name="l00743"></a>00743     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; l-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(); i++)
<a name="l00744"></a>00744     {
<a name="l00745"></a>00745       <span class="keywordtype">int</span> lid = l-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i)-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>();
<a name="l00746"></a>00746       <span class="keywordtype">int</span> rid = r-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i)-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>();
<a name="l00747"></a>00747       <span class="keywordflow">if</span> (vgtArr &amp;&amp; lid &lt; 0 &amp;&amp; rid &lt; 0)
<a name="l00748"></a>00748       {
<a name="l00749"></a>00749         <span class="keywordtype">bool</span> lbound = (*vgtArr)[-lid]-&gt;vars.size() &gt; 1;
<a name="l00750"></a>00750         <span class="keywordtype">bool</span> rbound = (*vgtArr)[-rid]-&gt;vars.size() &gt; 1;
<a name="l00751"></a>00751         <span class="keywordflow">if</span> (lbound &amp;&amp; !rbound) <span class="keywordflow">return</span> -1;
<a name="l00752"></a>00752         <span class="keywordflow">if</span> (!lbound &amp;&amp; rbound) <span class="keywordflow">return</span> 1;
<a name="l00753"></a>00753       }
<a name="l00754"></a>00754       <span class="keywordflow">if</span> (lid &gt; rid) <span class="keywordflow">return</span> -1;
<a name="l00755"></a>00755       <span class="keywordflow">if</span> (lid &lt; rid) <span class="keywordflow">return</span> 1;
<a name="l00756"></a>00756     }
<a name="l00757"></a>00757     <span class="keywordflow">return</span> 0;
<a name="l00758"></a>00758   }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760 
<a name="l00761"></a>00761   <span class="keywordtype">void</span> sortPredicatesByIdAndSenseAndTerms(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; l, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; r,
<a name="l00762"></a>00762                                  <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>* <span class="keyword">const</span> &amp; vgtArr)
<a name="l00763"></a>00763   {
<a name="l00764"></a>00764     <span class="keywordflow">if</span> (l &gt;= r) <span class="keywordflow">return</span>;
<a name="l00765"></a>00765     <a class="code" href="classPredicate.html">Predicate</a>* tmp = (*predicates_)[l];
<a name="l00766"></a>00766     (*predicates_)[l] = (*predicates_)[(l+r)/2];
<a name="l00767"></a>00767     (*predicates_)[(l+r)/2] = tmp;
<a name="l00768"></a>00768 
<a name="l00769"></a>00769     <span class="keywordtype">int</span> last = l;
<a name="l00770"></a>00770     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = l+1; i &lt;= r; i++)
<a name="l00771"></a>00771     <span class="keywordflow">if</span> (comparePredicatesByIdAndSenseAndTerms((*predicates_)[i],
<a name="l00772"></a>00772                                               (*predicates_)[l], vgtArr) &lt; 0)
<a name="l00773"></a>00773       {
<a name="l00774"></a>00774         ++last;
<a name="l00775"></a>00775         tmp = (*predicates_)[last];
<a name="l00776"></a>00776         (*predicates_)[last] = (*predicates_)[i];
<a name="l00777"></a>00777         (*predicates_)[i] = tmp;
<a name="l00778"></a>00778       }
<a name="l00779"></a>00779     
<a name="l00780"></a>00780     tmp = (*predicates_)[l];
<a name="l00781"></a>00781     (*predicates_)[l] = (*predicates_)[last];
<a name="l00782"></a>00782     (*predicates_)[last] = tmp;
<a name="l00783"></a>00783     sortPredicatesByIdAndSenseAndTerms(l, last-1, vgtArr);
<a name="l00784"></a>00784     sortPredicatesByIdAndSenseAndTerms(last+1, r, vgtArr);  
<a name="l00785"></a>00785   }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 
<a name="l00788"></a>00788     <span class="comment">//l and r must have the same id and sense</span>
<a name="l00789"></a>00789   <span class="keyword">static</span> <span class="keywordtype">int</span> comparePredicatesByTerms(<span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; l,
<a name="l00790"></a>00790                                <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; r)
<a name="l00791"></a>00791   {
<a name="l00792"></a>00792     assert(l-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>() == r-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>());
<a name="l00793"></a>00793     assert(l-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>() == r-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>());
<a name="l00794"></a>00794     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; l-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(); i++)
<a name="l00795"></a>00795     {
<a name="l00796"></a>00796       <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* lTerm =l-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i);
<a name="l00797"></a>00797       <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* rTerm =r-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i);
<a name="l00798"></a>00798       <span class="keywordtype">int</span> lTermType = lTerm-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>();
<a name="l00799"></a>00799       <span class="keywordtype">int</span> rTermType = rTerm-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>();
<a name="l00800"></a>00800       <span class="keywordflow">if</span> (lTermType == Term::VARIABLE &amp;&amp; rTermType == Term::VARIABLE)
<a name="l00801"></a>00801       {
<a name="l00802"></a>00802         <span class="keywordflow">if</span> (lTerm-&gt;getId() &gt; rTerm-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>()) <span class="keywordflow">return</span> -1;
<a name="l00803"></a>00803         <span class="keywordflow">if</span> (lTerm-&gt;getId() &lt; rTerm-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>()) <span class="keywordflow">return</span> 1;
<a name="l00804"></a>00804       }
<a name="l00805"></a>00805       <span class="keywordflow">else</span>
<a name="l00806"></a>00806       <span class="keywordflow">if</span> (lTermType == Term::CONSTANT &amp;&amp; rTermType == Term::CONSTANT)
<a name="l00807"></a>00807       {
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (lTerm-&gt;getId() &lt; rTerm-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>()) <span class="keywordflow">return</span> -1;
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (lTerm-&gt;getId() &gt; rTerm-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>()) <span class="keywordflow">return</span> 1;
<a name="l00810"></a>00810       }
<a name="l00811"></a>00811       <span class="keywordflow">else</span>
<a name="l00812"></a>00812       <span class="keywordflow">if</span> (lTermType == Term::VARIABLE &amp;&amp; rTermType == Term::CONSTANT)
<a name="l00813"></a>00813         <span class="keywordflow">return</span> -1;
<a name="l00814"></a>00814       <span class="keywordflow">else</span>
<a name="l00815"></a>00815       <span class="keywordflow">if</span> (lTermType == Term::CONSTANT &amp;&amp; rTermType == Term::VARIABLE)
<a name="l00816"></a>00816         <span class="keywordflow">return</span> 1;
<a name="l00817"></a>00817       <span class="keywordflow">else</span>
<a name="l00818"></a>00818       {
<a name="l00819"></a>00819         assert(<span class="keyword">false</span>);
<a name="l00820"></a>00820       }
<a name="l00821"></a>00821     }
<a name="l00822"></a>00822     <span class="keywordflow">return</span> 0;
<a name="l00823"></a>00823   }
<a name="l00824"></a>00824 
<a name="l00825"></a>00825 
<a name="l00826"></a>00826     <span class="comment">//The lth to rth predicates must have the same id and sense </span>
<a name="l00827"></a>00827   <span class="keywordtype">void</span> sortPredicatesByTerms(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; l, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; r)
<a name="l00828"></a>00828   {
<a name="l00829"></a>00829     <span class="keywordflow">if</span> (l &gt;= r) <span class="keywordflow">return</span>;
<a name="l00830"></a>00830     <a class="code" href="classPredicate.html">Predicate</a>* tmp = (*predicates_)[l];
<a name="l00831"></a>00831     (*predicates_)[l] = (*predicates_)[(l+r)/2];
<a name="l00832"></a>00832     (*predicates_)[(l+r)/2] = tmp;
<a name="l00833"></a>00833     
<a name="l00834"></a>00834     <span class="keywordtype">int</span> last = l;
<a name="l00835"></a>00835     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = l+1; i &lt;= r; i++)
<a name="l00836"></a>00836       <span class="keywordflow">if</span> (comparePredicatesByTerms((*predicates_)[i],(*predicates_)[l]) &lt; 0)
<a name="l00837"></a>00837       {
<a name="l00838"></a>00838         ++last;
<a name="l00839"></a>00839         tmp = (*predicates_)[last];
<a name="l00840"></a>00840         (*predicates_)[last] = (*predicates_)[i];
<a name="l00841"></a>00841         (*predicates_)[i] = tmp;
<a name="l00842"></a>00842       }
<a name="l00843"></a>00843     
<a name="l00844"></a>00844     tmp = (*predicates_)[l];
<a name="l00845"></a>00845     (*predicates_)[l] = (*predicates_)[last];
<a name="l00846"></a>00846     (*predicates_)[last] = tmp;
<a name="l00847"></a>00847     sortPredicatesByTerms(l, last-1);
<a name="l00848"></a>00848     sortPredicatesByTerms(last+1, r);  
<a name="l00849"></a>00849   }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 
<a name="l00852"></a>00852   <span class="keywordtype">bool</span> noDirtyPredicates()<span class="keyword"> const</span>
<a name="l00853"></a>00853 <span class="keyword">  </span>{
<a name="l00854"></a>00854     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l00855"></a>00855       <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;<a class="code" href="classClause.html#1e7974bc95399bd33a2800bd0bde0c20">isDirty</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00856"></a>00856     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00857"></a>00857   }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* getIntArrRep() 
<a name="l00860"></a>00860   { <span class="keywordflow">if</span> (dirty_) computeAndStoreIntArrRep(); <span class="keywordflow">return</span> intArrRep_; }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 
<a name="l00863"></a>00863   <span class="keywordtype">void</span> computeAndStoreIntArrRep()
<a name="l00864"></a>00864   {
<a name="l00865"></a>00865     dirty_ = <span class="keyword">false</span>;
<a name="l00866"></a>00866     <span class="keywordflow">if</span> (intArrRep_ == NULL) intArrRep_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>;
<a name="l00867"></a>00867     <span class="keywordflow">else</span>                    intArrRep_-&gt;<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     <span class="keywordtype">int</span> numPred = predicates_-&gt;size();
<a name="l00870"></a>00870     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numPred; i++)
<a name="l00871"></a>00871     {
<a name="l00872"></a>00872       <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;getSense()) intArrRep_-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(1);
<a name="l00873"></a>00873       <span class="keywordflow">else</span>                               intArrRep_-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(0);
<a name="l00874"></a>00874       (*predicates_)[i]-&gt;appendIntArrRep(*intArrRep_);      
<a name="l00875"></a>00875     }
<a name="l00876"></a>00876     hashCode_ = <a class="code" href="classHash.html#92377fe714014a69ead87bfccb2f71d8">Hash::hash</a>(*intArrRep_);
<a name="l00877"></a>00877   }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   
<a name="l00881"></a>00881  <span class="keyword">public</span>:
<a name="l00882"></a><a class="code" href="classClause.html#13bbfecce5950d8e55ad828598275f75">00882</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#13bbfecce5950d8e55ad828598275f75">addUnknownClauses</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain, 
<a name="l00883"></a>00883                          <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span>&amp; db, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; gndPredIdx, 
<a name="l00884"></a>00884                          <span class="keyword">const</span> <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* <span class="keyword">const</span> &amp; groundPred,
<a name="l00885"></a>00885                          <span class="keyword">const</span> <a class="code" href="structAddGroundClauseStruct.html">AddGroundClauseStruct</a>* <span class="keyword">const</span> &amp; agcs)
<a name="l00886"></a>00886   {
<a name="l00887"></a>00887     createVarIdToVarsGroundedType(domain);
<a name="l00888"></a>00888     <span class="keywordflow">if</span> (gndPredIdx &gt;= 0) groundPredVars(gndPredIdx, groundPred);
<a name="l00889"></a>00889     countNumTrueGroundings(domain, db, <span class="keyword">true</span>, <span class="keyword">false</span>, gndPredIdx, groundPred, 
<a name="l00890"></a>00890                            NULL, NULL, NULL, NULL, agcs);
<a name="l00891"></a>00891     restoreVars();
<a name="l00892"></a>00892     deleteVarIdToVarsGroundedType();
<a name="l00893"></a>00893   }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895 
<a name="l00896"></a><a class="code" href="classClause.html#0b08541f395c5e07ea8f26ec30ae4fba">00896</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#0b08541f395c5e07ea8f26ec30ae4fba">getUnknownClauses</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain, 
<a name="l00897"></a>00897                          <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span>&amp; db, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; gndPredIdx, 
<a name="l00898"></a>00898                          <span class="keyword">const</span> <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* <span class="keyword">const</span> &amp; groundPred,
<a name="l00899"></a>00899                          <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred,
<a name="l00900"></a>00900                          <a class="code" href="classArray.html">Array&lt;GroundClause*&gt;</a>* <span class="keyword">const</span>&amp; unknownGndClauses,
<a name="l00901"></a>00901                          <a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>* <span class="keyword">const</span>&amp; unknownClauses)
<a name="l00902"></a>00902   {
<a name="l00903"></a>00903     createVarIdToVarsGroundedType(domain);
<a name="l00904"></a>00904     <span class="keywordflow">if</span> (gndPredIdx &gt;= 0) 
<a name="l00905"></a>00905     {
<a name="l00906"></a>00906       <span class="keywordflow">if</span> (groundPred)          groundPredVars(gndPredIdx, groundPred);
<a name="l00907"></a>00907       <span class="keywordflow">else</span>  { assert(gndPred); groundPredVars(gndPredIdx, (<a class="code" href="classPredicate.html">Predicate</a>*)gndPred);}
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909     countNumTrueGroundings(domain, db, <span class="keyword">true</span>, <span class="keyword">false</span>, gndPredIdx, groundPred, 
<a name="l00910"></a>00910                            gndPred, unknownGndClauses,unknownClauses,NULL,NULL);
<a name="l00911"></a>00911     restoreVars();
<a name="l00912"></a>00912     deleteVarIdToVarsGroundedType();
<a name="l00913"></a>00913   }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915 
<a name="l00916"></a><a class="code" href="classClause.html#8388b5313c5ea52ecd1c50a37ca8a13f">00916</a>   <span class="keywordtype">bool</span> <a class="code" href="classClause.html#8388b5313c5ea52ecd1c50a37ca8a13f">isSatisfiable</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain, <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span>&amp; db,
<a name="l00917"></a>00917                      <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds)
<a name="l00918"></a>00918   {
<a name="l00919"></a>00919     createVarIdToVarsGroundedType(domain);
<a name="l00920"></a>00920 
<a name="l00921"></a>00921     <span class="keywordtype">double</span> i = countNumTrueGroundings(domain, db, hasUnknownPreds ,<span class="keyword">true</span>,
<a name="l00922"></a>00922                                       -1, NULL, NULL, NULL, NULL, NULL, NULL);
<a name="l00923"></a>00923     restoreVars();
<a name="l00924"></a>00924     deleteVarIdToVarsGroundedType();
<a name="l00925"></a>00925     <span class="keywordflow">return</span> (i &gt; 0);
<a name="l00926"></a>00926   }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     <span class="comment">//count the number of groundings of clause variables</span>
<a name="l00930"></a><a class="code" href="classClause.html#e3ce6ea80845699a1b8d1ad28624c4f7">00930</a>   <span class="keywordtype">double</span> <a class="code" href="classClause.html#e3ce6ea80845699a1b8d1ad28624c4f7">getNumGroundings</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)
<a name="l00931"></a>00931   {
<a name="l00932"></a>00932     createVarIdToVarsGroundedType(domain);
<a name="l00933"></a>00933     <span class="keywordtype">double</span> n = countNumGroundings();
<a name="l00934"></a>00934     deleteVarIdToVarsGroundedType();
<a name="l00935"></a>00935     <span class="keywordflow">return</span> n;
<a name="l00936"></a>00936   }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938 
<a name="l00939"></a><a class="code" href="classClause.html#7f7ccc631b58be414ff3976ae95ae0f1">00939</a>   <span class="keywordtype">double</span> <a class="code" href="classClause.html#7f7ccc631b58be414ff3976ae95ae0f1">getNumTrueGroundings</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00940"></a>00940                               <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l00941"></a>00941                               <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds)
<a name="l00942"></a>00942   {
<a name="l00943"></a>00943     createVarIdToVarsGroundedType(domain);
<a name="l00944"></a>00944     <span class="keywordtype">double</span> n = countNumTrueGroundings(domain, db, hasUnknownPreds, <span class="keyword">false</span>, 
<a name="l00945"></a>00945                                       -1, NULL, NULL, NULL, NULL, NULL,NULL);
<a name="l00946"></a>00946     restoreVars();
<a name="l00947"></a>00947     deleteVarIdToVarsGroundedType();
<a name="l00948"></a>00948     <span class="keywordflow">return</span> n;
<a name="l00949"></a>00949   }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 
<a name="l00952"></a><a class="code" href="classClause.html#22a19cb4883af8f774bb93fd0d70eef8">00952</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#22a19cb4883af8f774bb93fd0d70eef8">getNumTrueUnknownGroundings</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00953"></a>00953                                    <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l00954"></a>00954                                    <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds,
<a name="l00955"></a>00955                                    <span class="keywordtype">double</span>&amp; numTrue, <span class="keywordtype">double</span>&amp; numUnknown)
<a name="l00956"></a>00956   {
<a name="l00957"></a>00957     createVarIdToVarsGroundedType(domain);
<a name="l00958"></a>00958     numTrue = countNumTrueGroundings(domain, db, hasUnknownPreds, <span class="keyword">false</span>, 
<a name="l00959"></a>00959                                      -1, NULL, NULL, NULL, NULL, &amp;numUnknown,
<a name="l00960"></a>00960                                      NULL);
<a name="l00961"></a>00961     restoreVars();
<a name="l00962"></a>00962     deleteVarIdToVarsGroundedType();
<a name="l00963"></a>00963   }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 
<a name="l00966"></a><a class="code" href="classClause.html#429c824ef326f4c20548bbbef94db363">00966</a>   <span class="keywordtype">double</span> <a class="code" href="classClause.html#429c824ef326f4c20548bbbef94db363">getNumUnknownGroundings</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00967"></a>00967                                  <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l00968"></a>00968                                  <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds)
<a name="l00969"></a>00969   {
<a name="l00970"></a>00970     <span class="keywordtype">double</span> numTrue, numUnknown;
<a name="l00971"></a>00971     <a class="code" href="classClause.html#22a19cb4883af8f774bb93fd0d70eef8">getNumTrueUnknownGroundings</a>(domain, db, hasUnknownPreds,numTrue,numUnknown);
<a name="l00972"></a>00972     <span class="keywordflow">return</span> numUnknown;
<a name="l00973"></a>00973   }
<a name="l00974"></a>00974   
<a name="l00975"></a><a class="code" href="classClause.html#429bb2eed322cd70d8932a6ce94eb946">00975</a>   <span class="keywordtype">void</span> <a class="code" href="classClause.html#429bb2eed322cd70d8932a6ce94eb946">getNumTrueFalseUnknownGroundings</a>(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00976"></a>00976                                         <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l00977"></a>00977                                         <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds,
<a name="l00978"></a>00978                                         <span class="keywordtype">double</span>&amp; numTrue, <span class="keywordtype">double</span>&amp; numFalse,
<a name="l00979"></a>00979                                         <span class="keywordtype">double</span>&amp; numUnknown)
<a name="l00980"></a>00980   {
<a name="l00981"></a>00981     <a class="code" href="classClause.html#22a19cb4883af8f774bb93fd0d70eef8">getNumTrueUnknownGroundings</a>(domain, db, hasUnknownPreds,numTrue,numUnknown);
<a name="l00982"></a>00982     numFalse = <a class="code" href="classClause.html#e3ce6ea80845699a1b8d1ad28624c4f7">getNumGroundings</a>(domain) - numTrue - numUnknown;
<a name="l00983"></a>00983     assert(numTrue &gt;= 0);
<a name="l00984"></a>00984     assert(numUnknown &gt;= 0);
<a name="l00985"></a>00985     assert(numFalse &gt;= 0);
<a name="l00986"></a>00986   }
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 
<a name="l00989"></a>00989     <span class="comment">//Count the difference between the number of true groundings of the clause</span>
<a name="l00990"></a>00990     <span class="comment">//when gndPred is held to the opposite of its actual value and when held to</span>
<a name="l00991"></a>00991     <span class="comment">//its actual value. </span>
<a name="l00992"></a><a class="code" href="classClause.html#9f54773ab5446b080e1f3d7724b82aea">00992</a>   <span class="keywordtype">double</span> <a class="code" href="classClause.html#9f54773ab5446b080e1f3d7724b82aea">countDiffNumTrueGroundings</a>(<a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred, 
<a name="l00993"></a>00993                                     <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00994"></a>00994                                     <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l00995"></a>00995                                     <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds,
<a name="l00996"></a>00996                                     <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; sampleClauses,
<a name="l00997"></a>00997                                     <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; combo)
<a name="l00998"></a>00998   {
<a name="l00999"></a>00999     assert(gndPred-&gt;<a class="code" href="classPredicate.html#e6080bac705952c80d73174270b8eb94">isGrounded</a>());
<a name="l01000"></a>01000 
<a name="l01001"></a>01001       <span class="comment">//store the indexes of the predicates that can be grounded as gndPred</span>
<a name="l01002"></a>01002     <a class="code" href="classArray.html">Array&lt;int&gt;</a> gndPredIndexes;
<a name="l01003"></a>01003 
<a name="l01004"></a>01004     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l01005"></a>01005     {
<a name="l01006"></a>01006       <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;canBeGroundedAs(gndPred)) gndPredIndexes.append(i);
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008       <span class="comment">//create mapping of variable ids (e.g. -1) to variable addresses,</span>
<a name="l01009"></a>01009       <span class="comment">//note whether they have been grounded, and store their types</span>
<a name="l01010"></a>01010     createVarIdToVarsGroundedType(domain); 
<a name="l01011"></a>01011 
<a name="l01012"></a>01012     TruthValue actual = db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>(gndPred);
<a name="l01013"></a>01013     assert(actual == TRUE || actual == FALSE);
<a name="l01014"></a>01014     TruthValue opp = (actual == TRUE) ? FALSE : TRUE;
<a name="l01015"></a>01015     <span class="keywordtype">bool</span> flipped = <span class="keyword">false</span>;
<a name="l01016"></a>01016 
<a name="l01017"></a>01017       <span class="comment">//count # true groundings when gndPred is held to its actual value</span>
<a name="l01018"></a>01018     <span class="keywordtype">double</span> numTrueGndActual = 
<a name="l01019"></a>01019       countNumTrueGroundingsForAllComb(gndPredIndexes, gndPred, actual, flipped,
<a name="l01020"></a>01020                                        domain, hasUnknownPreds, sampleClauses);
<a name="l01021"></a>01021     <span class="comment">//cout &lt;&lt; "numTrueGndActual = " &lt;&lt; numTrueGndActual &lt;&lt; endl;</span>
<a name="l01022"></a>01022     
<a name="l01023"></a>01023       <span class="comment">//count # true groundings when gndPred is held to opposite value</span>
<a name="l01024"></a>01024     <span class="keywordtype">double</span> numTrueGndOpp = 0.0;
<a name="l01025"></a>01025     flipped = <span class="keyword">true</span>;
<a name="l01026"></a>01026     
<a name="l01027"></a>01027     <span class="keywordtype">int</span> blockIdx = domain-&gt;<a class="code" href="classDomain.html#800ce55fce96020c4c53091969df384e">getBlock</a>(gndPred);
<a name="l01028"></a>01028     <span class="keywordflow">if</span> (blockIdx &gt;= 0)
<a name="l01029"></a>01029     {
<a name="l01030"></a>01030         <span class="comment">// Pred in block: We have to look at combination c</span>
<a name="l01031"></a>01031         <span class="comment">// of other preds in block</span>
<a name="l01032"></a>01032       <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>* block = domain-&gt;<a class="code" href="classDomain.html#36913a072d47f3d22c4550cb1b5feb99">getPredBlock</a>(blockIdx);
<a name="l01033"></a>01033       assert(combo &lt; block-&gt;size());
<a name="l01034"></a>01034 
<a name="l01035"></a>01035       <span class="keywordtype">int</span> oldTrueOne = 0;
<a name="l01036"></a>01036       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; block-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01037"></a>01037       {
<a name="l01038"></a>01038         <span class="keywordflow">if</span> (db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>((*block)[i]) == TRUE)
<a name="l01039"></a>01039         {
<a name="l01040"></a>01040           oldTrueOne = i;
<a name="l01041"></a>01041           <span class="keywordflow">break</span>;
<a name="l01042"></a>01042         }
<a name="l01043"></a>01043       }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045       <span class="keywordtype">int</span> newTrueOne = (oldTrueOne &lt;= combo) ? combo + 1 : combo;
<a name="l01046"></a>01046       
<a name="l01047"></a>01047       assert(db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>((*block)[oldTrueOne]) == TRUE);
<a name="l01048"></a>01048       assert(db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>((*block)[newTrueOne]) == FALSE);
<a name="l01049"></a>01049       
<a name="l01050"></a>01050       db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>((*block)[oldTrueOne], FALSE);
<a name="l01051"></a>01051       db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>((*block)[newTrueOne], TRUE);
<a name="l01052"></a>01052       
<a name="l01053"></a>01053    <span class="comment">//numTrueGndOpp +=</span>
<a name="l01054"></a>01054    <span class="comment">//  countNumTrueGroundingsForAllComb(gndPredIndexes, gndPred, opp, flipped,</span>
<a name="l01055"></a>01055    <span class="comment">//                                   domain, hasUnknownPreds, sampleClauses);</span>
<a name="l01056"></a>01056 
<a name="l01057"></a>01057       numTrueGndOpp +=
<a name="l01058"></a>01058         countNumTrueGroundingsForAllComb(gndPredIndexes, (*block)[oldTrueOne],
<a name="l01059"></a>01059                                          opp, flipped, domain, hasUnknownPreds,
<a name="l01060"></a>01060                                          sampleClauses);
<a name="l01061"></a>01061       numTrueGndOpp +=
<a name="l01062"></a>01062         countNumTrueGroundingsForAllComb(gndPredIndexes, (*block)[newTrueOne],
<a name="l01063"></a>01063                                          opp, flipped, domain, hasUnknownPreds,
<a name="l01064"></a>01064                                          sampleClauses);
<a name="l01065"></a>01065       
<a name="l01066"></a>01066       db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>((*block)[oldTrueOne], TRUE);
<a name="l01067"></a>01067       db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>((*block)[newTrueOne], FALSE);
<a name="l01068"></a>01068     }
<a name="l01069"></a>01069     <span class="keywordflow">else</span>
<a name="l01070"></a>01070     {
<a name="l01071"></a>01071         <span class="comment">// Pred not in block: Count gndings with pred flipped</span>
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         <span class="comment">//set gndPred to have the opposite of its actual value</span>
<a name="l01074"></a>01074       db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>(gndPred, opp);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076       numTrueGndOpp +=
<a name="l01077"></a>01077         countNumTrueGroundingsForAllComb(gndPredIndexes, gndPred, opp, flipped,
<a name="l01078"></a>01078                                         domain, hasUnknownPreds, sampleClauses);
<a name="l01079"></a>01079 
<a name="l01080"></a>01080       db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>(gndPred, actual);
<a name="l01081"></a>01081     }
<a name="l01082"></a>01082     <span class="comment">//cout &lt;&lt; "numTrueGndOpp    = " &lt;&lt; numTrueGndOpp &lt;&lt; endl;</span>
<a name="l01083"></a>01083 
<a name="l01084"></a>01084     deleteVarIdToVarsGroundedType();
<a name="l01085"></a>01085     <span class="keywordflow">return</span> numTrueGndOpp - numTrueGndActual;
<a name="l01086"></a>01086   }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088 
<a name="l01089"></a>01089  <span class="keyword">private</span>:
<a name="l01090"></a>01090   <span class="keyword">static</span> <span class="keywordtype">void</span> addVarId(<a class="code" href="classTerm.html">Term</a>* <span class="keyword">const</span> &amp; t, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; typeId, 
<a name="l01091"></a>01091                 <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,                
<a name="l01092"></a>01092                 <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>*&amp; vgtArr)
<a name="l01093"></a>01093   {
<a name="l01094"></a>01094     <span class="keywordtype">int</span> <span class="keywordtype">id</span> = -(t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>());
<a name="l01095"></a>01095     assert(<span class="keywordtype">id</span> &gt; 0);
<a name="l01096"></a>01096     <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= vgtArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()) vgtArr-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(<span class="keywordtype">id</span>+1,NULL);
<a name="l01097"></a>01097     <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>*&amp; vgt = (*vgtArr)[id];
<a name="l01098"></a>01098     <span class="keywordflow">if</span> (vgt == NULL) 
<a name="l01099"></a>01099     {
<a name="l01100"></a>01100       vgt = <span class="keyword">new</span> <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>; 
<a name="l01101"></a>01101       <span class="comment">// vgt-&gt;isGrounded init to false</span>
<a name="l01102"></a>01102       vgt-&gt;<a class="code" href="structVarsGroundedType.html#79c8057f09ddaa37fe3fc6ef0d1a6d40">typeId</a> = typeId;
<a name="l01103"></a>01103       assert(vgt-&gt;<a class="code" href="structVarsGroundedType.html#79c8057f09ddaa37fe3fc6ef0d1a6d40">typeId</a> &gt;= 0);
<a name="l01104"></a>01104       vgt-&gt;<a class="code" href="structVarsGroundedType.html#b69c649723fe58e284222a463af9647d">numGndings</a> = domain-&gt;<a class="code" href="classDomain.html#8d92b09ec41630e34409bfe662930d3a">getNumConstantsByType</a>(vgt-&gt;<a class="code" href="structVarsGroundedType.html#79c8057f09ddaa37fe3fc6ef0d1a6d40">typeId</a>);
<a name="l01105"></a>01105       assert(vgt-&gt;<a class="code" href="structVarsGroundedType.html#b69c649723fe58e284222a463af9647d">numGndings</a> &gt; 0);
<a name="l01106"></a>01106     }
<a name="l01107"></a>01107     assert(typeId == vgt-&gt;<a class="code" href="structVarsGroundedType.html#79c8057f09ddaa37fe3fc6ef0d1a6d40">typeId</a>);
<a name="l01108"></a>01108     vgt-&gt;<a class="code" href="structVarsGroundedType.html#c332dea4788ad9f3129d8261e5b36c3e">vars</a>.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(t);
<a name="l01109"></a>01109   }
<a name="l01110"></a>01110   
<a name="l01111"></a>01111   <span class="keywordtype">void</span> createVarIdToVarsGroundedType(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l01112"></a>01112                                      <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>*&amp; vgtArr)<span class="keyword"> const</span>
<a name="l01113"></a>01113 <span class="keyword">  </span>{    
<a name="l01114"></a>01114       <span class="comment">//for each predicate </span>
<a name="l01115"></a>01115     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l01116"></a>01116     {
<a name="l01117"></a>01117       <a class="code" href="classPredicate.html">Predicate</a>* p = (*predicates_)[i];
<a name="l01118"></a>01118         <span class="comment">//for each variable of the predicate</span>
<a name="l01119"></a>01119       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; p-&gt;getNumTerms(); j++)
<a name="l01120"></a>01120       {
<a name="l01121"></a>01121         <a class="code" href="classTerm.html">Term</a>* t = (<a class="code" href="classTerm.html">Term</a>*) p-&gt;getTerm(j);
<a name="l01122"></a>01122         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::VARIABLE)
<a name="l01123"></a>01123           addVarId(t, p-&gt;getTermTypeAsInt(j), domain, vgtArr);
<a name="l01124"></a>01124         <span class="keywordflow">else</span>
<a name="l01125"></a>01125         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::FUNCTION)
<a name="l01126"></a>01126         {
<a name="l01127"></a>01127           cout &lt;&lt; <span class="stringliteral">"Clause::createVarIdToVarsGroundedType() not expecting a "</span>
<a name="l01128"></a>01128                &lt;&lt; <span class="stringliteral">"FUNCTION term"</span> &lt;&lt; endl;
<a name="l01129"></a>01129           exit(-1);
<a name="l01130"></a>01130         }
<a name="l01131"></a>01131       }<span class="comment">// for each variable of the predicate</span>
<a name="l01132"></a>01132     } <span class="comment">// for each predicate</span>
<a name="l01133"></a>01133   }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 
<a name="l01136"></a>01136   <span class="keywordtype">void</span> createVarIdToVarsGroundedType(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)
<a name="l01137"></a>01137   {    
<a name="l01138"></a>01138     deleteVarIdToVarsGroundedType();
<a name="l01139"></a>01139     varIdToVarsGroundedType_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>;
<a name="l01140"></a>01140     createVarIdToVarsGroundedType(domain, varIdToVarsGroundedType_);
<a name="l01141"></a>01141   }
<a name="l01142"></a>01142 
<a name="l01143"></a>01143 
<a name="l01144"></a>01144   <span class="keyword">static</span> <span class="keywordtype">void</span> deleteVarIdToVarsGroundedType(<a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>*&amp; vgtArr)
<a name="l01145"></a>01145   {
<a name="l01146"></a>01146     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vgtArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01147"></a>01147       <span class="keywordflow">if</span> ((*vgtArr)[i]) <span class="keyword">delete</span> (*vgtArr)[i];
<a name="l01148"></a>01148     <span class="keyword">delete</span> vgtArr;
<a name="l01149"></a>01149     vgtArr = NULL;
<a name="l01150"></a>01150   }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 
<a name="l01153"></a>01153   <span class="keywordtype">void</span> deleteVarIdToVarsGroundedType()
<a name="l01154"></a>01154   {
<a name="l01155"></a>01155     <span class="keywordflow">if</span> (varIdToVarsGroundedType_)
<a name="l01156"></a>01156       deleteVarIdToVarsGroundedType(varIdToVarsGroundedType_);
<a name="l01157"></a>01157   }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159 
<a name="l01160"></a>01160   <span class="keywordtype">void</span> getVarOrder(<a class="code" href="classHashArray.html">IntHashArray</a>&amp; varAppearOrder)<span class="keyword"> const</span>
<a name="l01161"></a>01161 <span class="keyword">  </span>{
<a name="l01162"></a>01162     varAppearOrder.<a class="code" href="classHashArray.html#2de280c5e9183a2ba9188f66b1eb026d">clear</a>();
<a name="l01163"></a>01163     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l01164"></a>01164     {
<a name="l01165"></a>01165       <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* p = (*predicates_)[i];
<a name="l01166"></a>01166       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; p-&gt;getNumTerms(); j++)
<a name="l01167"></a>01167       {
<a name="l01168"></a>01168         <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = p-&gt;getTerm(j);
<a name="l01169"></a>01169         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::VARIABLE)
<a name="l01170"></a>01170         {
<a name="l01171"></a>01171           <span class="keywordtype">int</span> <span class="keywordtype">id</span> = -(t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>());
<a name="l01172"></a>01172           assert(<span class="keywordtype">id</span> &gt; 0);
<a name="l01173"></a>01173           varAppearOrder.<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(<span class="keywordtype">id</span>);
<a name="l01174"></a>01174         }
<a name="l01175"></a>01175       }
<a name="l01176"></a>01176     }
<a name="l01177"></a>01177   }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179 
<a name="l01180"></a>01180   <span class="keywordtype">void</span> createVarIdToVarsGroundedType(<a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>*&amp; vgtArr)
<a name="l01181"></a>01181   {    
<a name="l01182"></a>01182       <span class="comment">//for each predicate </span>
<a name="l01183"></a>01183     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l01184"></a>01184     {
<a name="l01185"></a>01185       <a class="code" href="classPredicate.html">Predicate</a>* p = (*predicates_)[i];
<a name="l01186"></a>01186         <span class="comment">//for each variable of the predicate</span>
<a name="l01187"></a>01187       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; p-&gt;getNumTerms(); j++)
<a name="l01188"></a>01188       {
<a name="l01189"></a>01189         <a class="code" href="classTerm.html">Term</a>* t = (<a class="code" href="classTerm.html">Term</a>*) p-&gt;getTerm(j);
<a name="l01190"></a>01190         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::VARIABLE)
<a name="l01191"></a>01191         {
<a name="l01192"></a>01192           assert(t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>()&lt;0);
<a name="l01193"></a>01193           <span class="keywordtype">int</span> <span class="keywordtype">id</span> = -(t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>());
<a name="l01194"></a>01194           <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= vgtArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()) vgtArr-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(<span class="keywordtype">id</span>+1,NULL);
<a name="l01195"></a>01195           <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>*&amp; vgt = (*vgtArr)[id];
<a name="l01196"></a>01196           <span class="keywordflow">if</span> (vgt == NULL)  vgt = <span class="keyword">new</span> <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>; 
<a name="l01197"></a>01197           vgt-&gt;<a class="code" href="structVarsGroundedType.html#c332dea4788ad9f3129d8261e5b36c3e">vars</a>.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(t);
<a name="l01198"></a>01198         }
<a name="l01199"></a>01199         assert(t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() != Term::FUNCTION);
<a name="l01200"></a>01200       }<span class="comment">// for each variable of the predicate</span>
<a name="l01201"></a>01201     } <span class="comment">// for each predicate    </span>
<a name="l01202"></a>01202   }
<a name="l01203"></a>01203   
<a name="l01204"></a>01204 
<a name="l01205"></a>01205   <span class="keywordtype">void</span> createVarConstIdToTerms(<a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="classArray.html">Array&lt;Term*&gt;</a>*&gt;*&amp; varIdToTerms,
<a name="l01206"></a>01206                                hash_map&lt;<span class="keywordtype">int</span>,<a class="code" href="classArray.html">Array&lt;Term*&gt;</a>*&gt;*&amp; constIdToTerms)
<a name="l01207"></a>01207   {    
<a name="l01208"></a>01208     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++) <span class="comment">//for each predicate </span>
<a name="l01209"></a>01209     {
<a name="l01210"></a>01210       <a class="code" href="classPredicate.html">Predicate</a>* p = (*predicates_)[i];
<a name="l01211"></a>01211       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; p-&gt;getNumTerms(); j++) <span class="comment">//for each term of predicate</span>
<a name="l01212"></a>01212       {
<a name="l01213"></a>01213         <a class="code" href="classTerm.html">Term</a>* t = (<a class="code" href="classTerm.html">Term</a>*) p-&gt;getTerm(j);
<a name="l01214"></a>01214         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::VARIABLE)
<a name="l01215"></a>01215         {
<a name="l01216"></a>01216           <span class="keywordflow">if</span> (varIdToTerms == NULL) <span class="keywordflow">continue</span>;
<a name="l01217"></a>01217           <span class="keywordtype">int</span> <span class="keywordtype">id</span> = -(t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>());
<a name="l01218"></a>01218           <span class="keywordflow">if</span> (<span class="keywordtype">id</span> &gt;= varIdToTerms-&gt;size()) varIdToTerms-&gt;growToSize(<span class="keywordtype">id</span>+1,NULL);
<a name="l01219"></a>01219           <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>*&amp; termArr = (*varIdToTerms)[id];
<a name="l01220"></a>01220           <span class="keywordflow">if</span> (termArr == NULL) termArr = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>;             
<a name="l01221"></a>01221           termArr-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(t);
<a name="l01222"></a>01222         }
<a name="l01223"></a>01223         <span class="keywordflow">else</span>
<a name="l01224"></a>01224         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::CONSTANT)
<a name="l01225"></a>01225         {
<a name="l01226"></a>01226           <span class="keywordflow">if</span> (constIdToTerms == NULL) <span class="keywordflow">continue</span>;
<a name="l01227"></a>01227           <span class="keywordtype">int</span> <span class="keywordtype">id</span> = t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>();
<a name="l01228"></a>01228           <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>* termArr;
<a name="l01229"></a>01229           hash_map&lt;int,Array&lt;Term*&gt;*&gt;::iterator it = constIdToTerms-&gt;<a class="code" href="classArray.html#e5a7703acd6b54d55cd7c95b68262b09">find</a>(<span class="keywordtype">id</span>);
<a name="l01230"></a>01230           <span class="keywordflow">if</span> (it == constIdToTerms-&gt;end()) 
<a name="l01231"></a>01231           {
<a name="l01232"></a>01232             termArr = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>;
<a name="l01233"></a>01233             (*constIdToTerms)[id] = termArr;
<a name="l01234"></a>01234           }
<a name="l01235"></a>01235           <span class="keywordflow">else</span>
<a name="l01236"></a>01236             termArr = (*it).second;
<a name="l01237"></a>01237           termArr-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(t);
<a name="l01238"></a>01238         }
<a name="l01239"></a>01239         <span class="keywordflow">else</span>
<a name="l01240"></a>01240         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::FUNCTION)
<a name="l01241"></a>01241         {
<a name="l01242"></a>01242           cout &lt;&lt; <span class="stringliteral">"Clause::createVarIdToTerms() not expecting a "</span>
<a name="l01243"></a>01243                &lt;&lt; <span class="stringliteral">"FUNCTION term"</span> &lt;&lt; endl;
<a name="l01244"></a>01244           exit(-1);
<a name="l01245"></a>01245         }
<a name="l01246"></a>01246       }<span class="comment">// for each variable of the predicate</span>
<a name="l01247"></a>01247     } <span class="comment">// for each predicate</span>
<a name="l01248"></a>01248   }
<a name="l01249"></a>01249 
<a name="l01250"></a>01250 
<a name="l01251"></a>01251   <span class="keywordtype">void</span> deleteVarConstIdToTerms(<a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="classArray.html">Array&lt;Term*&gt;</a>*&gt;*&amp; varIdToTerms,
<a name="l01252"></a>01252                                hash_map&lt;<span class="keywordtype">int</span>,<a class="code" href="classArray.html">Array&lt;Term*&gt;</a>*&gt;*&amp;  constIdToTerms)
<a name="l01253"></a>01253   {
<a name="l01254"></a>01254     <span class="keywordflow">if</span> (varIdToTerms)
<a name="l01255"></a>01255     {
<a name="l01256"></a>01256       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; varIdToTerms-&gt;size(); i++)
<a name="l01257"></a>01257         <span class="keywordflow">if</span> ((*varIdToTerms)[i]) <span class="keyword">delete</span> (*varIdToTerms)[i];
<a name="l01258"></a>01258       <span class="keyword">delete</span> varIdToTerms;
<a name="l01259"></a>01259       varIdToTerms = NULL;
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261     <span class="keywordflow">if</span> (constIdToTerms)
<a name="l01262"></a>01262     {
<a name="l01263"></a>01263       hash_map&lt;int,Array&lt;Term*&gt;*&gt;::iterator it = constIdToTerms-&gt;begin();
<a name="l01264"></a>01264       <span class="keywordflow">for</span> (; it != constIdToTerms-&gt;end(); it++) <span class="keyword">delete</span> (*it).second;
<a name="l01265"></a>01265       <span class="keyword">delete</span> constIdToTerms;
<a name="l01266"></a>01266       constIdToTerms = NULL;
<a name="l01267"></a>01267     }
<a name="l01268"></a>01268   }
<a name="l01269"></a>01269 
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="comment">//Predicate at position predIdx must be able to be grounded as gndPred.</span>
<a name="l01272"></a>01272     <span class="comment">//Call Predicate::canBeGroundedAs() to check this.</span>
<a name="l01273"></a>01273     <span class="comment">//After one or more invocation of this function restoreVars() should</span>
<a name="l01274"></a>01274     <span class="comment">//be called to restore the variables in the clause to their original </span>
<a name="l01275"></a>01275     <span class="comment">//values. Since the variables will be restored later, the dirty_ bit is </span>
<a name="l01276"></a>01276     <span class="comment">//not set.</span>
<a name="l01277"></a>01277   <span class="keywordtype">void</span> groundPredVars(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; predIdx, <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span>&amp; gndPred,
<a name="l01278"></a>01278                       <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>*&amp; vgtArr)<span class="keyword"> const</span>
<a name="l01279"></a>01279 <span class="keyword">  </span>{
<a name="l01280"></a>01280     assert((*predicates_)[predIdx]-&gt;canBeGroundedAs(gndPred));
<a name="l01281"></a>01281     assert(predIdx &lt; predicates_-&gt;size());
<a name="l01282"></a>01282     assert(gndPred-&gt;<a class="code" href="classPredicate.html#e6080bac705952c80d73174270b8eb94">isGrounded</a>());
<a name="l01283"></a>01283 
<a name="l01284"></a>01284     <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* pred = (*predicates_)[predIdx];
<a name="l01285"></a>01285     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pred-&gt;getNumTerms(); i++)
<a name="l01286"></a>01286     {
<a name="l01287"></a>01287       <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = pred-&gt;getTerm(i);
<a name="l01288"></a>01288       <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::VARIABLE)
<a name="l01289"></a>01289       {
<a name="l01290"></a>01290         <span class="keywordtype">int</span> constId = gndPred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i)-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>();
<a name="l01291"></a>01291         <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>* vgt = (*vgtArr)[-t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>()];
<a name="l01292"></a>01292         <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = vgt-&gt;<a class="code" href="structVarsGroundedType.html#c332dea4788ad9f3129d8261e5b36c3e">vars</a>;
<a name="l01293"></a>01293         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)  vars[j]-&gt;setId(constId);
<a name="l01294"></a>01294         vgt-&gt;<a class="code" href="structVarsGroundedType.html#ffd040ae2f83be72b7b1eed86289b364">isGrounded</a> = <span class="keyword">true</span>;
<a name="l01295"></a>01295       }
<a name="l01296"></a>01296       assert(t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() != Term::FUNCTION);
<a name="l01297"></a>01297     }
<a name="l01298"></a>01298   }
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 
<a name="l01301"></a>01301     <span class="comment">//Predicate at position predIdx must be able to be grounded as gndPred.</span>
<a name="l01302"></a>01302     <span class="comment">//Call Predicate::canBeGroundedAs() to check this.</span>
<a name="l01303"></a>01303     <span class="comment">//After one or more invocation of this function restoreVars() should</span>
<a name="l01304"></a>01304     <span class="comment">//be called to restore the variables in the clause to their original </span>
<a name="l01305"></a>01305     <span class="comment">//values. Since the variables will be restored later, the dirty_ bit is </span>
<a name="l01306"></a>01306     <span class="comment">//not set.</span>
<a name="l01307"></a>01307   <span class="keywordtype">void</span> groundPredVars(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; predIdx, 
<a name="l01308"></a>01308                       <span class="keyword">const</span> <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* <span class="keyword">const</span>&amp; gndPred)<span class="keyword"> const</span>
<a name="l01309"></a>01309 <span class="keyword">  </span>{
<a name="l01310"></a>01310     assert(varIdToVarsGroundedType_);
<a name="l01311"></a>01311     assert((*predicates_)[predIdx]-&gt;canBeGroundedAs(gndPred));
<a name="l01312"></a>01312     assert(predIdx &lt; predicates_-&gt;size());
<a name="l01313"></a>01313 
<a name="l01314"></a>01314     <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* pred = (*predicates_)[predIdx];
<a name="l01315"></a>01315     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; pred-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(); i++)
<a name="l01316"></a>01316     {
<a name="l01317"></a>01317       <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = pred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i);
<a name="l01318"></a>01318       <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::VARIABLE)
<a name="l01319"></a>01319       {
<a name="l01320"></a>01320         <span class="keywordtype">int</span> constId = gndPred-&gt;<a class="code" href="classGroundPredicate.html#67ea81a3d3531afbead1d0d8d95f6e92">getTermId</a>(i);
<a name="l01321"></a>01321         <a class="code" href="structVarsGroundedType.html">VarsGroundedType</a>* vgt = (*varIdToVarsGroundedType_)[-t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>()];
<a name="l01322"></a>01322         <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = vgt-&gt;<a class="code" href="structVarsGroundedType.html#c332dea4788ad9f3129d8261e5b36c3e">vars</a>;
<a name="l01323"></a>01323         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)  vars[j]-&gt;setId(constId);
<a name="l01324"></a>01324         vgt-&gt;<a class="code" href="structVarsGroundedType.html#ffd040ae2f83be72b7b1eed86289b364">isGrounded</a> = <span class="keyword">true</span>;
<a name="l01325"></a>01325       }
<a name="l01326"></a>01326       assert(t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() != Term::FUNCTION);
<a name="l01327"></a>01327     }
<a name="l01328"></a>01328   }
<a name="l01329"></a>01329 
<a name="l01330"></a>01330 
<a name="l01331"></a>01331     <span class="comment">//Predicate at position predIdx must be able to be grounded as gndPred.</span>
<a name="l01332"></a>01332     <span class="comment">//Call Predicate::canBeGroundedAs() to check this.</span>
<a name="l01333"></a>01333     <span class="comment">//After one or more invocation of this function restoreVars() should</span>
<a name="l01334"></a>01334     <span class="comment">//be called to restore the variables in the clause to their original </span>
<a name="l01335"></a>01335     <span class="comment">//values. Since the variables will be restored later, the dirty_ bit is </span>
<a name="l01336"></a>01336     <span class="comment">//not set.</span>
<a name="l01337"></a>01337   <span class="keywordtype">void</span> groundPredVars(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; predIdx, <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span>&amp; gndPred)
<a name="l01338"></a>01338   {
<a name="l01339"></a>01339     assert(varIdToVarsGroundedType_);
<a name="l01340"></a>01340     groundPredVars(predIdx, gndPred, varIdToVarsGroundedType_); 
<a name="l01341"></a>01341   }
<a name="l01342"></a>01342 
<a name="l01343"></a>01343 
<a name="l01344"></a>01344     <span class="comment">// restore variables to original values</span>
<a name="l01345"></a>01345   <span class="keyword">static</span> <span class="keywordtype">void</span> restoreVars(<a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>* <span class="keyword">const</span> &amp; vgtArr)
<a name="l01346"></a>01346   {    
<a name="l01347"></a>01347     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; vgtArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01348"></a>01348     {
<a name="l01349"></a>01349       <span class="keywordflow">if</span> ((*vgtArr)[i] == NULL) <span class="keywordflow">continue</span>;
<a name="l01350"></a>01350       <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = (*vgtArr)[i]-&gt;vars;
<a name="l01351"></a>01351       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)  vars[j]-&gt;setId(-i);
<a name="l01352"></a>01352       (*vgtArr)[i]-&gt;isGrounded = <span class="keyword">false</span>;
<a name="l01353"></a>01353     }
<a name="l01354"></a>01354   }
<a name="l01355"></a>01355   
<a name="l01356"></a>01356 
<a name="l01357"></a>01357     <span class="comment">// restore variables to original values</span>
<a name="l01358"></a>01358   <span class="keywordtype">void</span> restoreVars()
<a name="l01359"></a>01359   {    
<a name="l01360"></a>01360     assert(varIdToVarsGroundedType_);
<a name="l01361"></a>01361     restoreVars(varIdToVarsGroundedType_);
<a name="l01362"></a>01362   }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364 
<a name="l01365"></a>01365   <span class="keyword">static</span> <span class="keywordtype">void</span> addVarIdAndGndings(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; varId, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; varType,
<a name="l01366"></a>01366                           <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l01367"></a>01367                           <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>* <span class="keyword">const</span> &amp; ivg)
<a name="l01368"></a>01368   {
<a name="l01369"></a>01369     ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#5cccf5441cb65de5dd090ff2f082f136">varIds</a>.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(varId);
<a name="l01370"></a>01370     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* constants = domain-&gt;<a class="code" href="classDomain.html#91e8d1dd04b99f0fe4fcf8b73aae54ee">getConstantsByType</a>(varType);
<a name="l01371"></a>01371     ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#64044243c9c5015955cd1b002c4a2b65">varGndings</a>.<a class="code" href="classArraysAccessor.html#dfec35a0a0f610d72b4463aa2841630c">appendArray</a>(constants);
<a name="l01372"></a>01372   }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374     <span class="comment">//Caller should delete the returned LitIdxVarsGndings*</span>
<a name="l01375"></a>01375     <span class="comment">//Returns NULL if the literal at litIdx is grounded </span>
<a name="l01376"></a>01376   <span class="keyword">static</span> <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>* createLitIdxVarIdsGndings(
<a name="l01377"></a>01377                                              <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; lit,
<a name="l01378"></a>01378                                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; litIdx,
<a name="l01379"></a>01379                                                  <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)
<a name="l01380"></a>01380   {
<a name="l01381"></a>01381     <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>* ivg = <span class="keyword">new</span> <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>;
<a name="l01382"></a>01382     ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#fd978459f8faaf456f1d6fa5daee0249">litIdx</a> = litIdx;
<a name="l01383"></a>01383     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; lit-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(); i++)
<a name="l01384"></a>01384     {
<a name="l01385"></a>01385       <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = lit-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i);
<a name="l01386"></a>01386       <span class="keywordtype">int</span> termType = t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>();
<a name="l01387"></a>01387       <span class="keywordflow">if</span> (termType == Term::VARIABLE)
<a name="l01388"></a>01388       {
<a name="l01389"></a>01389         <span class="keywordtype">int</span> varId = t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>();
<a name="l01390"></a>01390         <span class="keywordflow">if</span> (!ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#5cccf5441cb65de5dd090ff2f082f136">varIds</a>.<a class="code" href="classArray.html#88285e0c0c3d5f499f4a897844044b65">contains</a>(varId))
<a name="l01391"></a>01391           addVarIdAndGndings(varId, lit-&gt;<a class="code" href="classPredicate.html#38b27de49bbbc584fd416be7e5391250">getTermTypeAsInt</a>(i), domain, ivg);
<a name="l01392"></a>01392       }
<a name="l01393"></a>01393       assert(t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() != Term::FUNCTION);
<a name="l01394"></a>01394       assert(ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#5cccf5441cb65de5dd090ff2f082f136">varIds</a>.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#64044243c9c5015955cd1b002c4a2b65">varGndings</a>.<a class="code" href="classArraysAccessor.html#0fff369a0a183aff9d5b177b65d927c8">getNumArrays</a>());
<a name="l01395"></a>01395     }
<a name="l01396"></a>01396     ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#450fcde593ca0c72883fffc79861ec28">litUnseen</a> = <span class="keyword">true</span>;
<a name="l01397"></a>01397     <span class="keywordflow">return</span> ivg;
<a name="l01398"></a>01398   }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400 
<a name="l01401"></a>01401   <span class="keywordtype">void</span> createAllLitIdxVarsGndings(<a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; clauseLits, 
<a name="l01402"></a>01402                                   <a class="code" href="classArray.html">Array&lt;LitIdxVarIdsGndings*&gt;</a>&amp; ivgArr,
<a name="l01403"></a>01403                                   <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l01404"></a>01404                                   <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; setGroundedClausesToNull)<span class="keyword"> const</span>
<a name="l01405"></a>01405 <span class="keyword">  </span>{
<a name="l01406"></a>01406     assert(varIdToVarsGroundedType_); <span class="comment">// this must already be created</span>
<a name="l01407"></a>01407     
<a name="l01408"></a>01408       <span class="comment">//for each literal</span>
<a name="l01409"></a>01409     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (<span class="keywordtype">unsigned</span> int) clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01410"></a>01410     {
<a name="l01411"></a>01411         <span class="comment">//the literal was grounded when a previous literal was grounded</span>
<a name="l01412"></a>01412       <span class="keywordflow">if</span> (clauseLits[i] == NULL) <span class="keywordflow">continue</span>;
<a name="l01413"></a>01413       
<a name="l01414"></a>01414       ivgArr.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(createLitIdxVarIdsGndings(clauseLits[i], i, domain));
<a name="l01415"></a>01415       
<a name="l01416"></a>01416         <span class="comment">//ground variables of the last literal we looked at throughout clause</span>
<a name="l01417"></a>01417       <a class="code" href="classArraysAccessor.html">ArraysAccessor&lt;int&gt;</a>&amp; varGndings = ivgArr.<a class="code" href="classArray.html#7d998c9bd43e7072da34aa45a900d76d">lastItem</a>()-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#64044243c9c5015955cd1b002c4a2b65">varGndings</a>;
<a name="l01418"></a>01418       <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; varIds = ivgArr.<a class="code" href="classArray.html#7d998c9bd43e7072da34aa45a900d76d">lastItem</a>()-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#5cccf5441cb65de5dd090ff2f082f136">varIds</a>;
<a name="l01419"></a>01419       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; varIds.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l01420"></a>01420       {
<a name="l01421"></a>01421           <span class="comment">// get the first constant that can be used to ground the var</span>
<a name="l01422"></a>01422         <span class="keywordtype">int</span> constId = varGndings.<a class="code" href="classArraysAccessor.html#5af1996870106f083a7a7bba6bbf538b">getArray</a>(j)-&gt;<a class="code" href="classArray.html#cbfccc9bcca3cac2212c64fabc727048">item</a>(0);
<a name="l01423"></a>01423         
<a name="l01424"></a>01424           <span class="comment">// ground all occurrences of var</span>
<a name="l01425"></a>01425         <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = (*varIdToVarsGroundedType_)[-varIds[j]]-&gt;vars;
<a name="l01426"></a>01426         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); k++) vars[k]-&gt;setId(constId);
<a name="l01427"></a>01427       }
<a name="l01428"></a>01428     
<a name="l01429"></a>01429         <span class="comment">//store subsequent literals that are grounded when literal i is grounded</span>
<a name="l01430"></a>01430       <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; subseqGndLits = ivgArr.<a class="code" href="classArray.html#7d998c9bd43e7072da34aa45a900d76d">lastItem</a>()-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#cc6db92a2b936f1c6a18af0ff254e059">subseqGndLits</a>;
<a name="l01431"></a>01431 
<a name="l01432"></a>01432       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i+1; j &lt; clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l01433"></a>01433       {
<a name="l01434"></a>01434         <a class="code" href="classPredicate.html">Predicate</a>* subseqLit = clauseLits[j];
<a name="l01435"></a>01435         <span class="keywordflow">if</span> (subseqLit==NULL) <span class="keywordflow">continue</span>;
<a name="l01436"></a>01436         <span class="keywordflow">if</span> (subseqLit-&gt;isGrounded()) 
<a name="l01437"></a>01437         {
<a name="l01438"></a>01438           subseqGndLits.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(subseqLit);
<a name="l01439"></a>01439           <span class="keywordflow">if</span> (setGroundedClausesToNull) clauseLits[j] = NULL;
<a name="l01440"></a>01440         }
<a name="l01441"></a>01441       } <span class="comment">//for each subsequent literal</span>
<a name="l01442"></a>01442     } <span class="comment">//for each literal</span>
<a name="l01443"></a>01443   }
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 
<a name="l01446"></a>01446     <span class="comment">// Also sets to -1 the ids of the parent terms of functions in ivgArr[i]. </span>
<a name="l01447"></a>01447   <span class="keyword">static</span> <span class="keywordtype">void</span> deleteAllLitIdxVarsGndings(<a class="code" href="classArray.html">Array&lt;LitIdxVarIdsGndings*&gt;</a>&amp; ivgArr)
<a name="l01448"></a>01448   { 
<a name="l01449"></a>01449     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ivgArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) <span class="keyword">delete</span> ivgArr[i]; 
<a name="l01450"></a>01450   }
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 
<a name="l01453"></a>01453   <span class="keyword">static</span> <span class="keywordtype">void</span> quicksortLiterals(pair&lt;double,Predicate*&gt; items[], 
<a name="l01454"></a>01454                          <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; l, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; r)
<a name="l01455"></a>01455   {
<a name="l01456"></a>01456     <span class="keywordflow">if</span> (l &gt;= r) <span class="keywordflow">return</span>;
<a name="l01457"></a>01457     pair&lt;double,Predicate*&gt; tmp = items[l];
<a name="l01458"></a>01458     items[l] = items[(l+r)/2];
<a name="l01459"></a>01459     items[(l+r)/2] = tmp;
<a name="l01460"></a>01460 
<a name="l01461"></a>01461     <span class="keywordtype">int</span> last = l;
<a name="l01462"></a>01462     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = l+1; i &lt;= r; i++)
<a name="l01463"></a>01463       <span class="keywordflow">if</span> (items[i].first &gt; items[l].first)
<a name="l01464"></a>01464       {
<a name="l01465"></a>01465         ++last;
<a name="l01466"></a>01466         tmp = items[last];
<a name="l01467"></a>01467         items[last] = items[i];
<a name="l01468"></a>01468         items[i] = tmp;
<a name="l01469"></a>01469       }
<a name="l01470"></a>01470     
<a name="l01471"></a>01471     tmp = items[l];
<a name="l01472"></a>01472     items[l] = items[last];
<a name="l01473"></a>01473     items[last] = tmp;
<a name="l01474"></a>01474     quicksortLiterals(items, l, last-1);
<a name="l01475"></a>01475     quicksortLiterals(items, last+1, r);  
<a name="l01476"></a>01476   }
<a name="l01477"></a>01477 
<a name="l01478"></a>01478 
<a name="l01479"></a>01479     <span class="comment">// sort literals in decreasing order of (# true groundings/# groundings)</span>
<a name="l01480"></a>01480   <span class="keywordtype">void</span> sortLiteralsByTrueDivTotalGroundings(<a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; clauseLits,
<a name="l01481"></a>01481                                             <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l01482"></a>01482                                             <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db)<span class="keyword"> const</span>
<a name="l01483"></a>01483 <span class="keyword">  </span>{
<a name="l01484"></a>01484     assert(predicates_-&gt;size() == clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l01485"></a>01485 
<a name="l01486"></a>01486     <a class="code" href="classArray.html">Array&lt;pair&lt;double, Predicate*&gt;</a> &gt; arr;
<a name="l01487"></a>01487     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01488"></a>01488     {
<a name="l01489"></a>01489       <a class="code" href="classPredicate.html">Predicate</a>* lit = clauseLits[i];
<a name="l01490"></a>01490     
<a name="l01491"></a>01491         <span class="comment">// put all the grounded literal in the front</span>
<a name="l01492"></a>01492       <span class="keywordflow">if</span> (lit-&gt;<a class="code" href="classPredicate.html#e6080bac705952c80d73174270b8eb94">isGrounded</a>()) 
<a name="l01493"></a>01493       {
<a name="l01494"></a>01494         arr.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(pair&lt;double,Predicate*&gt;(DBL_MAX, lit));
<a name="l01495"></a>01495         <span class="keywordflow">continue</span>;
<a name="l01496"></a>01496       }
<a name="l01497"></a>01497 
<a name="l01498"></a>01498         <span class="comment">//estimate how likely the literal is true</span>
<a name="l01499"></a>01499       <span class="keywordtype">double</span> numTrue = (lit-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>())? db-&gt;<a class="code" href="classDatabase.html#28df1bfc97685059a7d07618d9f4ff38">getNumTrueGndPreds</a>(lit-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>())
<a name="l01500"></a>01500                                          :db-&gt;<a class="code" href="classDatabase.html#77d79369c06fb38238f47bbed87dbef4">getNumFalseGndPreds</a>(lit-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>());
<a name="l01501"></a>01501       <span class="keywordtype">double</span> numTotal = lit-&gt;<a class="code" href="classPredicate.html#8e9da7915ff4c54791d3b54f002ee09a">getNumGroundingsIfAllVarDiff</a>(domain);
<a name="l01502"></a>01502 
<a name="l01503"></a>01503         <span class="comment">//get number of groundings of the literal</span>
<a name="l01504"></a>01504       <span class="keywordtype">double</span> numGnd = 1;
<a name="l01505"></a>01505 
<a name="l01506"></a>01506       <a class="code" href="classArray.html">Array&lt;int&gt;</a> varIds; <span class="comment">//used to check unique var ids. A hash_set is slower.</span>
<a name="l01507"></a>01507       varIds.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(lit-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(),1);
<a name="l01508"></a>01508       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; lit-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(); i++)
<a name="l01509"></a>01509       {
<a name="l01510"></a>01510         <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* t = lit-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(i);
<a name="l01511"></a>01511         <span class="keywordflow">if</span> (t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() == Term::VARIABLE)
<a name="l01512"></a>01512         {
<a name="l01513"></a>01513           <span class="keywordtype">int</span> tid = t-&gt;<a class="code" href="classTerm.html#d03dd7ef78e7b209f60bb0b128c1d6f1">getId</a>();
<a name="l01514"></a>01514           <span class="keywordflow">if</span> (!varIds.<a class="code" href="classArray.html#88285e0c0c3d5f499f4a897844044b65">contains</a>(tid))
<a name="l01515"></a>01515           {
<a name="l01516"></a>01516             varIds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(tid);
<a name="l01517"></a>01517             numGnd *= domain-&gt;<a class="code" href="classDomain.html#8d92b09ec41630e34409bfe662930d3a">getNumConstantsByType</a>(lit-&gt;<a class="code" href="classPredicate.html#38b27de49bbbc584fd416be7e5391250">getTermTypeAsInt</a>(i));
<a name="l01518"></a>01518           }
<a name="l01519"></a>01519         }
<a name="l01520"></a>01520         assert(t-&gt;<a class="code" href="classTerm.html#75bc6e1d8b75e504702debda40decb6c">getType</a>() != Term::FUNCTION);
<a name="l01521"></a>01521       }
<a name="l01522"></a>01522 
<a name="l01523"></a>01523       arr.append(pair&lt;double,Predicate*&gt;(numTrue/numTotal/numGnd, lit));
<a name="l01524"></a>01524     }
<a name="l01525"></a>01525   
<a name="l01526"></a>01526     quicksortLiterals((pair&lt;double,Predicate*&gt;*) arr.getItems(),0,arr.size()-1);
<a name="l01527"></a>01527     assert(arr.size() == clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l01528"></a>01528     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; arr.size(); i++) clauseLits[i] = arr[i].second;
<a name="l01529"></a>01529   }
<a name="l01530"></a>01530 
<a name="l01531"></a>01531 
<a name="l01532"></a>01532   <span class="keyword">static</span> <span class="keywordtype">bool</span> literalOrSubsequentLiteralsAreTrue(<a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; lit,
<a name="l01533"></a>01533                                           <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; subseqLits,
<a name="l01534"></a>01534                                           <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db)
<a name="l01535"></a>01535   {
<a name="l01536"></a>01536     TruthValue tv = db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>(lit);
<a name="l01537"></a>01537     lit-&gt;setTruthValue(tv);
<a name="l01538"></a>01538     <span class="keywordflow">if</span> (db-&gt;<a class="code" href="classDatabase.html#d9ac7f6dd8191ac46a417e35622df48f">sameTruthValueAndSense</a>(tv,lit-&gt;getSense())) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01539"></a>01539     
<a name="l01540"></a>01540     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; subseqLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01541"></a>01541     {
<a name="l01542"></a>01542       tv = db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>(subseqLits[i]);
<a name="l01543"></a>01543       subseqLits[i]-&gt;setTruthValue(tv);
<a name="l01544"></a>01544       <span class="keywordflow">if</span> (db-&gt;<a class="code" href="classDatabase.html#d9ac7f6dd8191ac46a417e35622df48f">sameTruthValueAndSense</a>(tv,subseqLits[i]-&gt;getSense())) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01545"></a>01545     }
<a name="l01546"></a>01546     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01547"></a>01547   }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   <span class="keywordtype">bool</span> hasTwoLiteralsWithOppSense()<span class="keyword"> const</span>
<a name="l01551"></a>01551 <span class="keyword">  </span>{    
<a name="l01552"></a>01552     PredicateSet predSet; <span class="comment">// used to detect duplicates</span>
<a name="l01553"></a>01553     PredicateSet::iterator iter;
<a name="l01554"></a>01554     
<a name="l01555"></a>01555     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l01556"></a>01556     {
<a name="l01557"></a>01557       <a class="code" href="classPredicate.html">Predicate</a>* predicate = (*predicates_)[i];
<a name="l01558"></a>01558       assert(predicate-&gt;isGrounded());
<a name="l01559"></a>01559       <span class="keywordflow">if</span> (predicate-&gt;getTruthValue() == UNKNOWN)
<a name="l01560"></a>01560       {
<a name="l01561"></a>01561         <span class="keywordflow">if</span> ( (iter=predSet.find(predicate)) != predSet.end() )
<a name="l01562"></a>01562         {
<a name="l01563"></a>01563             <span class="comment">// the two gnd preds are of opp sense, so clause must be satisfied</span>
<a name="l01564"></a>01564           <span class="keywordflow">if</span> ((*iter)-&gt;getSense() !=  predicate-&gt;getSense()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01565"></a>01565         }
<a name="l01566"></a>01566         <span class="keywordflow">else</span>
<a name="l01567"></a>01567           predSet.insert(predicate);        
<a name="l01568"></a>01568       }
<a name="l01569"></a>01569     }
<a name="l01570"></a>01570       
<a name="l01571"></a>01571     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01572"></a>01572   }
<a name="l01573"></a>01573 
<a name="l01574"></a>01574 
<a name="l01575"></a>01575     <span class="comment">//returns true if the (ground) clause has two literals with opposite sense</span>
<a name="l01576"></a>01576     <span class="comment">//i.e. the clause is satisfied; otherwise returns false</span>
<a name="l01577"></a>01577   <span class="keywordtype">bool</span> createAndAddUnknownClause(<a class="code" href="classArray.html">Array&lt;GroundClause*&gt;</a>* <span class="keyword">const</span>&amp; unknownGndClauses,
<a name="l01578"></a>01578                                  <a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>* <span class="keyword">const</span>&amp; unknownClauses,
<a name="l01579"></a>01579                                  <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; numUnknownClauses,
<a name="l01580"></a>01580                                  <span class="keyword">const</span> <a class="code" href="structAddGroundClauseStruct.html">AddGroundClauseStruct</a>* <span class="keyword">const</span> &amp; agcs);
<a name="l01581"></a>01581 
<a name="l01582"></a>01582   <span class="keywordtype">bool</span> groundPredicates(<span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* <span class="keyword">const</span> &amp; set,
<a name="l01583"></a>01583                         <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; gndPredIndexes,
<a name="l01584"></a>01584                         <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred,
<a name="l01585"></a>01585                         <span class="keyword">const</span> TruthValue&amp; gndPredTV,
<a name="l01586"></a>01586                         <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l01587"></a>01587                         <span class="keywordtype">bool</span>&amp; sameTruthValueAndSense,
<a name="l01588"></a>01588                         <span class="keywordtype">bool</span>&amp; gndPredPosHaveSameSense)
<a name="l01589"></a>01589   {
<a name="l01590"></a>01590     sameTruthValueAndSense = <span class="keyword">false</span>;
<a name="l01591"></a>01591     gndPredPosHaveSameSense = <span class="keyword">true</span>;
<a name="l01592"></a>01592     <span class="keywordtype">bool</span> prevSense = <span class="keyword">false</span>;
<a name="l01593"></a>01593     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; set-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01594"></a>01594     {
<a name="l01595"></a>01595       <span class="keywordtype">int</span> gndPredIdx = gndPredIndexes[(*set)[i]];
<a name="l01596"></a>01596       <a class="code" href="classPredicate.html">Predicate</a>* pred = (*predicates_)[gndPredIdx];
<a name="l01597"></a>01597         <span class="comment">// if inconsistent grounding of variables, proceed to next combination</span>
<a name="l01598"></a>01598       <span class="keywordflow">if</span> (!pred-&gt;<a class="code" href="classPredicate.html#498a3099f82f9f523bd8680e4986c0a6">canBeGroundedAs</a>(gndPred)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01599"></a>01599       groundPredVars(gndPredIdx, gndPred);
<a name="l01600"></a>01600       <span class="keywordflow">if</span> (db-&gt;<a class="code" href="classDatabase.html#d9ac7f6dd8191ac46a417e35622df48f">sameTruthValueAndSense</a>(gndPredTV, pred-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>()))
<a name="l01601"></a>01601         sameTruthValueAndSense = <span class="keyword">true</span>;
<a name="l01602"></a>01602       <span class="keywordflow">if</span> (i == 0) 
<a name="l01603"></a>01603         prevSense = pred-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>();
<a name="l01604"></a>01604       <span class="keywordflow">else</span>
<a name="l01605"></a>01605       <span class="keywordflow">if</span> (prevSense != pred-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>())
<a name="l01606"></a>01606         gndPredPosHaveSameSense = <span class="keyword">false</span>;
<a name="l01607"></a>01607     }
<a name="l01608"></a>01608     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01609"></a>01609   }
<a name="l01610"></a>01610 
<a name="l01611"></a>01611 
<a name="l01612"></a>01612     <span class="comment">//count the number of groundings of clause variables</span>
<a name="l01613"></a>01613   <span class="keywordtype">double</span> countNumGroundings()
<a name="l01614"></a>01614   {
<a name="l01615"></a>01615     <span class="keywordtype">double</span> n = 1;
<a name="l01616"></a>01616     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; varIdToVarsGroundedType_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01617"></a>01617     {
<a name="l01618"></a>01618       <span class="keywordflow">if</span> (!((*varIdToVarsGroundedType_)[i]-&gt;isGrounded))
<a name="l01619"></a>01619         n *= (*varIdToVarsGroundedType_)[i]-&gt;numGndings;
<a name="l01620"></a>01620     }
<a name="l01621"></a>01621     <span class="keywordflow">return</span> n;
<a name="l01622"></a>01622   }
<a name="l01623"></a>01623   
<a name="l01624"></a>01624 
<a name="l01625"></a>01625   <span class="keyword">static</span> <span class="keywordtype">double</span> addCountToCombination(<span class="keywordtype">bool</span> inComb[], <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; inCombSize,
<a name="l01626"></a>01626                                <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* <span class="keyword">const</span> &amp; set,
<a name="l01627"></a>01627                                <a class="code" href="classMultDArray.html">MultDArray&lt;double&gt;</a>&amp; gndedPredPosArr,
<a name="l01628"></a>01628                                <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; count)
<a name="l01629"></a>01629   {
<a name="l01630"></a>01630     memset(inComb, <span class="keyword">false</span>, inCombSize*<span class="keyword">sizeof</span>(<span class="keywordtype">bool</span>));
<a name="l01631"></a>01631     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; set-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)  inComb[(*set)[i]] = <span class="keyword">true</span>;
<a name="l01632"></a>01632     <a class="code" href="classArray.html">Array&lt;int&gt;</a> multDArrIndexes(inCombSize); <span class="comment">//e.g. [0][1][0][1]</span>
<a name="l01633"></a>01633     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; inCombSize; i++)
<a name="l01634"></a>01634     {
<a name="l01635"></a>01635       <span class="keywordflow">if</span> (inComb[i]) multDArrIndexes.append(1);
<a name="l01636"></a>01636       <span class="keywordflow">else</span>           multDArrIndexes.append(0);    
<a name="l01637"></a>01637     }
<a name="l01638"></a>01638     gndedPredPosArr.<a class="code" href="classMultDArray.html#6da319cdc24314dc0479241345ab3c75">addItem</a>(&amp;multDArrIndexes, count);   
<a name="l01639"></a>01639     <span class="keywordflow">return</span> gndedPredPosArr.<a class="code" href="classMultDArray.html#d5d4822b2e435d3dca4ca974eb37db74">getItem</a>(&amp;multDArrIndexes);
<a name="l01640"></a>01640   }
<a name="l01641"></a>01641 
<a name="l01642"></a>01642   
<a name="l01643"></a>01643   <span class="keyword">static</span> <span class="keywordtype">void</span> minusRepeatedCounts(<span class="keywordtype">bool</span> inComb[], <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; inCombSize,
<a name="l01644"></a>01644                            <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; inCombIndexes,
<a name="l01645"></a>01645                            <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* <span class="keyword">const</span> &amp; set,
<a name="l01646"></a>01646                            <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* <span class="keyword">const</span> &amp; falseSet,
<a name="l01647"></a>01647                            <a class="code" href="classMultDArray.html">MultDArray&lt;double&gt;</a>&amp; gndedPredPosArr,
<a name="l01648"></a>01648                            <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; count)
<a name="l01649"></a>01649   {
<a name="l01650"></a>01650     memset(inComb, <span class="keyword">false</span>, inCombSize*<span class="keyword">sizeof</span>(<span class="keywordtype">bool</span>));
<a name="l01651"></a>01651     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; set-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)  inComb[(*set)[i]] = <span class="keyword">true</span>;
<a name="l01652"></a>01652     
<a name="l01653"></a>01653     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; falseSet-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01654"></a>01654     {
<a name="l01655"></a>01655       <span class="keywordtype">int</span> idx = inCombIndexes[(*falseSet)[i]];
<a name="l01656"></a>01656       assert(inComb[idx] == <span class="keyword">true</span>);
<a name="l01657"></a>01657       inComb[idx] = <span class="keyword">false</span>;
<a name="l01658"></a>01658     }
<a name="l01659"></a>01659     
<a name="l01660"></a>01660     <a class="code" href="classArray.html">Array&lt;int&gt;</a> multDArrIndexes(inCombSize); <span class="comment">//e.g. [0][1][0][1]</span>
<a name="l01661"></a>01661     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; inCombSize; i++)
<a name="l01662"></a>01662     {
<a name="l01663"></a>01663       <span class="keywordflow">if</span> (inComb[i]) multDArrIndexes.append(1);
<a name="l01664"></a>01664       <span class="keywordflow">else</span>           multDArrIndexes.append(0);    
<a name="l01665"></a>01665     }      
<a name="l01666"></a>01666     
<a name="l01667"></a>01667       <span class="comment">//subtract count from that of a smaller combination that includes it</span>
<a name="l01668"></a>01668     gndedPredPosArr.<a class="code" href="classMultDArray.html#6da319cdc24314dc0479241345ab3c75">addItem</a>(&amp;multDArrIndexes, -count);
<a name="l01669"></a>01669   }  
<a name="l01670"></a>01670 
<a name="l01671"></a>01671 
<a name="l01673"></a>01673   <span class="keywordtype">void</span> getBannedPreds(<a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; bannedPreds,
<a name="l01674"></a>01674                       <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; gndPredIdx,
<a name="l01675"></a>01675                       <span class="keyword">const</span> <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* <span class="keyword">const</span> &amp; groundPred,
<a name="l01676"></a>01676                       <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred)<span class="keyword"> const</span>
<a name="l01677"></a>01677 <span class="keyword">  </span>{
<a name="l01678"></a>01678     assert(gndPredIdx &lt; predicates_-&gt;size());
<a name="l01679"></a>01679     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndPredIdx; i++)
<a name="l01680"></a>01680     {
<a name="l01681"></a>01681       <span class="keywordflow">if</span> ( (groundPred &amp;&amp; (*predicates_)[i]-&gt;canBeGroundedAs(groundPred)) ||
<a name="l01682"></a>01682            (gndPred &amp;&amp; (*predicates_)[i]-&gt;canBeGroundedAs((<a class="code" href="classPredicate.html">Predicate</a>*)gndPred)))
<a name="l01683"></a>01683         bannedPreds.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*predicates_)[i]);
<a name="l01684"></a>01684     }
<a name="l01685"></a>01685   }
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 
<a name="l01688"></a>01688 
<a name="l01689"></a>01689   <span class="keyword">static</span> <span class="keywordtype">void</span> createBannedPreds(<a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; clauseLits,
<a name="l01690"></a>01690                          <a class="code" href="classArray.html">Array&lt;LitIdxVarIdsGndings*&gt;</a>&amp; ivgArr,
<a name="l01691"></a>01691                          <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; bannedPreds)
<a name="l01692"></a>01692   {
<a name="l01693"></a>01693     <span class="keywordflow">if</span> (bannedPreds.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == 0) <span class="keywordflow">return</span>;
<a name="l01694"></a>01694 
<a name="l01695"></a>01695     <span class="keywordtype">int</span> a;
<a name="l01696"></a>01696     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ivgArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01697"></a>01697     {
<a name="l01698"></a>01698       <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>* ivg = ivgArr[i];
<a name="l01699"></a>01699       a = bannedPreds.<a class="code" href="classArray.html#e5a7703acd6b54d55cd7c95b68262b09">find</a>(clauseLits[ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#fd978459f8faaf456f1d6fa5daee0249">litIdx</a>]);
<a name="l01700"></a>01700       <span class="keywordflow">if</span> (a &gt;= 0) ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#985fa95759e0302b3afb5cdd784eacf8">bannedPreds</a>.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(bannedPreds[a]);
<a name="l01701"></a>01701       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#cc6db92a2b936f1c6a18af0ff254e059">subseqGndLits</a>.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l01702"></a>01702       {
<a name="l01703"></a>01703         a = bannedPreds.<a class="code" href="classArray.html#e5a7703acd6b54d55cd7c95b68262b09">find</a>(ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#cc6db92a2b936f1c6a18af0ff254e059">subseqGndLits</a>[j]);
<a name="l01704"></a>01704         <span class="keywordflow">if</span> (a &gt;= 0) ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#985fa95759e0302b3afb5cdd784eacf8">bannedPreds</a>.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(bannedPreds[a]);        
<a name="l01705"></a>01705       }
<a name="l01706"></a>01706     }   
<a name="l01707"></a>01707   }
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 
<a name="l01710"></a>01710     <span class="comment">//the array parameter should be LitIdxVarIdsGndings.bannedGndPreds</span>
<a name="l01711"></a>01711   <span class="keyword">static</span> <span class="keywordtype">bool</span> bannedPredsAreGndedAsGndPred(
<a name="l01712"></a>01712                                 <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; bannedPreds,
<a name="l01713"></a>01713                                     <span class="keyword">const</span> <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* <span class="keyword">const</span> &amp; groundPred,
<a name="l01714"></a>01714                                     <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred)
<a name="l01715"></a>01715   {
<a name="l01716"></a>01716     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; bannedPreds.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01717"></a>01717     {
<a name="l01718"></a>01718       <span class="keywordflow">if</span> ( (groundPred &amp;&amp; bannedPreds[i]-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>(groundPred)) ||
<a name="l01719"></a>01719            (gndPred    &amp;&amp; bannedPreds[i]-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>((<a class="code" href="classPredicate.html">Predicate</a>*)gndPred)) ) 
<a name="l01720"></a>01720         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01721"></a>01721     }
<a name="l01722"></a>01722     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01723"></a>01723   }
<a name="l01724"></a>01724 
<a name="l01725"></a>01725 
<a name="l01726"></a>01726   <span class="keywordtype">bool</span> containsGndPredBeforeIdx(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; gndPredIdx, 
<a name="l01727"></a>01727                                 <span class="keyword">const</span> <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* <span class="keyword">const</span> &amp; groundPred,
<a name="l01728"></a>01728                                 <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred)
<a name="l01729"></a>01729   {
<a name="l01730"></a>01730     assert(gndPredIdx &lt; predicates_-&gt;size());
<a name="l01731"></a>01731  
<a name="l01732"></a>01732     <span class="keywordflow">if</span> (gndPredIdx &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01733"></a>01733 
<a name="l01734"></a>01734     <span class="keywordflow">if</span> (groundPred)
<a name="l01735"></a>01735     {
<a name="l01736"></a>01736       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndPredIdx; i++)
<a name="l01737"></a>01737         <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>(groundPred)) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01738"></a>01738     }
<a name="l01739"></a>01739     <span class="keywordflow">else</span>
<a name="l01740"></a>01740     {
<a name="l01741"></a>01741       assert(gndPred);
<a name="l01742"></a>01742       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndPredIdx; i++)
<a name="l01743"></a>01743         <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>((<a class="code" href="classPredicate.html">Predicate</a>*)gndPred)) <span class="keywordflow">return</span> <span class="keyword">true</span>; 
<a name="l01744"></a>01744     }
<a name="l01745"></a>01745     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01746"></a>01746   }
<a name="l01747"></a>01747 
<a name="l01748"></a>01748 
<a name="l01750"></a>01750 
<a name="l01751"></a>01751     <span class="comment">//Even though it is more intuitive to use a recursive function to count</span>
<a name="l01752"></a>01752     <span class="comment">//the number of true groundings, we are not doing so in order to allow the </span>
<a name="l01753"></a>01753     <span class="comment">//compiler to inline it.</span>
<a name="l01754"></a>01754     <span class="comment">//Returns the number of true groundings, unknown clauses, number of unknown</span>
<a name="l01755"></a>01755     <span class="comment">//clauses, and satisfiability</span>
<a name="l01756"></a>01756     <span class="comment">//If gndPredId &gt;= 0, the returned clauses do not contain groundPred/gndPred </span>
<a name="l01757"></a>01757     <span class="comment">//before position gndPredIdx</span>
<a name="l01758"></a>01758     <span class="comment">//No more than one of the array parameters can be non-NULL.</span>
<a name="l01759"></a>01759     <span class="comment">//No more than one of the groundPred/gndPred parameters can be non-NULL  </span>
<a name="l01760"></a>01760   <span class="keywordtype">double</span> countNumTrueGroundings(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l01761"></a>01761                                 <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l01762"></a>01762                                 <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds,
<a name="l01763"></a>01763                                 <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; checkSatOnly,
<a name="l01764"></a>01764                                   <span class="comment">//params below: find unknown clauses</span>
<a name="l01765"></a>01765                                 <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; gndPredIdx,
<a name="l01766"></a>01766                                 <span class="keyword">const</span> <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* <span class="keyword">const</span> &amp; groundPred,
<a name="l01767"></a>01767                                 <span class="keyword">const</span> <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred,
<a name="l01768"></a>01768                                 <a class="code" href="classArray.html">Array&lt;GroundClause*&gt;</a>* <span class="keyword">const</span> &amp; unknownGndClauses,
<a name="l01769"></a>01769                                 <a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>* <span class="keyword">const</span> &amp; unknownClauses,
<a name="l01770"></a>01770                                 <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; numUnknownClauses,
<a name="l01771"></a>01771                                   <span class="comment">//params below: add unknown clauses to MRF</span>
<a name="l01772"></a>01772                                 <span class="keyword">const</span> <a class="code" href="structAddGroundClauseStruct.html">AddGroundClauseStruct</a>* <span class="keyword">const</span> &amp; agcs)
<a name="l01773"></a>01773   {
<a name="l01774"></a>01774     assert(unknownGndClauses == NULL || unknownClauses == NULL);
<a name="l01775"></a>01775     assert(groundPred == NULL || gndPred == NULL);
<a name="l01776"></a>01776 
<a name="l01777"></a>01777     <span class="keywordflow">if</span> (numUnknownClauses) *numUnknownClauses = 0;
<a name="l01778"></a>01778 
<a name="l01779"></a>01779     <span class="keywordtype">bool</span> findUnknownClauses = (unknownGndClauses || unknownClauses || 
<a name="l01780"></a>01780                                numUnknownClauses || agcs);
<a name="l01781"></a>01781       <span class="comment">// these predicates must not be grounded as groundPred/gndPred</span>
<a name="l01782"></a>01782     <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a> bannedPreds;
<a name="l01783"></a>01783     <span class="keywordflow">if</span> (findUnknownClauses)
<a name="l01784"></a>01784       getBannedPreds(bannedPreds, gndPredIdx, groundPred, gndPred);
<a name="l01785"></a>01785 
<a name="l01786"></a>01786     <span class="keywordtype">double</span> numTrueGndings = 0;
<a name="l01787"></a>01787     
<a name="l01788"></a>01788       <span class="comment">//Copy the literals so that their original order in the clause is</span>
<a name="l01789"></a>01789       <span class="comment">//not affected by the subsequent sorting</span>
<a name="l01790"></a>01790     <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a> clauseLits(*predicates_);
<a name="l01791"></a>01791 
<a name="l01792"></a>01792       <span class="comment">//Sort preds in decreasing order of #TrueGndOfLiteral/#numOfGroundings.</span>
<a name="l01793"></a>01793       <span class="comment">//The larger the number of true groundings of a literal, the more likely</span>
<a name="l01794"></a>01794       <span class="comment">//it is to be true, so put it in front so that we can decide whether the</span>
<a name="l01795"></a>01795       <span class="comment">//clause is true early.The larger the number of groundings of the literal,</span>
<a name="l01796"></a>01796       <span class="comment">//the larger the savings when we decide that preceding literals are true.</span>
<a name="l01797"></a>01797     sortLiteralsByTrueDivTotalGroundings(clauseLits, domain, db);
<a name="l01798"></a>01798 
<a name="l01799"></a>01799       <span class="comment">//simulate a stack, back/front corresponds to top/bottom</span>
<a name="l01800"></a>01800       <span class="comment">//ivg stands for index, varIds, groundings</span>
<a name="l01801"></a>01801     <a class="code" href="classArray.html">Array&lt;LitIdxVarIdsGndings*&gt;</a> ivgArr;
<a name="l01802"></a>01802     createAllLitIdxVarsGndings(clauseLits, ivgArr, domain, <span class="keyword">true</span>);
<a name="l01803"></a>01803     <span class="keywordflow">if</span> (findUnknownClauses) createBannedPreds(clauseLits, ivgArr, bannedPreds);
<a name="l01804"></a>01804     <span class="keywordtype">int</span> ivgArrIdx = 0; <span class="comment">//store current position in ivgArr</span>
<a name="l01805"></a>01805     <span class="keywordtype">bool</span> lookAtNextLit = <span class="keyword">false</span>;
<a name="l01806"></a>01806     
<a name="l01807"></a>01807       <span class="comment">// while stack is not empty</span>
<a name="l01808"></a>01808     <span class="keywordflow">while</span> (ivgArrIdx &gt;= 0)
<a name="l01809"></a>01809     {
<a name="l01810"></a>01810         <span class="comment">//get variable groundings at top of stack</span>
<a name="l01811"></a>01811       <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>* ivg = ivgArr[ivgArrIdx];
<a name="l01812"></a>01812       <a class="code" href="classPredicate.html">Predicate</a>* lit = clauseLits[ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#fd978459f8faaf456f1d6fa5daee0249">litIdx</a>];
<a name="l01813"></a>01813       <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; varIds = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#5cccf5441cb65de5dd090ff2f082f136">varIds</a>;
<a name="l01814"></a>01814       <a class="code" href="classArraysAccessor.html">ArraysAccessor&lt;int&gt;</a>&amp; varGndings = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#64044243c9c5015955cd1b002c4a2b65">varGndings</a>;
<a name="l01815"></a>01815       <span class="keywordtype">bool</span>&amp; litUnseen = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#450fcde593ca0c72883fffc79861ec28">litUnseen</a>;
<a name="l01816"></a>01816       <span class="keywordtype">bool</span> hasComb;
<a name="l01817"></a>01817 
<a name="l01818"></a>01818         <span class="comment">// while there are groundings of literal's variables</span>
<a name="l01819"></a>01819       <span class="keywordflow">while</span> ((hasComb=varGndings.<a class="code" href="classArraysAccessor.html#918e7f43b7168775cc0a56daf10997e4">hasNextCombination</a>()) || litUnseen)
<a name="l01820"></a>01820       {
<a name="l01821"></a>01821           <span class="comment">// there may be no combinations if the literal is fully grounded</span>
<a name="l01822"></a>01822         <span class="keywordflow">if</span> (litUnseen) litUnseen = <span class="keyword">false</span>;
<a name="l01823"></a>01823 
<a name="l01824"></a>01824         <span class="keywordflow">if</span> (hasComb)
<a name="l01825"></a>01825         {
<a name="l01826"></a>01826             <span class="comment">//ground the literal's variables throughout the clause</span>
<a name="l01827"></a>01827           <span class="keywordtype">int</span> constId;
<a name="l01828"></a>01828           <span class="keywordtype">int</span> v = 0; <span class="comment">// index of varIds</span>
<a name="l01829"></a>01829             <span class="comment">//for each variable in literal</span>
<a name="l01830"></a>01830           <span class="keywordflow">while</span>(varGndings.<a class="code" href="classArraysAccessor.html#fbb7373c9a45c3abee42fbb2e22b2197">nextItemInCombination</a>(constId))
<a name="l01831"></a>01831           {
<a name="l01832"></a>01832             <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars =(*varIdToVarsGroundedType_)[-varIds[v++]]-&gt;vars;
<a name="l01833"></a>01833             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) vars[i]-&gt;setId(constId);
<a name="l01834"></a>01834           }
<a name="l01835"></a>01835           
<a name="l01836"></a>01836           <span class="comment">//return values of grounded functions are assigned to their parent</span>
<a name="l01837"></a>01837           <span class="comment">//terms in literalOrSubsequentLiteralsAreTrue()</span>
<a name="l01838"></a>01838         }
<a name="l01839"></a>01839 
<a name="l01840"></a>01840           <span class="comment">//if literal or subsequent grounded literals are true,</span>
<a name="l01841"></a>01841         <span class="keywordflow">if</span> (literalOrSubsequentLiteralsAreTrue(lit, ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#cc6db92a2b936f1c6a18af0ff254e059">subseqGndLits</a>, db))
<a name="l01842"></a>01842         {
<a name="l01843"></a>01843           <span class="keywordflow">if</span> (checkSatOnly) <span class="keywordflow">return</span> 1;
<a name="l01844"></a>01844             <span class="comment">//count the number of combinations of remaining variables</span>
<a name="l01845"></a>01845           <span class="keywordtype">double</span> numComb = 1;
<a name="l01846"></a>01846           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = ivgArrIdx+1; i &lt; ivgArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01847"></a>01847           {
<a name="l01848"></a>01848             <span class="keywordtype">int</span> numVar = ivgArr[i]-&gt;varGndings.<a class="code" href="classArraysAccessor.html#0fff369a0a183aff9d5b177b65d927c8">getNumArrays</a>();
<a name="l01849"></a>01849             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numVar; j++)
<a name="l01850"></a>01850               numComb *= ivgArr[i]-&gt;varGndings.<a class="code" href="classArraysAccessor.html#5af1996870106f083a7a7bba6bbf538b">getArray</a>(j)-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>();
<a name="l01851"></a>01851           }
<a name="l01852"></a>01852           numTrueGndings += numComb;
<a name="l01853"></a>01853         }
<a name="l01854"></a>01854         <span class="keywordflow">else</span>
<a name="l01855"></a>01855         <span class="keywordflow">if</span> (findUnknownClauses &amp;&amp; 
<a name="l01856"></a>01856             bannedPredsAreGndedAsGndPred(ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#985fa95759e0302b3afb5cdd784eacf8">bannedPreds</a>, groundPred, gndPred))
<a name="l01857"></a>01857         {
<a name="l01858"></a>01858           <span class="comment">//do nothing, will move down stack later</span>
<a name="l01859"></a>01859         }
<a name="l01860"></a>01860         <span class="keywordflow">else</span>
<a name="l01861"></a>01861         {
<a name="l01862"></a>01862             <span class="comment">// if there are more literals</span>
<a name="l01863"></a>01863           <span class="keywordflow">if</span> (ivgArrIdx+1 &lt; ivgArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>())
<a name="l01864"></a>01864           {
<a name="l01865"></a>01865             lookAtNextLit = <span class="keyword">true</span>;
<a name="l01866"></a>01866             ivgArrIdx++; <span class="comment">// move up stack</span>
<a name="l01867"></a>01867             <span class="keywordflow">break</span>;
<a name="l01868"></a>01868           }
<a name="l01869"></a>01869             <span class="comment">//At this point all the literals are grounded, and they are either</span>
<a name="l01870"></a>01870             <span class="comment">//unknown or false (have truth values opposite of their senses).</span>
<a name="l01871"></a>01871 
<a name="l01872"></a>01872           <span class="keywordtype">bool</span> twoLitWithOppSense = <span class="keyword">false</span>;
<a name="l01873"></a>01873           <span class="keywordflow">if</span> (hasUnknownPreds)
<a name="l01874"></a>01874           {
<a name="l01875"></a>01875             <span class="keywordflow">if</span> (hasTwoLiteralsWithOppSense()) 
<a name="l01876"></a>01876             {
<a name="l01877"></a>01877               twoLitWithOppSense = <span class="keyword">true</span>;
<a name="l01878"></a>01878               ++numTrueGndings;
<a name="l01879"></a>01879               <span class="keywordflow">if</span> (checkSatOnly) <span class="keywordflow">return</span> 1;
<a name="l01880"></a>01880             }
<a name="l01881"></a>01881           }
<a name="l01882"></a>01882 
<a name="l01883"></a>01883           <span class="keywordflow">if</span> (!twoLitWithOppSense &amp;&amp; findUnknownClauses)
<a name="l01884"></a>01884           {
<a name="l01885"></a>01885             assert(!containsGndPredBeforeIdx(gndPredIdx, groundPred, gndPred));
<a name="l01886"></a>01886 
<a name="l01887"></a>01887               <span class="comment">//Create a new clause by appending unknown predicates to it.</span>
<a name="l01888"></a>01888             createAndAddUnknownClause(unknownGndClauses, unknownClauses, 
<a name="l01889"></a>01889                                       numUnknownClauses, agcs);
<a name="l01890"></a>01890           }
<a name="l01891"></a>01891         }
<a name="l01892"></a>01892       } <span class="comment">//while there are groundings of literal's variables</span>
<a name="l01893"></a>01893 
<a name="l01894"></a>01894         <span class="comment">//if we exit the while loop in order to look at next literal </span>
<a name="l01895"></a>01895         <span class="comment">//(i.e. without considering all groundings of current literal)</span>
<a name="l01896"></a>01896       <span class="keywordflow">if</span> (lookAtNextLit) { lookAtNextLit = <span class="keyword">false</span>; }
<a name="l01897"></a>01897       <span class="keywordflow">else</span> { varGndings.<a class="code" href="classArraysAccessor.html#fad0b102fd84cce2c9ba94fea8b9fe16">reset</a>(); litUnseen = <span class="keyword">true</span>; ivgArrIdx--; }<span class="comment">//mv down stack</span>
<a name="l01898"></a>01898 
<a name="l01899"></a>01899     } <span class="comment">// while stack is not empty</span>
<a name="l01900"></a>01900 
<a name="l01901"></a>01901     deleteAllLitIdxVarsGndings(ivgArr);
<a name="l01902"></a>01902 
<a name="l01903"></a>01903     <span class="keywordflow">return</span> numTrueGndings;
<a name="l01904"></a>01904   }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906 
<a name="l01907"></a>01907   <span class="keywordtype">double</span> countNumTrueGroundingsForAllComb(<span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; gndPredIndexes,
<a name="l01908"></a>01908                                           <a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred,
<a name="l01909"></a>01909                                           <span class="keyword">const</span> TruthValue&amp; gndPredTV,
<a name="l01910"></a>01910                                           <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; gndPredFlipped,
<a name="l01911"></a>01911                                           <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l01912"></a>01912                                           <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasUnknownPreds,
<a name="l01913"></a>01913                                           <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; sampleClauses)
<a name="l01914"></a>01914   {
<a name="l01915"></a>01915     assert(varIdToVarsGroundedType_);
<a name="l01916"></a>01916     <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* db = domain-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>();
<a name="l01917"></a>01917     <span class="keywordtype">double</span> count = 0;
<a name="l01918"></a>01918     <span class="keywordtype">int</span> inCombSize = gndPredIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>();
<a name="l01919"></a>01919     <span class="keywordtype">bool</span>* inComb = <span class="keyword">new</span> <span class="keywordtype">bool</span>[inCombSize];
<a name="l01920"></a>01920 
<a name="l01921"></a>01921       <span class="comment">//initialize the number of true groundings for each way grounding the</span>
<a name="l01922"></a>01922       <span class="comment">//predicates represented by gndPredIndexes.</span>
<a name="l01923"></a>01923       <span class="comment">//e.g. gndedPredPosArr[0][0][1][1] is the number of true groundings when</span>
<a name="l01924"></a>01924       <span class="comment">//the 1st and 2nd predicates in gndPredIndexes are not grounded and</span>
<a name="l01925"></a>01925       <span class="comment">//the 3rd and 4th are grounded</span>
<a name="l01926"></a>01926     <a class="code" href="classArray.html">Array&lt;int&gt;</a> dim;
<a name="l01927"></a>01927     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndPredIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) dim.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(2);
<a name="l01928"></a>01928       <span class="comment">//WARNING: this may take up a lot of memory when gndPred can be grounded</span>
<a name="l01929"></a>01929       <span class="comment">//at many positions in the clause</span>
<a name="l01930"></a>01930     <a class="code" href="classMultDArray.html">MultDArray&lt;double&gt;</a> gndedPredPosArr(&amp;dim);
<a name="l01931"></a>01931     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;double&gt;</a>* oneDArray = gndedPredPosArr.<a class="code" href="classMultDArray.html#360ba4e34f2cebe2693ed6b1a6737bd9">get1DArray</a>();
<a name="l01932"></a>01932     <span class="keywordtype">double</span>* oneDArrayItems = (<span class="keywordtype">double</span>*) oneDArray-&gt;<a class="code" href="classArray.html#db9fecfda9dfefea1421efc3ae010049">getItems</a>();
<a name="l01933"></a>01933     memset(oneDArrayItems, 0, oneDArray-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()*<span class="keyword">sizeof</span>(double));
<a name="l01934"></a>01934 
<a name="l01935"></a>01935       <span class="comment">//for each possible combination of grounding the predicates</span>
<a name="l01936"></a>01936       <span class="comment">//(represented by gndPredIndexes) as gndPred</span>
<a name="l01937"></a>01937     <a class="code" href="classPowerSet.html">PowerSet</a>* ps = <a class="code" href="classPowerSet.html#bc634b7142178d6af0e54d3e76398615">PowerSet::getPowerSet</a>();
<a name="l01938"></a>01938       <span class="comment">//the combinations are accessed in order of decreasing size</span>
<a name="l01939"></a>01939     ps-&gt;<a class="code" href="classPowerSet.html#fa991500e71c969c8f1077f9d711ce3f">prepareAccess</a>(gndPredIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(), <span class="keyword">false</span>);
<a name="l01940"></a>01940 
<a name="l01941"></a>01941     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* set;
<a name="l01942"></a>01942     <span class="keywordflow">while</span>(ps-&gt;<a class="code" href="classPowerSet.html#d5133688ddbb794fd92287fb0ab01a9b">getNextSet</a>(set))
<a name="l01943"></a>01943     {
<a name="l01944"></a>01944         <span class="comment">//ground the predicates in current combination</span>
<a name="l01945"></a>01945       <span class="keywordtype">bool</span> sameTruthValueAndSense; <span class="comment">//a ground pred has the same tv and sense</span>
<a name="l01946"></a>01946       <span class="keywordtype">bool</span> gndPredPosSameSense;
<a name="l01947"></a>01947       <span class="keywordtype">bool</span> valid = groundPredicates(set, gndPredIndexes, gndPred, gndPredTV, db,
<a name="l01948"></a>01948                                     sameTruthValueAndSense,gndPredPosSameSense);
<a name="l01949"></a>01949 
<a name="l01950"></a>01950         <span class="comment">//If it is not possible to ground the predicates according to current</span>
<a name="l01951"></a>01951         <span class="comment">//combination or the grounded predicates are not all of the same sense,</span>
<a name="l01952"></a>01952         <span class="comment">//then skip the combination.</span>
<a name="l01953"></a>01953         <span class="comment">//We can ignore the combination when the grounded predicates are not all</span>
<a name="l01954"></a>01954         <span class="comment">//of the same sense because the counts when gndPred is held to true and</span>
<a name="l01955"></a>01955         <span class="comment">//false cancel one another out exactly</span>
<a name="l01956"></a>01956       <span class="keywordflow">if</span> (!valid || !gndPredPosSameSense) { restoreVars(); <span class="keywordflow">continue</span>; }
<a name="l01957"></a>01957       
<a name="l01958"></a>01958         <span class="comment">//count number of true groundings</span>
<a name="l01959"></a>01959       <span class="keywordtype">double</span> cnt, numGndings = countNumGroundings();
<a name="l01960"></a>01960 
<a name="l01961"></a>01961         <span class="comment">//if any of the grounded predicates has the same truth value and sense</span>
<a name="l01962"></a>01962       <span class="keywordflow">if</span> (sameTruthValueAndSense)
<a name="l01963"></a>01963         cnt = numGndings;
<a name="l01964"></a>01964       <span class="keywordflow">else</span>
<a name="l01965"></a>01965       {
<a name="l01966"></a>01966         <span class="keywordtype">double</span> samp; <span class="keywordtype">int</span> np;
<a name="l01967"></a>01967         <span class="keywordtype">bool</span> toSampleClauses = (sampleClauses &amp;&amp; (np=predicates_-&gt;size()) &gt; 1 &amp;&amp;
<a name="l01968"></a>01968                                 (samp = clauseSampler_-&gt;<a class="code" href="classClauseSampler.html#ac9250e3d6c3236fb3cbc42e97a9cabd">computeNumSamples</a>(np))
<a name="l01969"></a>01969                                 &lt; numGndings);
<a name="l01970"></a>01970         <span class="comment">//commented out: for testing sampling only</span>
<a name="l01971"></a>01971         <span class="comment">//toSampleClauses = (sampleClauses &amp;&amp; np &gt; 1);</span>
<a name="l01972"></a>01972 
<a name="l01973"></a>01973         <span class="keywordflow">if</span> (toSampleClauses)
<a name="l01974"></a>01974         {
<a name="l01975"></a>01975           <a class="code" href="classPredicate.html">Predicate</a>* flippedGndPred = (gndPredFlipped) ? gndPred : NULL;
<a name="l01976"></a>01976           cnt = clauseSampler_-&gt;<a class="code" href="classClauseSampler.html#f650f43ad18d67c481384494beab189a">estimateNumTrueGroundings</a>(<span class="keyword">this</span>, flippedGndPred,
<a name="l01977"></a>01977                                                           domain, samp);
<a name="l01978"></a>01978           <span class="keywordflow">if</span> (cnt &gt; numGndings) cnt = numGndings;
<a name="l01979"></a>01979           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cnt &lt; 0)     cnt = 0;
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981         <span class="keywordflow">else</span>
<a name="l01982"></a>01982           cnt = countNumTrueGroundings(domain, db, hasUnknownPreds, <span class="keyword">false</span>,
<a name="l01983"></a>01983                                        -1, NULL, NULL, NULL, NULL, NULL, NULL);
<a name="l01984"></a>01984       }
<a name="l01985"></a>01985 
<a name="l01986"></a>01986         <span class="comment">// add cnt to that of current combination</span>
<a name="l01987"></a>01987       <span class="keywordtype">double</span> cntDueToThisComb
<a name="l01988"></a>01988         = addCountToCombination(inComb,inCombSize,set,gndedPredPosArr,cnt);
<a name="l01989"></a>01989       count += cntDueToThisComb;
<a name="l01990"></a>01990 
<a name="l01991"></a>01991       <span class="comment">//for (int i = 0; i &lt; inCombSize; i++)  cout &lt;&lt; ((int) inComb[i]) &lt;&lt; " ";</span>
<a name="l01992"></a>01992       <span class="comment">//cout &lt;&lt; " = " &lt;&lt; cntDueToThisComb &lt;&lt; "/" &lt;&lt; cnt &lt;&lt; endl;</span>
<a name="l01993"></a>01993     
<a name="l01994"></a>01994         <span class="comment">//find the indexes that are in this combination</span>
<a name="l01995"></a>01995       <a class="code" href="classArray.html">Array&lt;int&gt;</a> inCombIndexes;
<a name="l01996"></a>01996       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; set-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)  inCombIndexes.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*set)[i]);
<a name="l01997"></a>01997 
<a name="l01998"></a>01998         <span class="comment">// subtract all the repeated counts of cntDueToThisComb</span>
<a name="l01999"></a>01999       <a class="code" href="structPowerSetInstanceVars.html">PowerSetInstanceVars</a> psInstVars;
<a name="l02000"></a>02000       ps-&gt;<a class="code" href="classPowerSet.html#fa991500e71c969c8f1077f9d711ce3f">prepareAccess</a>(inCombIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(), psInstVars);
<a name="l02001"></a>02001       <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>* falseSet;
<a name="l02002"></a>02002       <span class="keywordflow">while</span> (ps-&gt;<a class="code" href="classPowerSet.html#d5133688ddbb794fd92287fb0ab01a9b">getNextSet</a>(falseSet, psInstVars))
<a name="l02003"></a>02003       {
<a name="l02004"></a>02004           <span class="comment">// at least one of the predicates must be gnded as gndPred</span>
<a name="l02005"></a>02005         <span class="keywordflow">if</span> (falseSet-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == set-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()) <span class="keywordflow">continue</span>;
<a name="l02006"></a>02006         minusRepeatedCounts(inComb, inCombSize, inCombIndexes, set, falseSet,
<a name="l02007"></a>02007                             gndedPredPosArr, cntDueToThisComb);
<a name="l02008"></a>02008       }
<a name="l02009"></a>02009       restoreVars();
<a name="l02010"></a>02010     } <span class="comment">//for each possible combination of grounding the predicates as gndPred</span>
<a name="l02011"></a>02011     <span class="keyword">delete</span> [] inComb;
<a name="l02012"></a>02012     <span class="keywordflow">return</span> count;
<a name="l02013"></a>02013   }
<a name="l02014"></a>02014 
<a name="l02015"></a>02015 
<a name="l02016"></a>02016     <span class="comment">// Returns true if the ground clause was active </span>
<a name="l02017"></a>02017   <span class="keywordtype">bool</span> createAndAddActiveClause(
<a name="l02018"></a>02018                             <a class="code" href="classArray.html">Array&lt;GroundClause *&gt;</a> * <span class="keyword">const</span> &amp; activeGroundClauses,
<a name="l02019"></a>02019                                 <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>* <span class="keyword">const</span>&amp; seenGndPreds,
<a name="l02020"></a>02020                                 <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l02021"></a>02021                                 <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; getSatisfied);
<a name="l02022"></a>02022   
<a name="l02023"></a>02023   <span class="keywordtype">bool</span> isActive(<span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db)
<a name="l02024"></a>02024   {
<a name="l02025"></a>02025     PredicateSet predSet; <span class="comment">// used to detect duplicates</span>
<a name="l02026"></a>02026     PredicateSet::iterator iter;
<a name="l02027"></a>02027     <span class="keywordtype">bool</span> isEmpty = <span class="keyword">true</span>;
<a name="l02028"></a>02028  
<a name="l02029"></a>02029     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l02030"></a>02030     {
<a name="l02031"></a>02031       <a class="code" href="classPredicate.html">Predicate</a>* predicate = (*predicates_)[i];
<a name="l02032"></a>02032       assert(predicate); 
<a name="l02033"></a>02033           assert(predicate-&gt;isGrounded());
<a name="l02034"></a>02034       <span class="keywordflow">if</span> ( (iter=predSet.find(predicate)) != predSet.end() )
<a name="l02035"></a>02035       {
<a name="l02036"></a>02036           <span class="comment">// the two gnd preds are of opp sense, so clause must be satisfied</span>
<a name="l02037"></a>02037             <span class="keywordflow">if</span> (wt_ &gt;= 0 &amp;&amp; (*iter)-&gt;getSense() !=  predicate-&gt;getSense())
<a name="l02038"></a>02038                   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02039"></a>02039         <span class="keywordflow">continue</span>;
<a name="l02040"></a>02040           }
<a name="l02041"></a>02041       <span class="keywordflow">else</span>
<a name="l02042"></a>02042         predSet.insert(predicate);
<a name="l02043"></a>02043           
<a name="l02044"></a>02044       <span class="keywordtype">bool</span> isEvidence = db-&gt;<a class="code" href="classDatabase.html#dc72bc31bf15a485b7353fa82291dbb9">getEvidenceStatus</a>(predicate);
<a name="l02045"></a>02045           <span class="keywordflow">if</span> (!isEvidence)
<a name="l02046"></a>02046         isEmpty = <span class="keyword">false</span>;
<a name="l02047"></a>02047     }
<a name="l02048"></a>02048     <span class="keywordflow">return</span> !isEmpty;
<a name="l02049"></a>02049   }
<a name="l02050"></a>02050 
<a name="l02051"></a>02051   <span class="comment">// Assumption: clause has pos. weight</span>
<a name="l02052"></a>02052 <span class="keywordtype">bool</span> isUnsatisfiedGivenActivePreds(<a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; lit,
<a name="l02053"></a>02053                                    <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; subseqLits,
<a name="l02054"></a>02054                                    <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l02055"></a>02055                                                                    <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; ignoreActivePreds)
<a name="l02056"></a>02056 {
<a name="l02057"></a>02057         <span class="comment">// If atom has been deactivated, then we don't want any clauses that it's in</span>
<a name="l02058"></a>02058 <span class="comment">//cout &lt;&lt; "ignoreActivePreds " &lt;&lt; ignoreActivePreds &lt;&lt; endl;</span>
<a name="l02059"></a>02059 <span class="comment">//cout &lt;&lt; "lit "; lit-&gt;printWithStrVar(cout, db-&gt;getDomain()); cout &lt;&lt; endl;</span>
<a name="l02060"></a>02060   <span class="keywordflow">if</span> (db-&gt;<a class="code" href="classDatabase.html#1c459bc03d0e73b3d51eafae6b9d5151">getDeactivatedStatus</a>(lit)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02061"></a>02061   <span class="keywordtype">bool</span> active = <span class="keyword">false</span>;
<a name="l02062"></a>02062   <span class="keywordflow">if</span>(!ignoreActivePreds)
<a name="l02063"></a>02063         active = db-&gt;<a class="code" href="classDatabase.html#a57622c524765825fb8ca985d84733b0">getActiveStatus</a>(lit);
<a name="l02064"></a>02064 <span class="comment">//cout &lt;&lt; "active " &lt;&lt; active &lt;&lt; endl;</span>
<a name="l02065"></a>02065   TruthValue tv = db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>(lit);
<a name="l02066"></a>02066   lit-&gt;<a class="code" href="classPredicate.html#4c79867498e7d91ba127e22e7b54a91e">setTruthValue</a>(tv);
<a name="l02067"></a>02067 <span class="comment">//cout &lt;&lt; "tv  " &lt;&lt; tv &lt;&lt; endl;</span>
<a name="l02068"></a>02068   <span class="keywordflow">if</span> (!active &amp;&amp; db-&gt;<a class="code" href="classDatabase.html#d9ac7f6dd8191ac46a417e35622df48f">sameTruthValueAndSense</a>(tv, lit-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>())) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02069"></a>02069     <span class="comment">//cout&lt;&lt;"okies *** came here.."&lt;&lt;endl;</span>
<a name="l02070"></a>02070   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; subseqLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l02071"></a>02071   {
<a name="l02072"></a>02072 <span class="comment">//cout &lt;&lt; "subseqLit " &lt;&lt; i &lt;&lt; " ";</span>
<a name="l02073"></a>02073 <span class="comment">//subseqLits[i]-&gt;printWithStrVar(cout, db-&gt;getDomain());</span>
<a name="l02074"></a>02074 <span class="comment">//cout &lt;&lt; endl;</span>
<a name="l02075"></a>02075     <span class="keywordflow">if</span> (!ignoreActivePreds)
<a name="l02076"></a>02076           active = db-&gt;<a class="code" href="classDatabase.html#a57622c524765825fb8ca985d84733b0">getActiveStatus</a>(subseqLits[i]);
<a name="l02077"></a>02077 <span class="comment">//cout &lt;&lt; "active " &lt;&lt; active &lt;&lt; endl;</span>
<a name="l02078"></a>02078     tv = db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>(subseqLits[i]);
<a name="l02079"></a>02079     subseqLits[i]-&gt;setTruthValue(tv);
<a name="l02080"></a>02080 <span class="comment">//cout &lt;&lt; "tv  " &lt;&lt; tv &lt;&lt; endl;</span>
<a name="l02081"></a>02081     <span class="keywordflow">if</span> (!active &amp;&amp; db-&gt;<a class="code" href="classDatabase.html#d9ac7f6dd8191ac46a417e35622df48f">sameTruthValueAndSense</a>(tv,subseqLits[i]-&gt;getSense()))
<a name="l02082"></a>02082       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02083"></a>02083   }
<a name="l02084"></a>02084   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02085"></a>02085 }
<a name="l02086"></a>02086 
<a name="l02087"></a>02087 
<a name="l02088"></a>02088   <span class="comment">// Assumption: clause has neg. weight</span>
<a name="l02089"></a>02089 <span class="keywordtype">bool</span> isSatisfiedGivenActivePreds(<span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* <span class="keyword">const</span> &amp; db,
<a name="l02090"></a>02090                                  <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; ignoreActivePreds)
<a name="l02091"></a>02091 {
<a name="l02092"></a>02092   <span class="keywordtype">bool</span> isSatisfied = <span class="keyword">false</span>;
<a name="l02093"></a>02093   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l02094"></a>02094   {
<a name="l02095"></a>02095     <a class="code" href="classPredicate.html">Predicate</a>* lit = <a class="code" href="classClause.html#3b9114866b1e944b818faaf35cf106d3">getPredicate</a>(i);
<a name="l02096"></a>02096     assert(lit-&gt;<a class="code" href="classPredicate.html#e6080bac705952c80d73174270b8eb94">isGrounded</a>());
<a name="l02097"></a>02097       <span class="comment">// If atom has been deactivated, then we don't want any clauses</span>
<a name="l02098"></a>02098       <span class="comment">// that it's in</span>
<a name="l02099"></a>02099     <span class="keywordflow">if</span> (db-&gt;<a class="code" href="classDatabase.html#1c459bc03d0e73b3d51eafae6b9d5151">getDeactivatedStatus</a>(lit)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02100"></a>02100     <span class="keywordtype">bool</span> active = <span class="keyword">false</span>;
<a name="l02101"></a>02101     <span class="keywordtype">bool</span> evidence = <span class="keyword">false</span>;
<a name="l02102"></a>02102     <span class="keywordflow">if</span>(!ignoreActivePreds)
<a name="l02103"></a>02103       active = db-&gt;<a class="code" href="classDatabase.html#a57622c524765825fb8ca985d84733b0">getActiveStatus</a>(lit);
<a name="l02104"></a>02104     
<a name="l02105"></a>02105     TruthValue tv = db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>(lit);
<a name="l02106"></a>02106     lit-&gt;<a class="code" href="classPredicate.html#4c79867498e7d91ba127e22e7b54a91e">setTruthValue</a>(tv);
<a name="l02107"></a>02107       <span class="comment">// If true evidence atom is in clause, then clause is always satisfied</span>
<a name="l02108"></a>02108       <span class="comment">// and we want to ignore it.</span>
<a name="l02109"></a>02109     evidence = db-&gt;<a class="code" href="classDatabase.html#dc72bc31bf15a485b7353fa82291dbb9">getEvidenceStatus</a>(lit);
<a name="l02110"></a>02110 
<a name="l02111"></a>02111 <span class="comment">//cout &lt;&lt; "Lit: ";</span>
<a name="l02112"></a>02112 <span class="comment">//lit-&gt;printWithStrVar(cout, db-&gt;getDomain());</span>
<a name="l02113"></a>02113 <span class="comment">//cout &lt;&lt; " ev. " &lt;&lt; evidence &lt;&lt; " act. " &lt;&lt; active &lt;&lt; " stvas "</span>
<a name="l02114"></a>02114 <span class="comment">//       &lt;&lt; db-&gt;sameTruthValueAndSense(tv, lit-&gt;getSense()) &lt;&lt; endl;</span>
<a name="l02115"></a>02115     <span class="keywordflow">if</span> (evidence &amp;&amp; db-&gt;<a class="code" href="classDatabase.html#d9ac7f6dd8191ac46a417e35622df48f">sameTruthValueAndSense</a>(tv, lit-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>()))
<a name="l02116"></a>02116       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02117"></a>02117       <span class="comment">// Any active atom in clause or any true non-active atom</span>
<a name="l02118"></a>02118       <span class="comment">// means it is candidate for active clause</span>
<a name="l02119"></a>02119     <span class="keywordflow">if</span> (active || db-&gt;<a class="code" href="classDatabase.html#d9ac7f6dd8191ac46a417e35622df48f">sameTruthValueAndSense</a>(tv, lit-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>()))
<a name="l02120"></a>02120       isSatisfied = <span class="keyword">true</span>;
<a name="l02121"></a>02121   }
<a name="l02122"></a>02122   <span class="keywordflow">return</span> isSatisfied;
<a name="l02123"></a>02123 }
<a name="l02124"></a>02124 
<a name="l02125"></a>02125 
<a name="l02126"></a>02126   <span class="comment">// Sort literals for use by the inverted index.</span>
<a name="l02127"></a>02127   <span class="comment">// For pos. clauses: negative literals first, then of increasing arity</span>
<a name="l02128"></a>02128   <span class="comment">// For neg. clauses: positive literals first, then of increasing arity</span>
<a name="l02129"></a>02129 <span class="keywordtype">void</span> sortLiteralsByNegationAndArity(<a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; clauseLits)
<a name="l02130"></a>02130 {
<a name="l02131"></a>02131   <span class="comment">//cout &lt;&lt; "Sorting lits by neg. and arity:" &lt;&lt; endl;</span>
<a name="l02132"></a>02132   assert(predicates_-&gt;size() == clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l02133"></a>02133 
<a name="l02134"></a>02134   <a class="code" href="classArray.html">Array&lt;pair&lt;double, Predicate*&gt;</a> &gt; arr;
<a name="l02135"></a>02135   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l02136"></a>02136   {
<a name="l02137"></a>02137     <a class="code" href="classPredicate.html">Predicate</a>* lit = clauseLits[i];
<a name="l02138"></a>02138     
<a name="l02139"></a>02139       <span class="comment">// Put all the grounded literals in the front</span>
<a name="l02140"></a>02140     <span class="keywordflow">if</span> (lit-&gt;<a class="code" href="classPredicate.html#e6080bac705952c80d73174270b8eb94">isGrounded</a>()) 
<a name="l02141"></a>02141     {
<a name="l02142"></a>02142       arr.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(pair&lt;double,Predicate*&gt;(DBL_MAX, lit));
<a name="l02143"></a>02143       <span class="keywordflow">continue</span>;
<a name="l02144"></a>02144     }
<a name="l02145"></a>02145 <span class="comment">/*</span>
<a name="l02146"></a>02146 <span class="comment">          // Pos. clause: negative literals of arity two next</span>
<a name="l02147"></a>02147 <span class="comment">        if (!lit-&gt;getSense())</span>
<a name="l02148"></a>02148 <span class="comment">        {</span>
<a name="l02149"></a>02149 <span class="comment">          if (wt_ &gt;= 0 &amp;&amp; lit-&gt;getNumTerms() == 2)</span>
<a name="l02150"></a>02150 <span class="comment">                arr.append(pair&lt;double,Predicate*&gt;((double)lit-&gt;getNumTerms(), lit));</span>
<a name="l02151"></a>02151 <span class="comment">          else</span>
<a name="l02152"></a>02152 <span class="comment">                arr.append(pair&lt;double,Predicate*&gt;(-(double)lit-&gt;getNumTerms(), lit));          </span>
<a name="l02153"></a>02153 <span class="comment">          continue;</span>
<a name="l02154"></a>02154 <span class="comment">        }</span>
<a name="l02155"></a>02155 <span class="comment"></span>
<a name="l02156"></a>02156 <span class="comment">      // Neg. clause: positive literals of arity two next</span>
<a name="l02157"></a>02157 <span class="comment">    if (lit-&gt;getSense())</span>
<a name="l02158"></a>02158 <span class="comment">    {</span>
<a name="l02159"></a>02159 <span class="comment">      if (wt_ &lt; 0 &amp;&amp; lit-&gt;getNumTerms() == 2)</span>
<a name="l02160"></a>02160 <span class="comment">        arr.append(pair&lt;double,Predicate*&gt;((double)lit-&gt;getNumTerms(), lit));</span>
<a name="l02161"></a>02161 <span class="comment">      else</span>
<a name="l02162"></a>02162 <span class="comment">        arr.append(pair&lt;double,Predicate*&gt;(-(double)lit-&gt;getNumTerms(), lit));      </span>
<a name="l02163"></a>02163 <span class="comment">    }</span>
<a name="l02164"></a>02164 <span class="comment">*/</span>
<a name="l02165"></a>02165     <span class="keywordflow">if</span> (lit-&gt;<a class="code" href="classPredicate.html#afca824b5e8c30d8f94012c2ed49afa0">isIndexable</a>(wt_ &gt;= 0))
<a name="l02166"></a>02166       arr.append(pair&lt;double,Predicate*&gt;((<span class="keywordtype">double</span>)lit-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(), lit));
<a name="l02167"></a>02167     <span class="keywordflow">else</span>
<a name="l02168"></a>02168       arr.append(pair&lt;double,Predicate*&gt;(-(<span class="keywordtype">double</span>)lit-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>(), lit));      
<a name="l02169"></a>02169   }
<a name="l02170"></a>02170   
<a name="l02171"></a>02171   quicksortLiterals((pair&lt;double,Predicate*&gt;*) arr.getItems(),0,arr.size()-1);
<a name="l02172"></a>02172   assert(arr.size() == clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l02173"></a>02173   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; arr.size(); i++)
<a name="l02174"></a>02174   {
<a name="l02175"></a>02175         clauseLits[i] = arr[i].second;
<a name="l02176"></a>02176         <span class="comment">//cout &lt;&lt; clauseLits[i]-&gt;getSense() &lt;&lt; " " &lt;&lt; clauseLits[i]-&gt;getName()</span>
<a name="l02177"></a>02177     <span class="comment">//     &lt;&lt; endl;</span>
<a name="l02178"></a>02178   }
<a name="l02179"></a>02179 }
<a name="l02180"></a>02180 
<a name="l02181"></a>02181 
<a name="l02182"></a>02182   <span class="comment">//Assumes clauseLits is ordered so that indexable lits are in the front</span>
<a name="l02183"></a>02183 <span class="keywordtype">void</span> groundIndexableLiterals(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l02184"></a>02184                              <a class="code" href="classArray.html">Array&lt;GroundClause *&gt;</a> * <span class="keyword">const</span> &amp; activeGroundClauses,
<a name="l02185"></a>02185                              <span class="keywordtype">int</span> &amp; activeClauseCnt,
<a name="l02186"></a>02186                              <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>* <span class="keyword">const</span>&amp; seenGndPreds,
<a name="l02187"></a>02187                              <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>&amp; clauseLits,
<a name="l02188"></a>02188                              <span class="keywordtype">int</span> litIdx, <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; ignoreActivePreds,
<a name="l02189"></a>02189                              <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; getSatisfied)
<a name="l02190"></a>02190 {
<a name="l02191"></a>02191   <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* db = domain-&gt;getDB();
<a name="l02192"></a>02192 <span class="comment">//cout &lt;&lt; "litIdx " &lt;&lt; litIdx &lt;&lt; endl;</span>
<a name="l02193"></a>02193 <span class="comment">//cout &lt;&lt; "clauseLits size " &lt;&lt; clauseLits.size() &lt;&lt; endl;</span>
<a name="l02194"></a>02194 <span class="comment">//cout &lt;&lt; "clauseLits start ";</span>
<a name="l02195"></a>02195 <span class="comment">/*</span>
<a name="l02196"></a>02196 <span class="comment">for (int i = 0; i &lt; clauseLits.size(); i++)</span>
<a name="l02197"></a>02197 <span class="comment">{</span>
<a name="l02198"></a>02198 <span class="comment">  if (clauseLits[i])</span>
<a name="l02199"></a>02199 <span class="comment">  {</span>
<a name="l02200"></a>02200 <span class="comment">  cout &lt;&lt; i &lt;&lt; " ";</span>
<a name="l02201"></a>02201 <span class="comment">  clauseLits[i]-&gt;printWithStrVar(cout, db-&gt;getDomain());</span>
<a name="l02202"></a>02202 <span class="comment">  cout &lt;&lt; " ";</span>
<a name="l02203"></a>02203 <span class="comment">  }</span>
<a name="l02204"></a>02204 <span class="comment">}</span>
<a name="l02205"></a>02205 <span class="comment">*/</span>
<a name="l02206"></a>02206 <span class="comment">//cout &lt;&lt; endl;</span>
<a name="l02207"></a>02207 <span class="comment">//cout &lt;&lt; "LIT ";</span>
<a name="l02208"></a>02208 <span class="comment">//clauseLits[litIdx]-&gt;printWithStrVar(cout, db-&gt;getDomain());</span>
<a name="l02209"></a>02209 <span class="comment">//cout &lt;&lt; endl;</span>
<a name="l02210"></a>02210   <span class="keywordtype">bool</span> posClause = (wt_ &gt;= 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l02211"></a>02211   <span class="keywordflow">if</span> (clauseLits[litIdx]-&gt;isIndexable(posClause))
<a name="l02212"></a>02212   {
<a name="l02213"></a>02213           <span class="comment">// Branch and bound on indexable literals</span>
<a name="l02214"></a>02214         <a class="code" href="classArray.html">Array&lt;Predicate *&gt;</a>* indexedGndings = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Predicate *&gt;</a>;
<a name="l02215"></a>02215           <span class="comment">// Bound</span>
<a name="l02216"></a>02216         ((<a class="code" href="classDatabase.html">Database</a> *)db)-&gt;<a class="code" href="classDatabase.html#e61759c1d48c5ac3d2a3b7dfe56301df">getIndexedGndings</a>(indexedGndings, clauseLits[litIdx],
<a name="l02217"></a>02217                                         ignoreActivePreds);
<a name="l02218"></a>02218 <span class="comment">/*</span>
<a name="l02219"></a>02219 <span class="comment">cout &lt;&lt; "indexedGndings: " &lt;&lt; endl;</span>
<a name="l02220"></a>02220 <span class="comment">for (int i = 0; i &lt; indexedGndings-&gt;size(); i ++)</span>
<a name="l02221"></a>02221 <span class="comment">{</span>
<a name="l02222"></a>02222 <span class="comment">  cout &lt;&lt; "\t";</span>
<a name="l02223"></a>02223 <span class="comment">  (*indexedGndings)[i]-&gt;printWithStrVar(cout, domain);</span>
<a name="l02224"></a>02224 <span class="comment">  cout &lt;&lt; endl;</span>
<a name="l02225"></a>02225 <span class="comment">}</span>
<a name="l02226"></a>02226 <span class="comment">*/</span>
<a name="l02227"></a>02227       <span class="comment">// Branch on the indexed groundings</span>
<a name="l02228"></a>02228     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; indexedGndings-&gt;size(); i++)
<a name="l02229"></a>02229     {
<a name="l02230"></a>02230       <a class="code" href="classArray.html">Array&lt;int&gt;</a>* origVarIds = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>;
<a name="l02231"></a>02231         <span class="comment">// Ground variables throughout clause</span>
<a name="l02232"></a>02232       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; clauseLits[litIdx]-&gt;getNumTerms(); j++)
<a name="l02233"></a>02233       {
<a name="l02234"></a>02234         <span class="keyword">const</span> <a class="code" href="classTerm.html">Term</a>* term = clauseLits[litIdx]-&gt;getTerm(j);
<a name="l02235"></a>02235         <span class="keywordflow">if</span> (term-&gt;getType() == Term::VARIABLE)
<a name="l02236"></a>02236         {
<a name="l02237"></a>02237           <span class="keywordtype">int</span> varId = term-&gt;getId();
<a name="l02238"></a>02238           origVarIds-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(varId);
<a name="l02239"></a>02239           <span class="keywordtype">int</span> constId = (*indexedGndings)[i]-&gt;getTerm(j)-&gt;getId();
<a name="l02240"></a>02240           assert(constId &gt;= 0);
<a name="l02241"></a>02241           <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = (*varIdToVarsGroundedType_)[-varId]-&gt;vars;
<a name="l02242"></a>02242           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); k++) vars[k]-&gt;setId(constId);
<a name="l02243"></a>02243         }
<a name="l02244"></a>02244       }
<a name="l02245"></a>02245 
<a name="l02246"></a>02246         <span class="comment">// Save literal in tmp, then set to null</span>
<a name="l02247"></a>02247       <a class="code" href="classPredicate.html">Predicate</a>* tmpLit = clauseLits[litIdx];
<a name="l02248"></a>02248       clauseLits[litIdx] = NULL;
<a name="l02249"></a>02249       <span class="keyword">delete</span> (*indexedGndings)[i];
<a name="l02250"></a>02250       
<a name="l02251"></a>02251         <span class="comment">// Move to next literal</span>
<a name="l02252"></a>02252       <span class="keywordflow">if</span> (litIdx + 1 &lt; clauseLits.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>())
<a name="l02253"></a>02253             groundIndexableLiterals(domain, activeGroundClauses, activeClauseCnt,
<a name="l02254"></a>02254                                 seenGndPreds, clauseLits, litIdx + 1,
<a name="l02255"></a>02255                                 ignoreActivePreds, getSatisfied);
<a name="l02256"></a>02256 
<a name="l02257"></a>02257                 <span class="comment">// Restore literal and variables</span>
<a name="l02258"></a>02258           clauseLits[litIdx] = tmpLit;
<a name="l02259"></a>02259       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; origVarIds-&gt;size(); i++)
<a name="l02260"></a>02260       {
<a name="l02261"></a>02261         <span class="keywordtype">int</span> varId = (*origVarIds)[i];
<a name="l02262"></a>02262         assert(varId &lt; 0);
<a name="l02263"></a>02263         <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = (*varIdToVarsGroundedType_)[-varId]-&gt;vars;
<a name="l02264"></a>02264         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++) vars[j]-&gt;setId(varId);
<a name="l02265"></a>02265         (*varIdToVarsGroundedType_)[-varId]-&gt;isGrounded = <span class="keyword">false</span>;
<a name="l02266"></a>02266       }
<a name="l02267"></a>02267           <span class="keyword">delete</span> origVarIds;
<a name="l02268"></a>02268         }
<a name="l02269"></a>02269         <span class="keyword">delete</span> indexedGndings;
<a name="l02270"></a>02270         <span class="keywordflow">return</span>;
<a name="l02271"></a>02271   }
<a name="l02272"></a>02272   
<a name="l02273"></a>02273         <span class="comment">// All indexable literals are grounded, now deal with the others</span>
<a name="l02274"></a>02274   <a class="code" href="classArray.html">Array&lt;LitIdxVarIdsGndings*&gt;</a> ivgArr;
<a name="l02275"></a>02275     <span class="comment">// RIGHT</span>
<a name="l02276"></a>02276   createAllLitIdxVarsGndings(clauseLits, ivgArr, domain, <span class="keyword">false</span>);
<a name="l02277"></a>02277     <span class="comment">// WRONG</span>
<a name="l02278"></a>02278   <span class="comment">//createAllLitIdxVarsGndings(clauseLits, ivgArr, domain, true);</span>
<a name="l02279"></a>02279   <span class="keywordtype">int</span> ivgArrIdx = 0; <span class="comment">//store current position in ivgArr</span>
<a name="l02280"></a>02280   <span class="keywordtype">bool</span> lookAtNextLit = <span class="keyword">false</span>;
<a name="l02281"></a>02281 
<a name="l02282"></a>02282     <span class="comment">// while stack is not empty</span>
<a name="l02283"></a>02283   <span class="keywordflow">while</span> (ivgArrIdx &gt;= 0)
<a name="l02284"></a>02284   {
<a name="l02285"></a>02285       <span class="comment">//get variable groundings at top of stack</span>
<a name="l02286"></a>02286     <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>* ivg = ivgArr[ivgArrIdx];
<a name="l02287"></a>02287     <a class="code" href="classPredicate.html">Predicate</a>* lit = clauseLits[ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#fd978459f8faaf456f1d6fa5daee0249">litIdx</a>];
<a name="l02288"></a>02288 <span class="comment">/*</span>
<a name="l02289"></a>02289 <span class="comment">cout &lt;&lt; "LIT1 ";</span>
<a name="l02290"></a>02290 <span class="comment">lit-&gt;printWithStrVar(cout, db-&gt;getDomain());</span>
<a name="l02291"></a>02291 <span class="comment">cout &lt;&lt; endl;</span>
<a name="l02292"></a>02292 <span class="comment">cout &lt;&lt; "clauseLits size " &lt;&lt; clauseLits.size() &lt;&lt; endl;</span>
<a name="l02293"></a>02293 <span class="comment">cout &lt;&lt; "Rest of clauseLits ";</span>
<a name="l02294"></a>02294 <span class="comment">for (int i = 0; i &lt; clauseLits.size(); i++)</span>
<a name="l02295"></a>02295 <span class="comment">{</span>
<a name="l02296"></a>02296 <span class="comment">  if (clauseLits[i])</span>
<a name="l02297"></a>02297 <span class="comment">  {</span>
<a name="l02298"></a>02298 <span class="comment">  cout &lt;&lt; i &lt;&lt; " ";</span>
<a name="l02299"></a>02299 <span class="comment">  clauseLits[i]-&gt;printWithStrVar(cout, db-&gt;getDomain());</span>
<a name="l02300"></a>02300 <span class="comment">  cout &lt;&lt; " ";</span>
<a name="l02301"></a>02301 <span class="comment">  }</span>
<a name="l02302"></a>02302 <span class="comment">}</span>
<a name="l02303"></a>02303 <span class="comment">cout &lt;&lt; endl;</span>
<a name="l02304"></a>02304 <span class="comment">cout &lt;&lt; "Subseq. size " &lt;&lt; ivg-&gt;subseqGndLits.size() &lt;&lt; endl;</span>
<a name="l02305"></a>02305 <span class="comment">*/</span>
<a name="l02306"></a>02306     <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; varIds = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#5cccf5441cb65de5dd090ff2f082f136">varIds</a>;
<a name="l02307"></a>02307     <a class="code" href="classArraysAccessor.html">ArraysAccessor&lt;int&gt;</a>&amp; varGndings = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#64044243c9c5015955cd1b002c4a2b65">varGndings</a>;
<a name="l02308"></a>02308     <span class="keywordtype">bool</span>&amp; litUnseen = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#450fcde593ca0c72883fffc79861ec28">litUnseen</a>;
<a name="l02309"></a>02309     <span class="keywordtype">bool</span> hasComb;
<a name="l02310"></a>02310 
<a name="l02311"></a>02311       <span class="comment">// while there are groundings of literal's variables</span>
<a name="l02312"></a>02312     <span class="keywordflow">while</span> ((hasComb=varGndings.<a class="code" href="classArraysAccessor.html#918e7f43b7168775cc0a56daf10997e4">hasNextCombination</a>()) || litUnseen)
<a name="l02313"></a>02313     {
<a name="l02314"></a>02314         <span class="comment">// there may be no combinations if the literal is fully grounded</span>
<a name="l02315"></a>02315       <span class="keywordflow">if</span> (litUnseen) litUnseen = <span class="keyword">false</span>;
<a name="l02316"></a>02316 
<a name="l02317"></a>02317       <span class="keywordflow">if</span> (hasComb)
<a name="l02318"></a>02318       {
<a name="l02319"></a>02319           <span class="comment">//ground the literal's variables throughout the clause</span>
<a name="l02320"></a>02320         <span class="keywordtype">int</span> constId;
<a name="l02321"></a>02321         <span class="keywordtype">int</span> v = 0; <span class="comment">// index of varIds</span>
<a name="l02322"></a>02322           <span class="comment">//for each variable in literal</span>
<a name="l02323"></a>02323         <span class="keywordflow">while</span> (varGndings.<a class="code" href="classArraysAccessor.html#fbb7373c9a45c3abee42fbb2e22b2197">nextItemInCombination</a>(constId))
<a name="l02324"></a>02324         {
<a name="l02325"></a>02325           <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars = (*varIdToVarsGroundedType_)[-varIds[v++]]-&gt;vars;
<a name="l02326"></a>02326           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) vars[i]-&gt;setId(constId);
<a name="l02327"></a>02327         }
<a name="l02328"></a>02328       }
<a name="l02329"></a>02329         
<a name="l02330"></a>02330         <span class="comment">//proceed further only if:</span>
<a name="l02331"></a>02331         <span class="comment">// 1. positive weight and partially grounded clause is unsatisfied or</span>
<a name="l02332"></a>02332         <span class="comment">// 2. negative weight and partially grounded clause is satisfied</span>
<a name="l02333"></a>02333       <span class="keywordtype">bool</span> proceed = <span class="keyword">true</span>;
<a name="l02334"></a>02334       <span class="keywordflow">if</span> (wt_ &gt;= 0)
<a name="l02335"></a>02335         proceed = isUnsatisfiedGivenActivePreds(lit, ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#cc6db92a2b936f1c6a18af0ff254e059">subseqGndLits</a>, db,
<a name="l02336"></a>02336                                                 ignoreActivePreds);
<a name="l02337"></a>02337 
<a name="l02338"></a>02338 <span class="comment">//cout &lt;&lt; "Clause: ";</span>
<a name="l02339"></a>02339 <span class="comment">//printWithWtAndStrVar(cout, domain);</span>
<a name="l02340"></a>02340 <span class="comment">//cout &lt;&lt; endl;</span>
<a name="l02341"></a>02341 <span class="comment">//cout &lt;&lt; " proceed " &lt;&lt; proceed &lt;&lt; endl;</span>
<a name="l02342"></a>02342 
<a name="l02343"></a>02343       <span class="keywordflow">if</span> (proceed)
<a name="l02344"></a>02344       {
<a name="l02345"></a>02345                 <span class="comment">// if there are more literals</span>
<a name="l02346"></a>02346         <span class="keywordflow">if</span> (ivgArrIdx + 1 &lt; ivgArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>())
<a name="l02347"></a>02347         {
<a name="l02348"></a>02348           lookAtNextLit = <span class="keyword">true</span>;
<a name="l02349"></a>02349           ivgArrIdx++; <span class="comment">// move up stack</span>
<a name="l02350"></a>02350           <span class="keywordflow">break</span>;
<a name="l02351"></a>02351         }
<a name="l02352"></a>02352           <span class="comment">// Now we can check neg. clauses: if not satisfied (no true literals)</span>
<a name="l02353"></a>02353           <span class="comment">// or satisfied with evidence atom, then do not activate</span>
<a name="l02354"></a>02354         <span class="keywordflow">if</span> (wt_ &lt; 0 &amp;&amp;
<a name="l02355"></a>02355             !isSatisfiedGivenActivePreds(db, ignoreActivePreds))
<a name="l02356"></a>02356         {
<a name="l02357"></a>02357           <span class="keywordflow">continue</span>;
<a name="l02358"></a>02358         }
<a name="l02359"></a>02359                   
<a name="l02360"></a>02360           <span class="comment">// At this point all the literals are grounded</span>
<a name="l02361"></a>02361                   <span class="comment">// and does not have any true literal. To make sure that</span>
<a name="l02362"></a>02362                   <span class="comment">// it is active, need to check the following two conditions:</span>
<a name="l02363"></a>02363                   <span class="comment">// 1. It may have the same literal appearing in opposite senses =&gt;</span>
<a name="l02364"></a>02364           <span class="comment">// satisfied (and hence not active)</span>
<a name="l02365"></a>02365                   <span class="comment">// 2. It may be empty when evidence is pruned away =&gt; not active</span>
<a name="l02366"></a>02366     
<a name="l02367"></a>02367         <span class="keywordtype">bool</span> active;
<a name="l02368"></a>02368         <span class="keywordtype">bool</span> accumulateClauses = activeGroundClauses;
<a name="l02369"></a>02369         <span class="keywordflow">if</span> (!accumulateClauses)
<a name="l02370"></a>02370         {
<a name="l02371"></a>02371           active = isActive(db);
<a name="l02372"></a>02372         }
<a name="l02373"></a>02373         <span class="keywordflow">else</span>
<a name="l02374"></a>02374         {
<a name="l02375"></a>02375           active = createAndAddActiveClause(activeGroundClauses, seenGndPreds,
<a name="l02376"></a>02376                                             db, getSatisfied);
<a name="l02377"></a>02377         }
<a name="l02378"></a>02378 <span class="comment">//cout &lt;&lt; "Active " &lt;&lt; active &lt;&lt; endl;</span>
<a name="l02379"></a>02379         <span class="keywordflow">if</span> (active) activeClauseCnt++;
<a name="l02380"></a>02380       }
<a name="l02381"></a>02381     } <span class="comment">//while there are groundings of literal's variables</span>
<a name="l02382"></a>02382 
<a name="l02383"></a>02383       <span class="comment">//if we exit the while loop in order to look at next literal </span>
<a name="l02384"></a>02384       <span class="comment">//(i.e. without considering all groundings of current literal)</span>
<a name="l02385"></a>02385     <span class="keywordflow">if</span> (lookAtNextLit) { lookAtNextLit = <span class="keyword">false</span>; }
<a name="l02386"></a>02386     <span class="keywordflow">else</span> { varGndings.<a class="code" href="classArraysAccessor.html#fad0b102fd84cce2c9ba94fea8b9fe16">reset</a>(); litUnseen = <span class="keyword">true</span>; ivgArrIdx--; }<span class="comment">//mv down stack</span>
<a name="l02387"></a>02387 
<a name="l02388"></a>02388   } <span class="comment">// while stack is not empty</span>
<a name="l02389"></a>02389   deleteAllLitIdxVarsGndings(ivgArr);
<a name="l02390"></a>02390 }
<a name="l02391"></a>02391 
<a name="l02392"></a>02392 
<a name="l02393"></a>02393 
<a name="l02394"></a>02394 <span class="keywordtype">void</span> getActiveClausesAndCnt(<span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l02395"></a>02395                             <a class="code" href="classArray.html">Array&lt;GroundClause *&gt;</a> * <span class="keyword">const</span> &amp; activeGroundClauses,
<a name="l02396"></a>02396                             <span class="keywordtype">int</span> &amp; activeClauseCnt,
<a name="l02397"></a>02397                             <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>* <span class="keyword">const</span>&amp; seenGndPreds,
<a name="l02398"></a>02398                             <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; ignoreActivePreds,
<a name="l02399"></a>02399                             <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; getSatisfied)
<a name="l02400"></a>02400 {
<a name="l02401"></a>02401   activeClauseCnt = 0;
<a name="l02402"></a>02402   <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a> clauseLits(*predicates_);
<a name="l02403"></a>02403   <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* db = domain-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>();
<a name="l02404"></a>02404 
<a name="l02405"></a>02405 <span class="comment">//cout &lt;&lt; "Getting active clauses for FO Clause: ";</span>
<a name="l02406"></a>02406 <span class="comment">//printWithWtAndStrVar(cout, domain);</span>
<a name="l02407"></a>02407 <span class="comment">//cout &lt;&lt; endl;</span>
<a name="l02408"></a>02408 
<a name="l02409"></a>02409   <span class="keywordflow">if</span> (useInverseIndex)
<a name="l02410"></a>02410   {
<a name="l02411"></a>02411         sortLiteralsByNegationAndArity(clauseLits);
<a name="l02412"></a>02412         groundIndexableLiterals(domain, activeGroundClauses, activeClauseCnt,
<a name="l02413"></a>02413                             seenGndPreds, clauseLits, 0, ignoreActivePreds,
<a name="l02414"></a>02414                             getSatisfied);
<a name="l02415"></a>02415   }
<a name="l02416"></a>02416   <span class="keywordflow">else</span>
<a name="l02417"></a>02417   {
<a name="l02418"></a>02418           <span class="comment">//Sort preds in increasing order of #TrueGndOfLiteral/#numOfGroundings.</span>
<a name="l02419"></a>02419       <span class="comment">//The larger the number of true groundings of a literal, the more likely</span>
<a name="l02420"></a>02420       <span class="comment">//it is to be true, so put it in front so that we can decide whether the</span>
<a name="l02421"></a>02421       <span class="comment">//clause is true early.The larger the number of groundings of the literal,</span>
<a name="l02422"></a>02422       <span class="comment">//the larger the savings when we decide that preceding literals are true.</span>
<a name="l02423"></a>02423         sortLiteralsByTrueDivTotalGroundings(clauseLits, domain, db);
<a name="l02424"></a>02424 
<a name="l02425"></a>02425       <span class="comment">//simulate a stack, back/front corresponds to top/bottom</span>
<a name="l02426"></a>02426       <span class="comment">//ivg stands for index, varIds, groundings</span>
<a name="l02427"></a>02427         <a class="code" href="classArray.html">Array&lt;LitIdxVarIdsGndings*&gt;</a> ivgArr;
<a name="l02428"></a>02428         createAllLitIdxVarsGndings(clauseLits, ivgArr, domain, <span class="keyword">true</span>);
<a name="l02429"></a>02429         <span class="keywordtype">int</span> ivgArrIdx = 0; <span class="comment">//store current position in ivgArr</span>
<a name="l02430"></a>02430         <span class="keywordtype">bool</span> lookAtNextLit = <span class="keyword">false</span>;
<a name="l02431"></a>02431 
<a name="l02432"></a>02432       <span class="comment">// while stack is not empty</span>
<a name="l02433"></a>02433         <span class="keywordflow">while</span> (ivgArrIdx &gt;= 0)
<a name="l02434"></a>02434         {
<a name="l02435"></a>02435         <span class="comment">//get variable groundings at top of stack</span>
<a name="l02436"></a>02436       <a class="code" href="structLitIdxVarIdsGndings.html">LitIdxVarIdsGndings</a>* ivg = ivgArr[ivgArrIdx];
<a name="l02437"></a>02437       <a class="code" href="classPredicate.html">Predicate</a>* lit = clauseLits[ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#fd978459f8faaf456f1d6fa5daee0249">litIdx</a>];
<a name="l02438"></a>02438       <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; varIds = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#5cccf5441cb65de5dd090ff2f082f136">varIds</a>;
<a name="l02439"></a>02439       <a class="code" href="classArraysAccessor.html">ArraysAccessor&lt;int&gt;</a>&amp; varGndings = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#64044243c9c5015955cd1b002c4a2b65">varGndings</a>;
<a name="l02440"></a>02440       <span class="keywordtype">bool</span>&amp; litUnseen = ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#450fcde593ca0c72883fffc79861ec28">litUnseen</a>;
<a name="l02441"></a>02441       <span class="keywordtype">bool</span> hasComb;
<a name="l02442"></a>02442 
<a name="l02443"></a>02443         <span class="comment">// while there are groundings of literal's variables</span>
<a name="l02444"></a>02444       <span class="keywordflow">while</span> ((hasComb=varGndings.<a class="code" href="classArraysAccessor.html#918e7f43b7168775cc0a56daf10997e4">hasNextCombination</a>()) || litUnseen)
<a name="l02445"></a>02445       {
<a name="l02446"></a>02446           <span class="comment">// there may be no combinations if the literal is fully grounded</span>
<a name="l02447"></a>02447         <span class="keywordflow">if</span> (litUnseen) litUnseen = <span class="keyword">false</span>;
<a name="l02448"></a>02448 
<a name="l02449"></a>02449         <span class="keywordflow">if</span> (hasComb)
<a name="l02450"></a>02450         {
<a name="l02451"></a>02451                 <span class="comment">//ground the literal's variables throughout the clause</span>
<a name="l02452"></a>02452           <span class="keywordtype">int</span> constId;
<a name="l02453"></a>02453           <span class="keywordtype">int</span> v = 0; <span class="comment">// index of varIds</span>
<a name="l02454"></a>02454             <span class="comment">//for each variable in literal</span>
<a name="l02455"></a>02455           <span class="keywordflow">while</span> (varGndings.<a class="code" href="classArraysAccessor.html#fbb7373c9a45c3abee42fbb2e22b2197">nextItemInCombination</a>(constId))
<a name="l02456"></a>02456           {
<a name="l02457"></a>02457                 <a class="code" href="classArray.html">Array&lt;Term*&gt;</a>&amp; vars =
<a name="l02458"></a>02458               (*varIdToVarsGroundedType_)[-varIds[v++]]-&gt;vars;
<a name="l02459"></a>02459                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vars.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) vars[i]-&gt;setId(constId);
<a name="l02460"></a>02460           }
<a name="l02461"></a>02461         }
<a name="l02462"></a>02462        
<a name="l02463"></a>02463                   <span class="comment">//proceed further only if:</span>
<a name="l02464"></a>02464           <span class="comment">// 1. positive weight and partially grounded clause is unsatisfied or</span>
<a name="l02465"></a>02465           <span class="comment">// 2. negative weight and partially grounded clause is satisfied</span>
<a name="l02466"></a>02466         <span class="keywordtype">bool</span> proceed = <span class="keyword">true</span>;
<a name="l02467"></a>02467         <span class="keywordflow">if</span> (wt_ &gt;= 0 &amp;&amp; !getSatisfied)
<a name="l02468"></a>02468           proceed = isUnsatisfiedGivenActivePreds(lit, ivg-&gt;<a class="code" href="structLitIdxVarIdsGndings.html#cc6db92a2b936f1c6a18af0ff254e059">subseqGndLits</a>, db,
<a name="l02469"></a>02469                                                   ignoreActivePreds);
<a name="l02470"></a>02470 
<a name="l02471"></a>02471 <span class="comment">//cout &lt;&lt; "Clause: ";</span>
<a name="l02472"></a>02472 <span class="comment">//printWithWtAndStrVar(cout, domain);</span>
<a name="l02473"></a>02473 <span class="comment">//cout &lt;&lt; endl;</span>
<a name="l02474"></a>02474 <span class="comment">//cout &lt;&lt; " proceed " &lt;&lt; proceed &lt;&lt; endl;</span>
<a name="l02475"></a>02475 
<a name="l02476"></a>02476         <span class="keywordflow">if</span> (proceed)
<a name="l02477"></a>02477         {
<a name="l02478"></a>02478                         <span class="comment">// if there are more literals</span>
<a name="l02479"></a>02479           <span class="keywordflow">if</span> (ivgArrIdx + 1 &lt; ivgArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>())
<a name="l02480"></a>02480           {
<a name="l02481"></a>02481                 lookAtNextLit = <span class="keyword">true</span>;
<a name="l02482"></a>02482                 ivgArrIdx++; <span class="comment">// move up stack</span>
<a name="l02483"></a>02483                 <span class="keywordflow">break</span>;
<a name="l02484"></a>02484           }
<a name="l02485"></a>02485                   
<a name="l02486"></a>02486 <span class="comment">//cout &lt;&lt; "Clause: ";</span>
<a name="l02487"></a>02487 <span class="comment">//printWithWtAndStrVar(cout, domain);</span>
<a name="l02488"></a>02488 <span class="comment">//cout &lt;&lt; endl;</span>
<a name="l02489"></a>02489             <span class="comment">// Now we can check neg. clauses: if not satisfied (no true</span>
<a name="l02490"></a>02490             <span class="comment">// literals) or satisfied with evidence atom, then do not activate</span>
<a name="l02491"></a>02491           <span class="keywordflow">if</span> (wt_ &lt; 0 &amp;&amp; !getSatisfied &amp;&amp;
<a name="l02492"></a>02492               !isSatisfiedGivenActivePreds(db, ignoreActivePreds))
<a name="l02493"></a>02493           {
<a name="l02494"></a>02494             <span class="comment">//cout &lt;&lt; "continuing..." &lt;&lt; endl;</span>
<a name="l02495"></a>02495             <span class="keywordflow">continue</span>;
<a name="l02496"></a>02496           }
<a name="l02497"></a>02497           
<a name="l02498"></a>02498                 <span class="comment">// At this point all the literals are grounded</span>
<a name="l02499"></a>02499                         <span class="comment">// and does not have any true literal. To make sure that</span>
<a name="l02500"></a>02500                         <span class="comment">// it is active, need to check the following two conditions:</span>
<a name="l02501"></a>02501                         <span class="comment">// 1. It may have the same literal appearing in opposite senses =&gt;</span>
<a name="l02502"></a>02502             <span class="comment">// satisfied (and hence not active)</span>
<a name="l02503"></a>02503                         <span class="comment">// 2. It may be empty when evidence is pruned away =&gt; not active</span>
<a name="l02504"></a>02504                   <span class="keywordtype">bool</span> active;
<a name="l02505"></a>02505           <span class="keywordtype">bool</span> accumulateClauses = activeGroundClauses;
<a name="l02506"></a>02506           <span class="keywordflow">if</span> (!accumulateClauses)
<a name="l02507"></a>02507             active = isActive(db);
<a name="l02508"></a>02508           <span class="keywordflow">else</span>
<a name="l02509"></a>02509             active = createAndAddActiveClause(activeGroundClauses, seenGndPreds,
<a name="l02510"></a>02510                                               db, getSatisfied);
<a name="l02511"></a>02511             
<a name="l02512"></a>02512 <span class="comment">//cout &lt;&lt; "Active " &lt;&lt; active &lt;&lt; endl;</span>
<a name="l02513"></a>02513           <span class="keywordflow">if</span> (active) activeClauseCnt++;
<a name="l02514"></a>02514         }
<a name="l02515"></a>02515       } <span class="comment">//while there are groundings of literal's variables</span>
<a name="l02516"></a>02516 
<a name="l02517"></a>02517         <span class="comment">//if we exit the while loop in order to look at next literal </span>
<a name="l02518"></a>02518         <span class="comment">//(i.e. without considering all groundings of current literal)</span>
<a name="l02519"></a>02519       <span class="keywordflow">if</span> (lookAtNextLit) { lookAtNextLit = <span class="keyword">false</span>; }
<a name="l02520"></a>02520       <span class="keywordflow">else</span> { varGndings.<a class="code" href="classArraysAccessor.html#fad0b102fd84cce2c9ba94fea8b9fe16">reset</a>(); litUnseen = <span class="keyword">true</span>; ivgArrIdx--; }<span class="comment">//mv down stack</span>
<a name="l02521"></a>02521 
<a name="l02522"></a>02522         } <span class="comment">// while stack is not empty</span>
<a name="l02523"></a>02523     deleteAllLitIdxVarsGndings(ivgArr);
<a name="l02524"></a>02524   }
<a name="l02525"></a>02525 }
<a name="l02526"></a>02526 
<a name="l02527"></a>02527  
<a name="l02528"></a>02528   <span class="comment">//get Active Clauses unifying with the given predicate - if ignoreActivePreds </span>
<a name="l02529"></a>02529   <span class="comment">//is true, this is equivalent to getting all the unsatisfied clauses</span>
<a name="l02530"></a>02530 <span class="keywordtype">void</span> getActiveClausesAndCnt(<a class="code" href="classPredicate.html">Predicate</a>*  <span class="keyword">const</span> &amp; gndPred,
<a name="l02531"></a>02531                             <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l02532"></a>02532                             <a class="code" href="classArray.html">Array&lt;GroundClause *&gt;</a>* <span class="keyword">const</span> &amp; activeGroundClauses,
<a name="l02533"></a>02533                             <span class="keywordtype">int</span> &amp; activeClauseCnt,
<a name="l02534"></a>02534                             <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>* <span class="keyword">const</span>&amp; seenGndPreds,
<a name="l02535"></a>02535                             <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; ignoreActivePreds,
<a name="l02536"></a>02536                             <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; getSatisfied)
<a name="l02537"></a>02537 {
<a name="l02538"></a>02538     <span class="comment">//create mapping of variable ids (e.g. -1) to variable addresses,</span>
<a name="l02539"></a>02539     <span class="comment">//note whether they have been grounded, and store their types   </span>
<a name="l02540"></a>02540   createVarIdToVarsGroundedType(domain); 
<a name="l02541"></a>02541   <span class="keywordflow">if</span> (gndPred == NULL)
<a name="l02542"></a>02542   {
<a name="l02543"></a>02543     getActiveClausesAndCnt(domain, activeGroundClauses, activeClauseCnt,
<a name="l02544"></a>02544                            seenGndPreds, ignoreActivePreds, getSatisfied);
<a name="l02545"></a>02545     restoreVars();
<a name="l02546"></a>02546   }
<a name="l02547"></a>02547   <span class="keywordflow">else</span>
<a name="l02548"></a>02548   {
<a name="l02549"></a>02549         assert(gndPred-&gt;<a class="code" href="classPredicate.html#e6080bac705952c80d73174270b8eb94">isGrounded</a>());
<a name="l02550"></a>02550 
<a name="l02551"></a>02551         <span class="comment">//store the indexes of the predicates that can be grounded as gndPred</span>
<a name="l02552"></a>02552     <a class="code" href="classArray.html">Array&lt;int&gt;</a> gndPredIndexes;
<a name="l02553"></a>02553     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predicates_-&gt;size(); i++)
<a name="l02554"></a>02554           <span class="keywordflow">if</span> ((*predicates_)[i]-&gt;canBeGroundedAs(gndPred)) gndPredIndexes.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(i);
<a name="l02555"></a>02555     
<a name="l02556"></a>02556     <span class="keyword">const</span> <a class="code" href="classDatabase.html">Database</a>* db = domain-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>();
<a name="l02557"></a>02557     <a class="code" href="classArray.html">Array&lt;int&gt;</a> unarySet;
<a name="l02558"></a>02558         unarySet.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(-1);
<a name="l02559"></a>02559 
<a name="l02560"></a>02560         activeClauseCnt = 0;
<a name="l02561"></a>02561         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndPredIndexes.size(); i++)
<a name="l02562"></a>02562         {
<a name="l02563"></a>02563       <span class="comment">//ground the predicates in current combination</span>
<a name="l02564"></a>02564       <span class="keywordtype">bool</span> sameTruthValueAndSense; <span class="comment">//a ground pred has the same tv and sense</span>
<a name="l02565"></a>02565       <span class="keywordtype">bool</span> gndPredPosSameSense;
<a name="l02566"></a>02566       unarySet[0] = i; <span class="comment">//gndPredIndexes[i];</span>
<a name="l02567"></a>02567                 <span class="comment">//cout&lt;&lt;"size of unary predicate set "&lt;&lt;unarySet.size()&lt;&lt;endl;</span>
<a name="l02568"></a>02568                 <span class="comment">//cout&lt;&lt;"Element[0] = "&lt;&lt;unarySet[0]&lt;&lt;endl;</span>
<a name="l02569"></a>02569           groundPredicates(&amp;unarySet, gndPredIndexes, gndPred,
<a name="l02570"></a>02570                        gndPred-&gt;<a class="code" href="classPredicate.html#26aabf16a08c2db8abd7032b1ec0ecb9">getTruthValue</a>(), db,sameTruthValueAndSense,
<a name="l02571"></a>02571                        gndPredPosSameSense);
<a name="l02572"></a>02572       <span class="keywordtype">int</span> cnt;
<a name="l02573"></a>02573           getActiveClausesAndCnt(domain, activeGroundClauses, cnt, seenGndPreds,
<a name="l02574"></a>02574                              ignoreActivePreds, getSatisfied);
<a name="l02575"></a>02575           activeClauseCnt += cnt;
<a name="l02576"></a>02576           restoreVars();
<a name="l02577"></a>02577         }
<a name="l02578"></a>02578   }
<a name="l02579"></a>02579 
<a name="l02580"></a>02580   assert(!activeGroundClauses ||
<a name="l02581"></a>02581          activeGroundClauses-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == activeClauseCnt);
<a name="l02582"></a>02582 } 
<a name="l02583"></a>02583 
<a name="l02584"></a>02584 
<a name="l02585"></a>02585 <span class="keyword">public</span>:
<a name="l02586"></a>02586 
<a name="l02587"></a>02587 <span class="comment">//get Active Clauses unifying with the given predicate - if ignoreActivePreds </span>
<a name="l02588"></a>02588 <span class="comment">//is true, this is equivalent to getting all the unsatisfied clauses</span>
<a name="l02589"></a>02589 <span class="comment">// Returns the groundClauses</span>
<a name="l02590"></a><a class="code" href="classClause.html#e7d9bdbce92ec00ea4fcd71c4106b1d5">02590</a> <span class="keywordtype">void</span> <a class="code" href="classClause.html#e7d9bdbce92ec00ea4fcd71c4106b1d5">getActiveClauses</a>(<a class="code" href="classPredicate.html">Predicate</a>* <span class="keyword">const</span> &amp; gndPred, 
<a name="l02591"></a>02591                       <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l02592"></a>02592                       <a class="code" href="classArray.html">Array&lt;GroundClause *&gt;</a>* <span class="keyword">const</span> &amp; activeGroundClauses,
<a name="l02593"></a>02593                       <a class="code" href="classHashArray.html">GroundPredicateHashArray</a> * <span class="keyword">const</span> &amp; seenGndPreds,
<a name="l02594"></a>02594                                           <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; ignoreActivePreds)
<a name="l02595"></a>02595 {
<a name="l02596"></a>02596   <span class="keywordtype">int</span> cnt = 0;
<a name="l02597"></a>02597   <span class="keywordtype">bool</span> getSatisfied = <span class="keyword">false</span>;
<a name="l02598"></a>02598   getActiveClausesAndCnt(gndPred, domain, activeGroundClauses, cnt,
<a name="l02599"></a>02599                          seenGndPreds, ignoreActivePreds, getSatisfied);
<a name="l02600"></a>02600                          
<a name="l02601"></a>02601 } 
<a name="l02602"></a>02602 
<a name="l02603"></a>02603 
<a name="l02604"></a>02604 <span class="comment">//get the count of Active Clauses unifying with the given predicate</span>
<a name="l02605"></a>02605 <span class="comment">//- if ignoreActivePreds is true, this is equivalent to getting the</span>
<a name="l02606"></a>02606 <span class="comment">//count of all the unsatisfied clauses</span>
<a name="l02607"></a><a class="code" href="classClause.html#7adbdc645a2765837fbd1464bf36d92f">02607</a> <span class="keywordtype">int</span> <a class="code" href="classClause.html#7adbdc645a2765837fbd1464bf36d92f">getActiveClauseCnt</a>(<a class="code" href="classPredicate.html">Predicate</a>*  <span class="keyword">const</span> &amp; gndPred, 
<a name="l02608"></a>02608                        <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l02609"></a>02609                        <span class="keywordtype">bool</span> <span class="keyword">const</span> &amp; ignoreActivePreds)
<a name="l02610"></a>02610 {
<a name="l02611"></a>02611   <span class="keywordtype">int</span> cnt = 0;
<a name="l02612"></a>02612    
<a name="l02613"></a>02613   <a class="code" href="classArray.html">Array&lt;GroundClause *&gt;</a> *activeGroundClauses = NULL;
<a name="l02614"></a>02614   <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>* <span class="keyword">const</span> &amp; seenGndPreds = NULL;
<a name="l02615"></a>02615   <span class="keywordtype">bool</span> getSatisfied = <span class="keyword">false</span>;
<a name="l02616"></a>02616   getActiveClausesAndCnt(gndPred, domain, activeGroundClauses, cnt,
<a name="l02617"></a>02617                          seenGndPreds, ignoreActivePreds, getSatisfied);
<a name="l02618"></a>02618 
<a name="l02619"></a>02619   <span class="keywordflow">return</span> cnt;
<a name="l02620"></a>02620 }
<a name="l02621"></a>02621 
<a name="l02622"></a>02622 
<a name="l02623"></a>02623 <span class="keyword">private</span>:
<a name="l02624"></a>02624   
<a name="l02625"></a>02625   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">sortByLen</a>(<a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>&amp; clauses, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; l, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; r)
<a name="l02626"></a>02626   {
<a name="l02627"></a>02627     <a class="code" href="classClause.html">Clause</a>** items = (<a class="code" href="classClause.html">Clause</a>**) clauses.<a class="code" href="classArray.html#db9fecfda9dfefea1421efc3ae010049">getItems</a>();
<a name="l02628"></a>02628     <span class="keywordflow">if</span> (l &gt;= r) <span class="keywordflow">return</span>;
<a name="l02629"></a>02629     <a class="code" href="classClause.html">Clause</a>* tmp = items[l];
<a name="l02630"></a>02630     items[l] = items[(l+r)/2];
<a name="l02631"></a>02631     items[(l+r)/2] = tmp;
<a name="l02632"></a>02632 
<a name="l02633"></a>02633     <span class="keywordtype">int</span> last = l;
<a name="l02634"></a>02634     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = l+1; i &lt;= r; i++)
<a name="l02635"></a>02635       <span class="keywordflow">if</span> (items[i]-&gt;<a class="code" href="classClause.html#43b84fdf90e0c961885151ef7679ead0">getNumPredicates</a>() &lt; items[l]-&gt;<a class="code" href="classClause.html#43b84fdf90e0c961885151ef7679ead0">getNumPredicates</a>())
<a name="l02636"></a>02636       {
<a name="l02637"></a>02637         ++last;
<a name="l02638"></a>02638         <a class="code" href="classClause.html">Clause</a>* tmp = items[last];
<a name="l02639"></a>02639         items[last] = items[i];
<a name="l02640"></a>02640         items[i] = tmp;
<a name="l02641"></a>02641       }
<a name="l02642"></a>02642     
<a name="l02643"></a>02643     tmp = items[l];
<a name="l02644"></a>02644     items[l] = items[last];
<a name="l02645"></a>02645     items[last] = tmp;
<a name="l02646"></a>02646     <a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">sortByLen</a>(clauses, l, last-1);
<a name="l02647"></a>02647     <a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">sortByLen</a>(clauses, last+1, r); 
<a name="l02648"></a>02648   }
<a name="l02649"></a>02649 
<a name="l02650"></a>02650 
<a name="l02651"></a>02651  <span class="keyword">private</span>:
<a name="l02652"></a>02652   <span class="keywordtype">double</span> wt_;
<a name="l02653"></a>02653   <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>* predicates_;
<a name="l02654"></a>02654   <a class="code" href="classArray.html">Array&lt;int&gt;</a>* intArrRep_;
<a name="l02655"></a>02655   size_t hashCode_;
<a name="l02656"></a>02656   <span class="keywordtype">bool</span> dirty_;
<a name="l02657"></a>02657   <span class="keywordtype">bool</span> isHardClause_;
<a name="l02658"></a>02658 
<a name="l02659"></a>02659     <span class="comment">// (*varIdToVarsGroundedType_)[v] is the VarsGroundType of variable -v</span>
<a name="l02660"></a>02660     <span class="comment">// start accessing this array from index 1</span>
<a name="l02661"></a>02661   <a class="code" href="classArray.html">Array&lt;VarsGroundedType*&gt;</a>* varIdToVarsGroundedType_ ;
<a name="l02662"></a>02662 
<a name="l02663"></a>02663   <a class="code" href="structAuxClauseData.html">AuxClauseData</a>* auxClauseData_;
<a name="l02664"></a>02664   <span class="keyword">static</span> <a class="code" href="classClauseSampler.html">ClauseSampler</a>* clauseSampler_;
<a name="l02665"></a>02665   <span class="keyword">static</span> <span class="keywordtype">double</span> fixedSizeB_;
<a name="l02666"></a>02666 };
<a name="l02667"></a>02667 
<a name="l02668"></a>02668 
<a name="l02670"></a>02670 
<a name="l02671"></a><a class="code" href="classHashClause.html">02671</a> <span class="keyword">class </span><a class="code" href="classHashClause.html">HashClause</a>
<a name="l02672"></a>02672 {
<a name="l02673"></a>02673  <span class="keyword">public</span>:
<a name="l02674"></a><a class="code" href="classHashClause.html#014786d8a43faeedafd2125c9bffcf92">02674</a>   size_t <a class="code" href="classHashClause.html#014786d8a43faeedafd2125c9bffcf92">operator()</a>(<a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> c-&gt;<a class="code" href="classClause.html#e4145e1a8a0335e532103adec4b44eac">hashCode</a>(); }
<a name="l02675"></a>02675 };
<a name="l02676"></a>02676 
<a name="l02677"></a>02677 
<a name="l02678"></a><a class="code" href="classEqualClause.html">02678</a> <span class="keyword">class </span><a class="code" href="classEqualClause.html">EqualClause</a>
<a name="l02679"></a>02679 {
<a name="l02680"></a>02680  <span class="keyword">public</span>:
<a name="l02681"></a><a class="code" href="classEqualClause.html#d9ce1a9340157d8b1f3c931235c220ad">02681</a>   <span class="keywordtype">bool</span> <a class="code" href="classEqualClause.html#d9ce1a9340157d8b1f3c931235c220ad">operator()</a>(<a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c1, <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c2)<span class="keyword"> const</span>
<a name="l02682"></a>02682 <span class="keyword">  </span>{ <span class="keywordflow">return</span> c1-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>(c2); }
<a name="l02683"></a>02683 };
<a name="l02684"></a>02684 
<a name="l02685"></a>02685 
<a name="l02686"></a><a class="code" href="classEqualClauseOp.html">02686</a> <span class="keyword">class </span><a class="code" href="classEqualClauseOp.html">EqualClauseOp</a>
<a name="l02687"></a>02687 {
<a name="l02688"></a>02688  <span class="keyword">public</span>:
<a name="l02689"></a>02689     <span class="comment">//the auxClauseData_ of c1 and c2 must be NON-NULL</span>
<a name="l02690"></a><a class="code" href="classEqualClauseOp.html#fd3f3f2d1cc3344a5743c79914c520b1">02690</a>   <span class="keywordtype">bool</span> <a class="code" href="classEqualClauseOp.html#fd3f3f2d1cc3344a5743c79914c520b1">operator()</a>(<a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c1, <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c2)<span class="keyword"> const</span>
<a name="l02691"></a>02691 <span class="keyword">  </span>{ 
<a name="l02692"></a>02692     <a class="code" href="structAuxClauseData.html">AuxClauseData</a>* acd1 = c1-&gt;<a class="code" href="classClause.html#cd89f78c621311b5f07210583eb8f608">getAuxClauseData</a>();
<a name="l02693"></a>02693     <a class="code" href="structAuxClauseData.html">AuxClauseData</a>* acd2 = c2-&gt;<a class="code" href="classClause.html#cd89f78c621311b5f07210583eb8f608">getAuxClauseData</a>();
<a name="l02694"></a>02694     <span class="keywordflow">if</span> (acd1-&gt;<a class="code" href="structAuxClauseData.html#0186961bdb427f1749cd9530506af66a">op</a> != acd2-&gt;<a class="code" href="structAuxClauseData.html#0186961bdb427f1749cd9530506af66a">op</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02695"></a>02695     <span class="keywordflow">if</span> (acd1-&gt;<a class="code" href="structAuxClauseData.html#0186961bdb427f1749cd9530506af66a">op</a> == OP_ADD) <span class="keywordflow">return</span> c1-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>(c2);
<a name="l02696"></a>02696     <span class="keywordflow">if</span> (acd1-&gt;<a class="code" href="structAuxClauseData.html#0186961bdb427f1749cd9530506af66a">op</a> == OP_REMOVE) 
<a name="l02697"></a>02697       <span class="keywordflow">return</span> acd1-&gt;<a class="code" href="structAuxClauseData.html#d511350b5fb665afc41bdc86282ce46d">removedClauseIdx</a> == acd2-&gt;<a class="code" href="structAuxClauseData.html#d511350b5fb665afc41bdc86282ce46d">removedClauseIdx</a>;
<a name="l02698"></a>02698       <span class="comment">//acd1-&gt;op is OP_REPLACE || OP_REPLACE_ADDPRED || OP_REPLACE_REMPRED</span>
<a name="l02699"></a>02699     <span class="keywordflow">return</span> acd1-&gt;<a class="code" href="structAuxClauseData.html#d511350b5fb665afc41bdc86282ce46d">removedClauseIdx</a> == acd2-&gt;<a class="code" href="structAuxClauseData.html#d511350b5fb665afc41bdc86282ce46d">removedClauseIdx</a> &amp;&amp; c1-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>(c2);
<a name="l02700"></a>02700   }
<a name="l02701"></a>02701 };
<a name="l02702"></a>02702 
<a name="l02703"></a>02703 
<a name="l02705"></a>02705 
<a name="l02706"></a>02706 <span class="keyword">typedef</span> hash_set&lt;Clause*, HashClause, EqualClause&gt; ClauseSet;
<a name="l02707"></a>02707 <span class="keyword">typedef</span> hash_set&lt;Clause*, HashClause, EqualClauseOp&gt; ClauseOpSet;
<a name="l02708"></a>02708 <span class="keyword">typedef</span> hash_map&lt;Clause*, Array&lt;Clause*&gt;*, <a class="code" href="classHashClause.html">HashClause</a>, <a class="code" href="classEqualClause.html">EqualClause</a>&gt; 
<a name="l02709"></a>02709   ClauseToClausesMap;
<a name="l02710"></a>02710 
<a name="l02711"></a>02711 <span class="keyword">typedef</span> <a class="code" href="classHashList.html">HashList&lt;Clause*, HashClause, EqualClause&gt;</a> <a class="code" href="classHashList.html">ClauseHashList</a>;
<a name="l02712"></a>02712 <span class="comment">//typedef HashArray&lt;Clause*, HashClause, EqualClause&gt; ClauseHashArray;</span>
<a name="l02713"></a>02713 <span class="keyword">typedef</span> <a class="code" href="classHashArray.html">HashArray&lt;Clause*, HashClause, EqualClauseOp&gt;</a> <a class="code" href="classHashArray.html">ClauseOpHashArray</a>;
<a name="l02714"></a>02714 
<a name="l02715"></a>02715 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 14 15:15:18 2007 for Alchemy by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
