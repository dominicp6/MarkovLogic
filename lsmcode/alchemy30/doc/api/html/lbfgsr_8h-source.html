<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Alchemy: src/rrf/lbfgsr.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_bad0962745a374caf6e9fb10c9087375.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_03927fe518ed865627761a1d09ad61c0.html">rrf</a></div>
<h1>lbfgsr.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef LBFGSR_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define LBFGSR_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "timer.h"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "gfeature.h"</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="keyword">const</span> <span class="keywordtype">int</span> LBFGSB_PRINT = 1; <span class="comment">//-1: no output; 1: output for every iteration</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="comment">// The code below from setulb() onwards is ported from: </span>
<a name="l00013"></a>00013 <span class="comment">// C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a</span>
<a name="l00014"></a>00014 <span class="comment">// limited memory FORTRAN code for solving bound constrained</span>
<a name="l00015"></a>00015 <span class="comment">// optimization problems'', Tech. Report, NAM-11, EECS Department,</span>
<a name="l00016"></a>00016 <span class="comment">// Northwestern University.</span>
<a name="l00017"></a>00017 
<a name="l00018"></a><a class="code" href="classLBFGSR.html">00018</a> <span class="keyword">class </span><a class="code" href="classLBFGSR.html">LBFGSR</a>
<a name="l00019"></a>00019 {
<a name="l00020"></a>00020  <span class="keyword">public</span>:
<a name="l00021"></a><a class="code" href="classLBFGSR.html#e32d90be2571ab49aa83b12dbbd1ff74">00021</a>   <a class="code" href="classLBFGSR.html#e32d90be2571ab49aa83b12dbbd1ff74">LBFGSR</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; maxIter, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ftol, <span class="keywordtype">double</span> samplingFrac,
<a name="l00022"></a>00022          <a class="code" href="classRRF.html">RRF</a>* <span class="keyword">const</span>&amp; rrf, <a class="code" href="classGroundRRF.html">GroundRRF</a>* <span class="keyword">const</span>&amp; grrf, 
<a name="l00023"></a>00023          <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; queryPreds, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numWts, 
<a name="l00024"></a>00024          <span class="keywordtype">int</span> wtOffset, <span class="keywordtype">double</span> sigmaSq, <span class="keywordtype">bool</span> fast=<span class="keyword">false</span>) 
<a name="l00025"></a>00025     : maxIter_(maxIter), ftol_(ftol), samplingFrac_(samplingFrac),
<a name="l00026"></a>00026       rrf_(rrf), grrf_(grrf), wtOffset_(wtOffset), sigmaSq_(sigmaSq),
<a name="l00027"></a>00027       pseudoFast_(fast),
<a name="l00028"></a>00028       nbd_(NULL), iwa_(NULL), l_(NULL), u_(NULL), g_(NULL), wa_(NULL), 
<a name="l00029"></a>00029       gArray_(numWts), queryPreds_(queryPreds)
<a name="l00030"></a>00030   { <a class="code" href="classLBFGSR.html#929f4c720ce034d15187f3578fbe4b8e">init</a>(numWts); }
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 
<a name="l00033"></a><a class="code" href="classLBFGSR.html#846d12e593f1b61fc37d5094555921a4">00033</a>   <a class="code" href="classLBFGSR.html#846d12e593f1b61fc37d5094555921a4">~LBFGSR</a>() { <a class="code" href="classLBFGSR.html#01fcb07b2badb645aefb2e5061f2bcaa">destroy</a>(); }
<a name="l00034"></a>00034 
<a name="l00035"></a>00035   
<a name="l00036"></a><a class="code" href="classLBFGSR.html#3777b9275c0126f38ec9a06e6b2d4dfc">00036</a>   <span class="keywordtype">void</span> <a class="code" href="classLBFGSR.html#3777b9275c0126f38ec9a06e6b2d4dfc">setMaxIter</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iter) { maxIter_ = iter; }
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="classLBFGSR.html#8112c3547c176e8c3f4807e1382ed08a">00038</a>   <span class="keywordtype">void</span> <a class="code" href="classLBFGSR.html#8112c3547c176e8c3f4807e1382ed08a">setFtol</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; tol)  { ftol_ = tol; }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 
<a name="l00041"></a><a class="code" href="classLBFGSR.html#929f4c720ce034d15187f3578fbe4b8e">00041</a>   <span class="keywordtype">void</span> <a class="code" href="classLBFGSR.html#929f4c720ce034d15187f3578fbe4b8e">init</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numWts)
<a name="l00042"></a>00042   {
<a name="l00043"></a>00043     <a class="code" href="classLBFGSR.html#01fcb07b2badb645aefb2e5061f2bcaa">destroy</a>();
<a name="l00044"></a>00044     numWts_ = numWts;
<a name="l00045"></a>00045     <span class="keywordtype">int</span> mmax = 17;
<a name="l00046"></a>00046     nbd_ = <span class="keyword">new</span> <span class="keywordtype">int</span>[numWts_+1];
<a name="l00047"></a>00047     iwa_ = <span class="keyword">new</span> <span class="keywordtype">int</span>[3*numWts_+1];
<a name="l00048"></a>00048     l_   = <span class="keyword">new</span> <span class="keywordtype">double</span>[numWts_+1];
<a name="l00049"></a>00049     u_   = <span class="keyword">new</span> <span class="keywordtype">double</span>[numWts_+1];
<a name="l00050"></a>00050     g_   = <span class="keyword">new</span> <span class="keywordtype">double</span>[numWts_+1];
<a name="l00051"></a>00051     wa_  = <span class="keyword">new</span> <span class="keywordtype">double</span>[2*mmax*numWts_+4*numWts_+12*mmax*mmax+12*mmax+1];    
<a name="l00052"></a>00052   }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="classLBFGSR.html#8e495847c2a112a4cce9fadbff01689b">00055</a>   <span class="keywordtype">void</span> <a class="code" href="classLBFGSR.html#8e495847c2a112a4cce9fadbff01689b">reInit</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numWts)
<a name="l00056"></a>00056   {
<a name="l00057"></a>00057     <span class="keywordflow">if</span> (numWts_ == numWts) <span class="keywordflow">return</span>;
<a name="l00058"></a>00058     <a class="code" href="classLBFGSR.html#929f4c720ce034d15187f3578fbe4b8e">init</a>(numWts);
<a name="l00059"></a>00059   }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061   
<a name="l00062"></a><a class="code" href="classLBFGSR.html#01fcb07b2badb645aefb2e5061f2bcaa">00062</a>   <span class="keywordtype">void</span> <a class="code" href="classLBFGSR.html#01fcb07b2badb645aefb2e5061f2bcaa">destroy</a>() 
<a name="l00063"></a>00063   {
<a name="l00064"></a>00064     <span class="keywordflow">if</span> (nbd_ != NULL) <span class="keyword">delete</span> [] nbd_;
<a name="l00065"></a>00065     <span class="keywordflow">if</span> (iwa_ != NULL) <span class="keyword">delete</span> [] iwa_;
<a name="l00066"></a>00066     <span class="keywordflow">if</span> (l_   != NULL) <span class="keyword">delete</span> [] l_;
<a name="l00067"></a>00067     <span class="keywordflow">if</span> (u_   != NULL) <span class="keyword">delete</span> [] u_;
<a name="l00068"></a>00068     <span class="keywordflow">if</span> (g_   != NULL) <span class="keyword">delete</span> [] g_;
<a name="l00069"></a>00069     <span class="keywordflow">if</span> (wa_  != NULL) <span class="keyword">delete</span> [] wa_;
<a name="l00070"></a>00070   }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 
<a name="l00073"></a><a class="code" href="classLBFGSR.html#5665be31c8ed758e198530eacb133204">00073</a>   <span class="keywordtype">double</span> <a class="code" href="classLBFGSR.html#5665be31c8ed758e198530eacb133204">minimize</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numWts, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wts, <span class="keywordtype">int</span>&amp; iter,<span class="keywordtype">bool</span>&amp; error)
<a name="l00074"></a>00074   {
<a name="l00075"></a>00075     <a class="code" href="classLBFGSR.html#8e495847c2a112a4cce9fadbff01689b">reInit</a>(numWts);
<a name="l00076"></a>00076     <span class="keywordflow">return</span> <a class="code" href="classLBFGSR.html#5665be31c8ed758e198530eacb133204">minimize</a>(wts, iter, error);
<a name="l00077"></a>00077   }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="classLBFGSR.html#457b353f494f2948cbb0deb48759782c">00080</a>   <span class="keywordtype">double</span> <a class="code" href="classLBFGSR.html#5665be31c8ed758e198530eacb133204">minimize</a>(<span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wts, <span class="keywordtype">int</span>&amp; iter, <span class="keywordtype">bool</span>&amp; error)
<a name="l00081"></a>00081   {
<a name="l00082"></a>00082     error = <span class="keyword">false</span>;
<a name="l00083"></a>00083     <span class="keywordtype">int</span> m = 5; <span class="comment">//max number of limited memory corrections</span>
<a name="l00084"></a>00084     <span class="keywordtype">double</span> f; <span class="comment">// value of function to be optimized</span>
<a name="l00085"></a>00085     <span class="keywordtype">double</span> factr = 0;
<a name="l00086"></a>00086     <span class="keywordtype">double</span> pgtol = 0;
<a name="l00087"></a>00087      <span class="comment">// -1: silent (-1); 1: out at every iteration</span>
<a name="l00088"></a>00088     ofstream* itfile = NULL;
<a name="l00089"></a>00089     <span class="keywordtype">int</span> iprint = LBFGSB_PRINT; 
<a name="l00090"></a>00090     <span class="keywordflow">if</span> (iprint &gt;= 1) itfile = <span class="keyword">new</span> ofstream(<span class="stringliteral">"iterate.dat"</span>);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     iter = 0;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095       <span class="comment">//indicate that the elements of x[] are unbounded</span>
<a name="l00096"></a>00096     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= numWts_; i++) nbd_[i] = 0;
<a name="l00097"></a>00097     
<a name="l00098"></a>00098     strcpy(task_,<span class="stringliteral">"START"</span>);
<a name="l00099"></a>00099     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 5; i &lt;= 60; i++) task_[i]=<span class="charliteral">' '</span>;
<a name="l00100"></a>00100     
<a name="l00101"></a>00101     setulb(numWts_,m,wts,l_,u_,nbd_,f,g_,factr,pgtol,wa_,iwa_,task_,
<a name="l00102"></a>00102            iprint,csave_,lsave_,isave_,dsave_,itfile);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     <span class="keywordtype">double</span> initialValue = 0, prevValue = 0, newValue;
<a name="l00105"></a>00105     <span class="keywordtype">bool</span> firstIter = <span class="keyword">true</span>;
<a name="l00106"></a>00106 
<a name="l00107"></a>00107       <span class="comment">//while routine returns "FG" or "NEW_X" in task, keep calling it</span>
<a name="l00108"></a>00108     <span class="keywordflow">while</span> (strncmp(task_,<span class="stringliteral">"FG"</span>,2)==0 || strncmp(task_,<span class="stringliteral">"NEW_X"</span>,5)==0)
<a name="l00109"></a>00109     {
<a name="l00110"></a>00110       <span class="keywordflow">if</span> (strncmp(task_,<span class="stringliteral">"FG"</span>,2)==0)
<a name="l00111"></a>00111       {
<a name="l00112"></a>00112         f = getValueAndGradient(g_, wts);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         setulb(numWts_,m,wts,l_,u_,nbd_,f,g_,factr,pgtol,wa_,iwa_,task_,
<a name="l00115"></a>00115                iprint,csave_,lsave_,isave_,dsave_,itfile);
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <span class="keywordflow">if</span> (firstIter) { firstIter = <span class="keyword">false</span>; prevValue = f; initialValue = f; }
<a name="l00118"></a>00118       }
<a name="l00119"></a>00119       <span class="keywordflow">else</span>
<a name="l00120"></a>00120       {
<a name="l00121"></a>00121           <span class="comment">//the minimization routine has returned with a new iterate,</span>
<a name="l00122"></a>00122           <span class="comment">//and we have opted to continue the iteration</span>
<a name="l00123"></a>00123         <span class="keywordflow">if</span> (iter+1 &gt; maxIter_) <span class="keywordflow">break</span>;
<a name="l00124"></a>00124         ++iter;
<a name="l00125"></a>00125         newValue = f;
<a name="l00126"></a>00126         
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (fabs(newValue-prevValue) &lt; ftol_*fabs(prevValue)) <span class="keywordflow">break</span>;
<a name="l00128"></a>00128         prevValue = newValue;
<a name="l00129"></a>00129         
<a name="l00130"></a>00130         setulb(numWts_,m,wts,l_,u_,nbd_,f,g_,factr,pgtol,wa_,iwa_,task_,
<a name="l00131"></a>00131                iprint,csave_,lsave_,isave_,dsave_,itfile);
<a name="l00132"></a>00132       }
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134     
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="comment">//If task is neither FG nor NEW_X we terminate execution.</span>
<a name="l00137"></a>00137     <span class="comment">//the minimization routine has returned with one of</span>
<a name="l00138"></a>00138     <span class="comment">//{CONV, ABNO, ERROR}</span>
<a name="l00139"></a>00139     
<a name="l00140"></a>00140     <span class="keywordflow">if</span> (strncmp(task_,<span class="stringliteral">"ABNO"</span>,4) == 0)
<a name="l00141"></a>00141     {
<a name="l00142"></a>00142       cout &lt;&lt; <span class="stringliteral">"ERROR: LBFGSB failed. Returned ABNO"</span> &lt;&lt; endl;
<a name="l00143"></a>00143       error = <span class="keyword">true</span>;
<a name="l00144"></a>00144       <span class="keywordflow">return</span> initialValue;
<a name="l00145"></a>00145     }
<a name="l00146"></a>00146     
<a name="l00147"></a>00147     <span class="keywordflow">if</span> (strncmp(task_,<span class="stringliteral">"ERROR"</span>,5)==0)
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149       cout &lt;&lt; <span class="stringliteral">"ERROR: LBFGSB failed. Returned ERROR"</span> &lt;&lt; endl;
<a name="l00150"></a>00150       error = <span class="keyword">true</span>;
<a name="l00151"></a>00151       <span class="keywordflow">return</span> initialValue;
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153     
<a name="l00154"></a>00154     <span class="keywordflow">if</span> (strncmp(task_,<span class="stringliteral">"CONV"</span>,4)==0)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156       <span class="comment">//cout &lt;&lt; "LBFGSB converged!" &lt;&lt; endl;</span>
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158         
<a name="l00159"></a>00159     <span class="keywordflow">return</span> f;    
<a name="l00160"></a>00160   }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 
<a name="l00163"></a>00163  <span class="keyword">private</span>:
<a name="l00164"></a>00164   <span class="keywordtype">int</span> maxIter_;
<a name="l00165"></a>00165   <span class="keywordtype">double</span> ftol_;
<a name="l00166"></a>00166   <span class="keywordtype">double</span> samplingFrac_; <span class="comment">// Fraction of ground preds to consider</span>
<a name="l00167"></a>00167   <a class="code" href="classRRF.html">RRF</a>*   rrf_; <span class="comment">//not owned by LBFGSR; do not delete</span>
<a name="l00168"></a>00168   <a class="code" href="classGroundRRF.html">GroundRRF</a>* grrf_; <span class="comment">//not owned by LBFGSR; do not delete</span>
<a name="l00169"></a>00169   <span class="keywordtype">int</span> numWts_;
<a name="l00170"></a>00170   <span class="keywordtype">int</span> wtOffset_;
<a name="l00171"></a>00171   <span class="keywordtype">double</span> sigmaSq_;
<a name="l00172"></a>00172   <span class="keywordtype">bool</span> pseudoFast_;
<a name="l00173"></a>00173   
<a name="l00174"></a>00174     <span class="comment">// params of lbfgsb algorithm</span>
<a name="l00175"></a>00175   <span class="keywordtype">int</span>*    nbd_;
<a name="l00176"></a>00176   <span class="keywordtype">int</span>*    iwa_;
<a name="l00177"></a>00177   <span class="keywordtype">double</span>* l_;
<a name="l00178"></a>00178   <span class="keywordtype">double</span>* u_;
<a name="l00179"></a>00179   <span class="keywordtype">double</span>* g_;
<a name="l00180"></a>00180   <span class="keywordtype">double</span>* wa_;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182   <span class="comment">// Other parameters, to assist in computing pseudo-log-likelihood</span>
<a name="l00183"></a>00183   <a class="code" href="classArray.html">Array&lt;double&gt;</a> gArray_;
<a name="l00184"></a>00184   <a class="code" href="classArray.html">Array&lt;int&gt;</a> queryPreds_;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordtype">char</span> task_[61];
<a name="l00187"></a>00187   <span class="keywordtype">char</span> csave_[61];
<a name="l00188"></a>00188   <span class="keywordtype">bool</span> lsave_[5];
<a name="l00189"></a>00189   <span class="keywordtype">int</span>  isave_[45];
<a name="l00190"></a>00190   <span class="keywordtype">double</span> dsave_[30];
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 
<a name="l00193"></a>00193  <span class="keyword">private</span>:
<a name="l00194"></a>00194   <span class="keywordtype">double</span> getValueAndGradient(<span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; g, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wts)
<a name="l00195"></a>00195   {
<a name="l00196"></a>00196       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numWts_; i++) {
<a name="l00197"></a>00197           <span class="comment">// NOTE: wts is 1-indexed, not 0-indexed</span>
<a name="l00198"></a>00198           rrf_-&gt;<a class="code" href="classRRF.html#ffc29d37cd9e3e081adeed6e74d2564d">setWeight</a>(i + wtOffset_, wts[i+1]);
<a name="l00199"></a>00199       }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201       <span class="comment">// Get gradient</span>
<a name="l00202"></a>00202       grrf_-&gt;<a class="code" href="classGroundRRF.html#e038b30d3dabc6d163f1912753b6694a">dirtyAll</a>();
<a name="l00203"></a>00203       <span class="keywordflow">if</span> (pseudoFast_) {
<a name="l00204"></a>00204           grrf_-&gt;<a class="code" href="classGroundRRF.html#c3979f1634d5db1caf6c30c428c8b517">getPseudoCountsFast</a>(gArray_, queryPreds_, samplingFrac_);
<a name="l00205"></a>00205       } <span class="keywordflow">else</span> {
<a name="l00206"></a>00206           grrf_-&gt;<a class="code" href="classGroundRRF.html#5e611f8eb34e5761529d674507307ada">getPseudoCounts</a>(gArray_, queryPreds_, samplingFrac_);
<a name="l00207"></a>00207       }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209       <span class="comment">// Copy into the array</span>
<a name="l00210"></a>00210       <span class="comment">// TODO: apply prior!</span>
<a name="l00211"></a>00211       <span class="keywordtype">double</span> wll = 0.0;
<a name="l00212"></a>00212       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numWts_; i++) {
<a name="l00213"></a>00213           g_[i+1] = -gArray_[i + wtOffset_] + wts[i+1]/sigmaSq_;
<a name="l00214"></a>00214           wll -= wts[i+1] * wts[i+1]/sigmaSq_;
<a name="l00215"></a>00215       }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217       <span class="keywordtype">double</span> value = -(grrf_-&gt;<a class="code" href="classGroundRRF.html#7f680b763da4af438505cfac404038e0">getLogPseudoLikelihood</a>(queryPreds_) + wll);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="preprocessor">#define VERBOSE_DEBUG 0</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span><span class="preprocessor">#if VERBOSE_DEBUG</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">"wts"</span>;
<a name="l00222"></a>00222       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numWts_; i++) {
<a name="l00223"></a>00223           cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; wts[i+1];
<a name="l00224"></a>00224       }
<a name="l00225"></a>00225       cout &lt;&lt; <span class="stringliteral">"\nval = "</span> &lt;&lt; value &lt;&lt; endl;
<a name="l00226"></a>00226       cout &lt;&lt; <span class="stringliteral">"grad"</span>;
<a name="l00227"></a>00227       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numWts_; i++) {
<a name="l00228"></a>00228           cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; g_[i+1];
<a name="l00229"></a>00229       }
<a name="l00230"></a>00230       cout &lt;&lt; endl;
<a name="l00231"></a>00231 <span class="preprocessor">#endif</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>      <span class="comment">// DEBUG</span>
<a name="l00233"></a>00233       cout &lt;&lt; <span class="stringliteral">"Getting value: "</span> &lt;&lt; value &lt;&lt; endl;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235       <span class="keywordflow">return</span> value;
<a name="l00236"></a>00236   }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="comment">//function</span>
<a name="l00239"></a>00239   <span class="keywordtype">int</span> getIdx(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; j, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; idim)
<a name="l00240"></a>00240   {
<a name="l00241"></a>00241     <span class="keywordflow">return</span> (j-1)*idim + i;
<a name="l00242"></a>00242   }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245   <span class="keywordtype">double</span> max(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; b) { <span class="keywordflow">if</span> (a&gt;=b) <span class="keywordflow">return</span> a; <span class="keywordflow">return</span> b; }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="keywordtype">double</span> min(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; b) { <span class="keywordflow">if</span> (a&lt;=b) <span class="keywordflow">return</span> a; <span class="keywordflow">return</span> b; }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keywordtype">int</span> min(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; b) { <span class="keywordflow">if</span> (a&lt;=b) <span class="keywordflow">return</span> a; <span class="keywordflow">return</span> b; }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="keywordtype">double</span> max(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; b, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; c)
<a name="l00252"></a>00252   {
<a name="l00253"></a>00253     <span class="keywordflow">if</span> (a &gt;= b &amp;&amp; a &gt;= c) <span class="keywordflow">return</span> a;
<a name="l00254"></a>00254     <span class="keywordflow">if</span> (b &gt;= a &amp;&amp; b &gt;= c) <span class="keywordflow">return</span> b;
<a name="l00255"></a>00255     assert(c &gt;= a &amp;&amp; c &gt;= b);
<a name="l00256"></a>00256     <span class="keywordflow">return</span> c;
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 
<a name="l00260"></a>00260   <span class="comment">// The code below is ported from: </span>
<a name="l00261"></a>00261   <span class="comment">// C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a</span>
<a name="l00262"></a>00262   <span class="comment">// limited memory FORTRAN code for solving bound constrained</span>
<a name="l00263"></a>00263   <span class="comment">// optimization problems'', Tech. Report, NAM-11, EECS Department,</span>
<a name="l00264"></a>00264   <span class="comment">// Northwestern University.</span>
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   <span class="comment">// The comments before each function are from the original fortran code.</span>
<a name="l00267"></a>00267 
<a name="l00268"></a>00268   <span class="comment">//   ************</span>
<a name="l00269"></a>00269   <span class="comment">//</span>
<a name="l00270"></a>00270   <span class="comment">//   Subroutine setulb</span>
<a name="l00271"></a>00271   <span class="comment">//</span>
<a name="l00272"></a>00272   <span class="comment">//   This subroutine partitions the working arrays wa and iwa, and </span>
<a name="l00273"></a>00273   <span class="comment">//     then uses the limited memory BFGS method to solve the bound</span>
<a name="l00274"></a>00274   <span class="comment">//     constrained optimization problem by calling mainlb.</span>
<a name="l00275"></a>00275   <span class="comment">//     (The direct method will be used in the subspace minimization.)</span>
<a name="l00276"></a>00276   <span class="comment">//</span>
<a name="l00277"></a>00277   <span class="comment">//   n is an integer variable.</span>
<a name="l00278"></a>00278   <span class="comment">//     On entry n is the dimension of the problem.</span>
<a name="l00279"></a>00279   <span class="comment">//     On exit n is unchanged.</span>
<a name="l00280"></a>00280   <span class="comment">//</span>
<a name="l00281"></a>00281   <span class="comment">//   m is an integer variable.</span>
<a name="l00282"></a>00282   <span class="comment">//     On entry m is the maximum number of variable metric corrections</span>
<a name="l00283"></a>00283   <span class="comment">//       used to define the limited memory matrix.</span>
<a name="l00284"></a>00284   <span class="comment">//     On exit m is unchanged.</span>
<a name="l00285"></a>00285   <span class="comment">//</span>
<a name="l00286"></a>00286   <span class="comment">//   x is a double precision array of dimension n.</span>
<a name="l00287"></a>00287   <span class="comment">//     On entry x is an approximation to the solution.</span>
<a name="l00288"></a>00288   <span class="comment">//     On exit x is the current approximation.</span>
<a name="l00289"></a>00289   <span class="comment">//</span>
<a name="l00290"></a>00290   <span class="comment">//   l is a double precision array of dimension n.</span>
<a name="l00291"></a>00291   <span class="comment">//     On entry l is the lower bound on x.</span>
<a name="l00292"></a>00292   <span class="comment">//     On exit l is unchanged.</span>
<a name="l00293"></a>00293   <span class="comment">//</span>
<a name="l00294"></a>00294   <span class="comment">//   u is a double precision array of dimension n.</span>
<a name="l00295"></a>00295   <span class="comment">//     On entry u is the upper bound on x.</span>
<a name="l00296"></a>00296   <span class="comment">//     On exit u is unchanged.</span>
<a name="l00297"></a>00297   <span class="comment">//</span>
<a name="l00298"></a>00298   <span class="comment">//   nbd is an integer array of dimension n.</span>
<a name="l00299"></a>00299   <span class="comment">//     On entry nbd represents the type of bounds imposed on the</span>
<a name="l00300"></a>00300   <span class="comment">//       variables, and must be specified as follows:</span>
<a name="l00301"></a>00301   <span class="comment">//       nbd(i)=0 if x(i) is unbounded,</span>
<a name="l00302"></a>00302   <span class="comment">//              1 if x(i) has only a lower bound,</span>
<a name="l00303"></a>00303   <span class="comment">//              2 if x(i) has both lower and upper bounds, and</span>
<a name="l00304"></a>00304   <span class="comment">//              3 if x(i) has only an upper bound.</span>
<a name="l00305"></a>00305   <span class="comment">//     On exit nbd is unchanged.</span>
<a name="l00306"></a>00306   <span class="comment">//</span>
<a name="l00307"></a>00307   <span class="comment">//   f is a double precision variable.</span>
<a name="l00308"></a>00308   <span class="comment">//     On first entry f is unspecified.</span>
<a name="l00309"></a>00309   <span class="comment">//     On final exit f is the value of the function at x.</span>
<a name="l00310"></a>00310   <span class="comment">//</span>
<a name="l00311"></a>00311   <span class="comment">//   g is a double precision array of dimension n.</span>
<a name="l00312"></a>00312   <span class="comment">//     On first entry g is unspecified.</span>
<a name="l00313"></a>00313   <span class="comment">//     On final exit g is the value of the gradient at x.</span>
<a name="l00314"></a>00314   <span class="comment">//</span>
<a name="l00315"></a>00315   <span class="comment">//   factr is a double precision variable.</span>
<a name="l00316"></a>00316   <span class="comment">//     On entry factr &gt;= 0 is specified by the user.  The iteration</span>
<a name="l00317"></a>00317   <span class="comment">//       will stop when</span>
<a name="l00318"></a>00318   <span class="comment">//</span>
<a name="l00319"></a>00319   <span class="comment">//       (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} &lt;= factr*epsmch</span>
<a name="l00320"></a>00320   <span class="comment">//</span>
<a name="l00321"></a>00321   <span class="comment">//       where epsmch is the machine precision, which is automatically</span>
<a name="l00322"></a>00322   <span class="comment">//       generated by the code. Typical values for factr: 1.d+12 for</span>
<a name="l00323"></a>00323   <span class="comment">//       low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely</span>
<a name="l00324"></a>00324   <span class="comment">//       high accuracy.</span>
<a name="l00325"></a>00325   <span class="comment">//     On exit factr is unchanged.</span>
<a name="l00326"></a>00326   <span class="comment">//</span>
<a name="l00327"></a>00327   <span class="comment">//   pgtol is a double precision variable.</span>
<a name="l00328"></a>00328   <span class="comment">//     On entry pgtol &gt;= 0 is specified by the user.  The iteration</span>
<a name="l00329"></a>00329   <span class="comment">//       will stop when</span>
<a name="l00330"></a>00330   <span class="comment">//</span>
<a name="l00331"></a>00331   <span class="comment">//               max{|proj g_i | i = 1, ..., n} &lt;= pgtol</span>
<a name="l00332"></a>00332   <span class="comment">//</span>
<a name="l00333"></a>00333   <span class="comment">//       where pg_i is the ith component of the projected gradient.   </span>
<a name="l00334"></a>00334   <span class="comment">//     On exit pgtol is unchanged.</span>
<a name="l00335"></a>00335   <span class="comment">//</span>
<a name="l00336"></a>00336   <span class="comment">//   wa is a double precision working array of length </span>
<a name="l00337"></a>00337   <span class="comment">//     (2mmax + 4)nmax + 12mmax^2 + 12mmax.</span>
<a name="l00338"></a>00338   <span class="comment">//</span>
<a name="l00339"></a>00339   <span class="comment">//   iwa is an integer working array of length 3nmax.</span>
<a name="l00340"></a>00340   <span class="comment">//</span>
<a name="l00341"></a>00341   <span class="comment">//   task is a working string of characters of length 60 indicating</span>
<a name="l00342"></a>00342   <span class="comment">//     the current job when entering and quitting this subroutine.</span>
<a name="l00343"></a>00343   <span class="comment">//</span>
<a name="l00344"></a>00344   <span class="comment">//   iprint is an integer variable that must be set by the user.</span>
<a name="l00345"></a>00345   <span class="comment">//     It controls the frequency and type of output generated:</span>
<a name="l00346"></a>00346   <span class="comment">//      iprint&lt;0    no output is generated;</span>
<a name="l00347"></a>00347   <span class="comment">//      iprint=0    print only one line at the last iteration;</span>
<a name="l00348"></a>00348   <span class="comment">//      0&lt;iprint&lt;99 print also f and |proj g| every iprint iterations;</span>
<a name="l00349"></a>00349   <span class="comment">//      iprint=99   print details of every iteration except n-vectors;</span>
<a name="l00350"></a>00350   <span class="comment">//      iprint=100  print also the changes of active set and final x;</span>
<a name="l00351"></a>00351   <span class="comment">//      iprint&gt;100  print details of every iteration including x and g;</span>
<a name="l00352"></a>00352   <span class="comment">//     When iprint &gt; 0, the file iterate.dat will be created to</span>
<a name="l00353"></a>00353   <span class="comment">//                      summarize the iteration.</span>
<a name="l00354"></a>00354   <span class="comment">//</span>
<a name="l00355"></a>00355   <span class="comment">//   csave is a working string of characters of length 60.</span>
<a name="l00356"></a>00356   <span class="comment">//</span>
<a name="l00357"></a>00357   <span class="comment">//   lsave is a logical working array of dimension 4.</span>
<a name="l00358"></a>00358   <span class="comment">//     On exit with 'task' = NEW_X, the following information is </span>
<a name="l00359"></a>00359   <span class="comment">//                                                           available:</span>
<a name="l00360"></a>00360   <span class="comment">//       If lsave(1) = true  then  the initial X has been replaced by</span>
<a name="l00361"></a>00361   <span class="comment">//                                   its projection in the feasible set;</span>
<a name="l00362"></a>00362   <span class="comment">//       If lsave(2) = true  then  the problem is constrained;</span>
<a name="l00363"></a>00363   <span class="comment">//       If lsave(3) = true  then  each variable has upper and lower</span>
<a name="l00364"></a>00364   <span class="comment">//                                   bounds;</span>
<a name="l00365"></a>00365   <span class="comment">//</span>
<a name="l00366"></a>00366   <span class="comment">//   isave is an integer working array of dimension 44.</span>
<a name="l00367"></a>00367   <span class="comment">//     On exit with 'task' = NEW_X, the following information is </span>
<a name="l00368"></a>00368   <span class="comment">//                                                           available:</span>
<a name="l00369"></a>00369   <span class="comment">//       isave(22) = the total number of intervals explored in the </span>
<a name="l00370"></a>00370   <span class="comment">//                       search of Cauchy points;</span>
<a name="l00371"></a>00371   <span class="comment">//       isave(26) = the total number of skipped BFGS updates before </span>
<a name="l00372"></a>00372   <span class="comment">//                       the current iteration;</span>
<a name="l00373"></a>00373   <span class="comment">//       isave(30) = the number of current iteration;</span>
<a name="l00374"></a>00374   <span class="comment">//       isave(31) = the total number of BFGS updates prior the current</span>
<a name="l00375"></a>00375   <span class="comment">//                       iteration;</span>
<a name="l00376"></a>00376   <span class="comment">//       isave(33) = the number of intervals explored in the search of</span>
<a name="l00377"></a>00377   <span class="comment">//                       Cauchy point in the current iteration;</span>
<a name="l00378"></a>00378   <span class="comment">//       isave(34) = the total number of function and gradient </span>
<a name="l00379"></a>00379   <span class="comment">//                       evaluations;</span>
<a name="l00380"></a>00380   <span class="comment">//       isave(36) = the number of function value or gradient</span>
<a name="l00381"></a>00381   <span class="comment">//                                evaluations in the current iteration;</span>
<a name="l00382"></a>00382   <span class="comment">//       if isave(37) = 0  then the subspace argmin is within the box;</span>
<a name="l00383"></a>00383   <span class="comment">//       if isave(37) = 1  then the subspace argmin is beyond the box;</span>
<a name="l00384"></a>00384   <span class="comment">//       isave(38) = the number of free variables in the current</span>
<a name="l00385"></a>00385   <span class="comment">//                       iteration;</span>
<a name="l00386"></a>00386   <span class="comment">//       isave(39) = the number of active constraints in the current</span>
<a name="l00387"></a>00387   <span class="comment">//                       iteration;</span>
<a name="l00388"></a>00388   <span class="comment">//       n + 1 - isave(40) = the number of variables leaving the set of</span>
<a name="l00389"></a>00389   <span class="comment">//                         active constraints in the current iteration;</span>
<a name="l00390"></a>00390   <span class="comment">//       isave(41) = the number of variables entering the set of active</span>
<a name="l00391"></a>00391   <span class="comment">//                       constraints in the current iteration.</span>
<a name="l00392"></a>00392   <span class="comment">//</span>
<a name="l00393"></a>00393   <span class="comment">//   dsave is a double precision working array of dimension 29.</span>
<a name="l00394"></a>00394   <span class="comment">//     On exit with 'task' = NEW_X, the following information is</span>
<a name="l00395"></a>00395   <span class="comment">//                                                           available:</span>
<a name="l00396"></a>00396   <span class="comment">//       dsave(1) = current 'theta' in the BFGS matrix;</span>
<a name="l00397"></a>00397   <span class="comment">//       dsave(2) = f(x) in the previous iteration;</span>
<a name="l00398"></a>00398   <span class="comment">//       dsave(3) = factr*epsmch;</span>
<a name="l00399"></a>00399   <span class="comment">//       dsave(4) = 2-norm of the line search direction vector;</span>
<a name="l00400"></a>00400   <span class="comment">//       dsave(5) = the machine precision epsmch generated by the code;</span>
<a name="l00401"></a>00401   <span class="comment">//       dsave(7) = the accumulated time spent on searching for</span>
<a name="l00402"></a>00402   <span class="comment">//                                                       Cauchy points;</span>
<a name="l00403"></a>00403   <span class="comment">//       dsave(8) = the accumulated time spent on</span>
<a name="l00404"></a>00404   <span class="comment">//                                               subspace minimization;</span>
<a name="l00405"></a>00405   <span class="comment">//       dsave(9) = the accumulated time spent on line search;</span>
<a name="l00406"></a>00406   <span class="comment">//       dsave(11) = the slope of the line search function at</span>
<a name="l00407"></a>00407   <span class="comment">//                                the current point of line search;</span>
<a name="l00408"></a>00408   <span class="comment">//       dsave(12) = the maximum relative step length imposed in</span>
<a name="l00409"></a>00409   <span class="comment">//                                                         line search;</span>
<a name="l00410"></a>00410   <span class="comment">//       dsave(13) = the infinity norm of the projected gradient;</span>
<a name="l00411"></a>00411   <span class="comment">//       dsave(14) = the relative step length in the line search;</span>
<a name="l00412"></a>00412   <span class="comment">//       dsave(15) = the slope of the line search function at</span>
<a name="l00413"></a>00413   <span class="comment">//                               the starting point of the line search;</span>
<a name="l00414"></a>00414   <span class="comment">//       dsave(16) = the square of the 2-norm of the line search</span>
<a name="l00415"></a>00415   <span class="comment">//                                                    direction vector.</span>
<a name="l00416"></a>00416   <span class="comment">//</span>
<a name="l00417"></a>00417   <span class="comment">//   Subprograms called:</span>
<a name="l00418"></a>00418   <span class="comment">//</span>
<a name="l00419"></a>00419   <span class="comment">//     L-BFGS-B Library ... mainlb.    </span>
<a name="l00420"></a>00420   <span class="comment">//</span>
<a name="l00421"></a>00421   <span class="comment">//</span>
<a name="l00422"></a>00422   <span class="comment">//   References:</span>
<a name="l00423"></a>00423   <span class="comment">//</span>
<a name="l00424"></a>00424   <span class="comment">//     [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited</span>
<a name="l00425"></a>00425   <span class="comment">//     memory algorithm for bound constrained optimization'',</span>
<a name="l00426"></a>00426   <span class="comment">//     SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.</span>
<a name="l00427"></a>00427   <span class="comment">//</span>
<a name="l00428"></a>00428   <span class="comment">//     [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a</span>
<a name="l00429"></a>00429   <span class="comment">//     limited memory FORTRAN code for solving bound constrained</span>
<a name="l00430"></a>00430   <span class="comment">//     optimization problems'', Tech. Report, NAM-11, EECS Department,</span>
<a name="l00431"></a>00431   <span class="comment">//     Northwestern University, 1994.</span>
<a name="l00432"></a>00432   <span class="comment">//</span>
<a name="l00433"></a>00433   <span class="comment">//     (Postscript files of these papers are available via anonymous</span>
<a name="l00434"></a>00434   <span class="comment">//      ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)</span>
<a name="l00435"></a>00435   <span class="comment">//</span>
<a name="l00436"></a>00436   <span class="comment">//                         *  *  *</span>
<a name="l00437"></a>00437   <span class="comment">//</span>
<a name="l00438"></a>00438   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l00439"></a>00439   <span class="comment">//   Optimization Technology Center.</span>
<a name="l00440"></a>00440   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l00441"></a>00441   <span class="comment">//   Written by</span>
<a name="l00442"></a>00442   <span class="comment">//                      Ciyou Zhu</span>
<a name="l00443"></a>00443   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l00444"></a>00444   <span class="comment">//</span>
<a name="l00445"></a>00445   <span class="comment">//</span>
<a name="l00446"></a>00446   <span class="comment">// ************</span>
<a name="l00447"></a>00447   <span class="comment">//function</span>
<a name="l00448"></a>00448   <span class="keywordtype">void</span> setulb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, 
<a name="l00449"></a>00449               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, 
<a name="l00450"></a>00450               <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; nbd, <span class="keywordtype">double</span>&amp; f, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; g, 
<a name="l00451"></a>00451               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; factr, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; pgtol, 
<a name="l00452"></a>00452               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wa, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; iwa,
<a name="l00453"></a>00453               <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; task, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint,  
<a name="l00454"></a>00454               <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; csave, <span class="keywordtype">bool</span>* <span class="keyword">const</span> &amp; lsave, 
<a name="l00455"></a>00455               <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; isave, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dsave,
<a name="l00456"></a>00456               ofstream* itfile)
<a name="l00457"></a>00457   { 
<a name="l00458"></a>00458     <span class="keywordtype">int</span> l1,l2,l3,lws,lr,lz,lt,ld,lsg,lwa,lyg,
<a name="l00459"></a>00459         lsgo,lwy,lsy,lss,lyy,lwt,lwn,lsnd,lygo;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461     <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"START"</span>,5)==0)
<a name="l00462"></a>00462     {
<a name="l00463"></a>00463       isave[1]  = m*n;
<a name="l00464"></a>00464       isave[2]  = m*m;
<a name="l00465"></a>00465       isave[3]  = 4*m*m;
<a name="l00466"></a>00466       isave[4]  = 1;
<a name="l00467"></a>00467       isave[5]  = isave[4]  + isave[1];
<a name="l00468"></a>00468       isave[6]  = isave[5]  + isave[1];
<a name="l00469"></a>00469       isave[7]  = isave[6]  + isave[2];
<a name="l00470"></a>00470       isave[8]  = isave[7]  + isave[2];
<a name="l00471"></a>00471       isave[9]  = isave[8]  + isave[2];
<a name="l00472"></a>00472       isave[10] = isave[9]  + isave[2];
<a name="l00473"></a>00473       isave[11] = isave[10] + isave[3];
<a name="l00474"></a>00474       isave[12] = isave[11] + isave[3];
<a name="l00475"></a>00475       isave[13] = isave[12] + n;
<a name="l00476"></a>00476       isave[14] = isave[13] + n;
<a name="l00477"></a>00477       isave[15] = isave[14] + n;
<a name="l00478"></a>00478       isave[16] = isave[15] + n;
<a name="l00479"></a>00479       isave[17] = isave[16] + 8*m;
<a name="l00480"></a>00480       isave[18] = isave[17] + m;
<a name="l00481"></a>00481       isave[19] = isave[18] + m;
<a name="l00482"></a>00482       isave[20] = isave[19] + m;
<a name="l00483"></a>00483     }
<a name="l00484"></a>00484     l1   = isave[1];
<a name="l00485"></a>00485     l2   = isave[2];
<a name="l00486"></a>00486     l3   = isave[3];
<a name="l00487"></a>00487     lws  = isave[4];
<a name="l00488"></a>00488     lwy  = isave[5];
<a name="l00489"></a>00489     lsy  = isave[6];
<a name="l00490"></a>00490     lss  = isave[7];
<a name="l00491"></a>00491     lyy  = isave[8];
<a name="l00492"></a>00492     lwt  = isave[9];
<a name="l00493"></a>00493     lwn  = isave[10];
<a name="l00494"></a>00494     lsnd = isave[11];
<a name="l00495"></a>00495     lz   = isave[12];
<a name="l00496"></a>00496     lr   = isave[13];
<a name="l00497"></a>00497     ld   = isave[14];
<a name="l00498"></a>00498     lt   = isave[15];
<a name="l00499"></a>00499     lwa  = isave[16];
<a name="l00500"></a>00500     lsg  = isave[17];
<a name="l00501"></a>00501     lsgo = isave[18];
<a name="l00502"></a>00502     lyg  = isave[19];
<a name="l00503"></a>00503     lygo = isave[20];
<a name="l00504"></a>00504 
<a name="l00505"></a>00505     timer_.<a class="code" href="classTimer.html#9020542d73357a4eef512eefaf57524b">reset</a>();
<a name="l00506"></a>00506     
<a name="l00507"></a>00507     mainlb(n,m,x,l,u,nbd,f,g,factr,pgtol,
<a name="l00508"></a>00508            &amp;(wa[lws-1]),&amp;(wa[lwy-1]),&amp;(wa[lsy-1]),&amp;(wa[lss-1]),&amp;(wa[lyy-1]),
<a name="l00509"></a>00509            &amp;(wa[lwt-1]),&amp;(wa[lwn-1]),&amp;(wa[lsnd-1]),&amp;(wa[lz-1]),&amp;(wa[lr-1]),
<a name="l00510"></a>00510            &amp;(wa[ld-1]),&amp;(wa[lt-1]),&amp;(wa[lwa-1]),&amp;(wa[lsg-1]),&amp;(wa[lsgo-1]),
<a name="l00511"></a>00511            &amp;(wa[lyg-1]),&amp;(wa[lygo-1]),&amp;(iwa[1-1]),&amp;(iwa[n+1-1]),&amp;(iwa[2*n+1-1]),
<a name="l00512"></a>00512            task,iprint,csave,lsave,&amp;(isave[22-1]),dsave, itfile);
<a name="l00513"></a>00513   } <span class="comment">//setulb()</span>
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="comment">//   ************</span>
<a name="l00517"></a>00517   <span class="comment">//</span>
<a name="l00518"></a>00518   <span class="comment">//   Subroutine mainlb</span>
<a name="l00519"></a>00519   <span class="comment">//</span>
<a name="l00520"></a>00520   <span class="comment">//   This subroutine solves bound constrained optimization problems by</span>
<a name="l00521"></a>00521   <span class="comment">//     using the compact formula of the limited memory BFGS updates.</span>
<a name="l00522"></a>00522   <span class="comment">//     </span>
<a name="l00523"></a>00523   <span class="comment">//   n is an integer variable.</span>
<a name="l00524"></a>00524   <span class="comment">//     On entry n is the number of variables.</span>
<a name="l00525"></a>00525   <span class="comment">//     On exit n is unchanged.</span>
<a name="l00526"></a>00526   <span class="comment">//</span>
<a name="l00527"></a>00527   <span class="comment">//   m is an integer variable.</span>
<a name="l00528"></a>00528   <span class="comment">//     On entry m is the maximum number of variable metri//</span>
<a name="l00529"></a>00529   <span class="comment">//        corrections allowed in the limited memory matrix.</span>
<a name="l00530"></a>00530   <span class="comment">//     On exit m is unchanged.</span>
<a name="l00531"></a>00531   <span class="comment">//</span>
<a name="l00532"></a>00532   <span class="comment">//   x is a double precision array of dimension n.</span>
<a name="l00533"></a>00533   <span class="comment">//     On entry x is an approximation to the solution.</span>
<a name="l00534"></a>00534   <span class="comment">//     On exit x is the current approximation.</span>
<a name="l00535"></a>00535   <span class="comment">//</span>
<a name="l00536"></a>00536   <span class="comment">//   l is a double precision array of dimension n.</span>
<a name="l00537"></a>00537   <span class="comment">//     On entry l is the lower bound of x.</span>
<a name="l00538"></a>00538   <span class="comment">//     On exit l is unchanged.</span>
<a name="l00539"></a>00539   <span class="comment">//</span>
<a name="l00540"></a>00540   <span class="comment">//   u is a double precision array of dimension n.</span>
<a name="l00541"></a>00541   <span class="comment">//     On entry u is the upper bound of x.</span>
<a name="l00542"></a>00542   <span class="comment">//     On exit u is unchanged.</span>
<a name="l00543"></a>00543   <span class="comment">//</span>
<a name="l00544"></a>00544   <span class="comment">//   nbd is an integer array of dimension n.</span>
<a name="l00545"></a>00545   <span class="comment">//     On entry nbd represents the type of bounds imposed on the</span>
<a name="l00546"></a>00546   <span class="comment">//       variables, and must be specified as follows:</span>
<a name="l00547"></a>00547   <span class="comment">//       nbd(i)=0 if x(i) is unbounded,</span>
<a name="l00548"></a>00548   <span class="comment">//              1 if x(i) has only a lower bound,</span>
<a name="l00549"></a>00549   <span class="comment">//              2 if x(i) has both lower and upper bounds,</span>
<a name="l00550"></a>00550   <span class="comment">//              3 if x(i) has only an upper bound.</span>
<a name="l00551"></a>00551   <span class="comment">//     On exit nbd is unchanged.</span>
<a name="l00552"></a>00552   <span class="comment">//</span>
<a name="l00553"></a>00553   <span class="comment">//   f is a double precision variable.</span>
<a name="l00554"></a>00554   <span class="comment">//     On first entry f is unspecified.</span>
<a name="l00555"></a>00555   <span class="comment">//     On final exit f is the value of the function at x.</span>
<a name="l00556"></a>00556   <span class="comment">//</span>
<a name="l00557"></a>00557   <span class="comment">//   g is a double precision array of dimension n.</span>
<a name="l00558"></a>00558   <span class="comment">//     On first entry g is unspecified.</span>
<a name="l00559"></a>00559   <span class="comment">//     On final exit g is the value of the gradient at x.</span>
<a name="l00560"></a>00560   <span class="comment">//</span>
<a name="l00561"></a>00561   <span class="comment">//   factr is a double precision variable.</span>
<a name="l00562"></a>00562   <span class="comment">//     On entry factr &gt;= 0 is specified by the user.  The iteration</span>
<a name="l00563"></a>00563   <span class="comment">//       will stop when</span>
<a name="l00564"></a>00564   <span class="comment">//</span>
<a name="l00565"></a>00565   <span class="comment">//       (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} &lt;= factr*epsmch</span>
<a name="l00566"></a>00566   <span class="comment">//</span>
<a name="l00567"></a>00567   <span class="comment">//       where epsmch is the machine precision, which is automatically</span>
<a name="l00568"></a>00568   <span class="comment">//       generated by the code.</span>
<a name="l00569"></a>00569   <span class="comment">//     On exit factr is unchanged.</span>
<a name="l00570"></a>00570   <span class="comment">//</span>
<a name="l00571"></a>00571   <span class="comment">//   pgtol is a double precision variable.</span>
<a name="l00572"></a>00572   <span class="comment">//     On entry pgtol &gt;= 0 is specified by the user.  The iteration</span>
<a name="l00573"></a>00573   <span class="comment">//       will stop when</span>
<a name="l00574"></a>00574   <span class="comment">//</span>
<a name="l00575"></a>00575   <span class="comment">//               max{|proj g_i | i = 1, ..., n} &lt;= pgtol</span>
<a name="l00576"></a>00576   <span class="comment">//</span>
<a name="l00577"></a>00577   <span class="comment">//       where pg_i is the ith component of the projected gradient.</span>
<a name="l00578"></a>00578   <span class="comment">//     On exit pgtol is unchanged.</span>
<a name="l00579"></a>00579   <span class="comment">//</span>
<a name="l00580"></a>00580   <span class="comment">//   ws, wy, sy, and wt are double precision working arrays used to</span>
<a name="l00581"></a>00581   <span class="comment">//     store the following information defining the limited memory</span>
<a name="l00582"></a>00582   <span class="comment">//        BFGS matrix:</span>
<a name="l00583"></a>00583   <span class="comment">//        ws, of dimension n x m, stores S, the matrix of s-vectors;</span>
<a name="l00584"></a>00584   <span class="comment">//        wy, of dimension n x m, stores Y, the matrix of y-vectors;</span>
<a name="l00585"></a>00585   <span class="comment">//        sy, of dimension m x m, stores S'Y;</span>
<a name="l00586"></a>00586   <span class="comment">//        ss, of dimension m x m, stores S'S;</span>
<a name="l00587"></a>00587   <span class="comment">//       yy, of dimension m x m, stores Y'Y;</span>
<a name="l00588"></a>00588   <span class="comment">//        wt, of dimension m x m, stores the Cholesky factorization</span>
<a name="l00589"></a>00589   <span class="comment">//                                of (theta*S'S+LD^(-1)L'); see eq.</span>
<a name="l00590"></a>00590   <span class="comment">//                                (2.26) in [3].</span>
<a name="l00591"></a>00591   <span class="comment">//</span>
<a name="l00592"></a>00592   <span class="comment">//   wn is a double precision working array of dimension 2m x 2m</span>
<a name="l00593"></a>00593   <span class="comment">//     used to store the LEL^T factorization of the indefinite matrix</span>
<a name="l00594"></a>00594   <span class="comment">//               K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]</span>
<a name="l00595"></a>00595   <span class="comment">//                   [L_a -R_z           theta*S'AA'S ]</span>
<a name="l00596"></a>00596   <span class="comment">//</span>
<a name="l00597"></a>00597   <span class="comment">//     where     E = [-I  0]</span>
<a name="l00598"></a>00598   <span class="comment">//                   [ 0  I]</span>
<a name="l00599"></a>00599   <span class="comment">//</span>
<a name="l00600"></a>00600   <span class="comment">//   snd is a double precision working array of dimension 2m x 2m</span>
<a name="l00601"></a>00601   <span class="comment">//     used to store the lower triangular part of</span>
<a name="l00602"></a>00602   <span class="comment">//               N = [Y' ZZ'Y   L_a'+R_z']</span>
<a name="l00603"></a>00603   <span class="comment">//                   [L_a +R_z  S'AA'S   ]</span>
<a name="l00604"></a>00604   <span class="comment">//         </span>
<a name="l00605"></a>00605   <span class="comment">//   z(n),r(n),d(n),t(n),wa(8*m) are double precision working arrays.</span>
<a name="l00606"></a>00606   <span class="comment">//     z is used at different times to store the Cauchy point and</span>
<a name="l00607"></a>00607   <span class="comment">//     the Newton point.</span>
<a name="l00608"></a>00608   <span class="comment">//</span>
<a name="l00609"></a>00609   <span class="comment">//   sg(m),sgo(m),yg(m),ygo(m) are double precision working arrays. </span>
<a name="l00610"></a>00610   <span class="comment">//</span>
<a name="l00611"></a>00611   <span class="comment">//   index is an integer working array of dimension n.</span>
<a name="l00612"></a>00612   <span class="comment">//     In subroutine freev, index is used to store the free and fixed</span>
<a name="l00613"></a>00613   <span class="comment">//        variables at the Generalized Cauchy Point (GCP).</span>
<a name="l00614"></a>00614   <span class="comment">//</span>
<a name="l00615"></a>00615   <span class="comment">//   iwhere is an integer working array of dimension n used to record</span>
<a name="l00616"></a>00616   <span class="comment">//     the status of the vector x for GCP computation.</span>
<a name="l00617"></a>00617   <span class="comment">//     iwhere(i)=0 or -3 if x(i) is free and has bounds,</span>
<a name="l00618"></a>00618   <span class="comment">//               1       if x(i) is fixed at l(i), and l(i) != u(i)</span>
<a name="l00619"></a>00619   <span class="comment">//               2       if x(i) is fixed at u(i), and u(i) != l(i)</span>
<a name="l00620"></a>00620   <span class="comment">//               3       if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)</span>
<a name="l00621"></a>00621   <span class="comment">//              -1       if x(i) is always free, i.e., no bounds on it.</span>
<a name="l00622"></a>00622   <span class="comment">//</span>
<a name="l00623"></a>00623   <span class="comment">//   indx2 is an integer working array of dimension n.</span>
<a name="l00624"></a>00624   <span class="comment">//     Within subroutine cauchy, indx2 corresponds to the array iorder.</span>
<a name="l00625"></a>00625   <span class="comment">//     In subroutine freev, a list of variables entering and leaving</span>
<a name="l00626"></a>00626   <span class="comment">//     the free set is stored in indx2, and it is passed on to</span>
<a name="l00627"></a>00627   <span class="comment">//     subroutine formk with this information.</span>
<a name="l00628"></a>00628   <span class="comment">//</span>
<a name="l00629"></a>00629   <span class="comment">//   task is a working string of characters of length 60 indicating</span>
<a name="l00630"></a>00630   <span class="comment">//     the current job when entering and leaving this subroutine.</span>
<a name="l00631"></a>00631   <span class="comment">//</span>
<a name="l00632"></a>00632   <span class="comment">//   iprint is an INTEGER variable that must be set by the user.</span>
<a name="l00633"></a>00633   <span class="comment">//     It controls the frequency and type of output generated:</span>
<a name="l00634"></a>00634   <span class="comment">//      iprint&lt;0    no output is generated;</span>
<a name="l00635"></a>00635   <span class="comment">//      iprint=0    print only one line at the last iteration;</span>
<a name="l00636"></a>00636   <span class="comment">//      0&lt;iprint&lt;99 print also f and |proj g| every iprint iterations;</span>
<a name="l00637"></a>00637   <span class="comment">//      iprint=99   print details of every iteration except n-vectors;</span>
<a name="l00638"></a>00638   <span class="comment">//      iprint=100  print also the changes of active set and final x;</span>
<a name="l00639"></a>00639   <span class="comment">//      iprint&gt;100  print details of every iteration including x and g;</span>
<a name="l00640"></a>00640   <span class="comment">//     When iprint &gt; 0, the file iterate.dat will be created to</span>
<a name="l00641"></a>00641   <span class="comment">//                      summarize the iteration.</span>
<a name="l00642"></a>00642   <span class="comment">//</span>
<a name="l00643"></a>00643   <span class="comment">//   csave is a working string of characters of length 60.</span>
<a name="l00644"></a>00644   <span class="comment">//</span>
<a name="l00645"></a>00645   <span class="comment">//   lsave is a logical working array of dimension 4.</span>
<a name="l00646"></a>00646   <span class="comment">//</span>
<a name="l00647"></a>00647   <span class="comment">//   isave is an integer working array of dimension 23.</span>
<a name="l00648"></a>00648   <span class="comment">//</span>
<a name="l00649"></a>00649   <span class="comment">//   dsave is a double precision working array of dimension 29.</span>
<a name="l00650"></a>00650   <span class="comment">//</span>
<a name="l00651"></a>00651   <span class="comment">//</span>
<a name="l00652"></a>00652   <span class="comment">//   Subprograms called</span>
<a name="l00653"></a>00653   <span class="comment">//</span>
<a name="l00654"></a>00654   <span class="comment">//     L-BFGS-B Library ... cauchy, subsm, lnsrlb, formk, </span>
<a name="l00655"></a>00655   <span class="comment">//</span>
<a name="l00656"></a>00656   <span class="comment">//      errclb, prn1lb, prn2lb, prn3lb, active, projgr,</span>
<a name="l00657"></a>00657   <span class="comment">//</span>
<a name="l00658"></a>00658   <span class="comment">//      freev, cmprlb, matupd, formt.</span>
<a name="l00659"></a>00659   <span class="comment">//</span>
<a name="l00660"></a>00660   <span class="comment">//     Minpack2 Library ... timer, dpmeps.</span>
<a name="l00661"></a>00661   <span class="comment">//</span>
<a name="l00662"></a>00662   <span class="comment">//     Linpack Library ... dcopy, ddot.</span>
<a name="l00663"></a>00663   <span class="comment">//</span>
<a name="l00664"></a>00664   <span class="comment">//</span>
<a name="l00665"></a>00665   <span class="comment">//   References:</span>
<a name="l00666"></a>00666   <span class="comment">//</span>
<a name="l00667"></a>00667   <span class="comment">//     [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited</span>
<a name="l00668"></a>00668   <span class="comment">//     memory algorithm for bound constrained optimization'',</span>
<a name="l00669"></a>00669   <span class="comment">//     SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.</span>
<a name="l00670"></a>00670   <span class="comment">//</span>
<a name="l00671"></a>00671   <span class="comment">//     [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN</span>
<a name="l00672"></a>00672   <span class="comment">//     Subroutines for Large Scale Bound Constrained Optimization''</span>
<a name="l00673"></a>00673   <span class="comment">//     Tech. Report, NAM-11, EECS Department, Northwestern University,</span>
<a name="l00674"></a>00674   <span class="comment">//     1994.</span>
<a name="l00675"></a>00675   <span class="comment">// </span>
<a name="l00676"></a>00676   <span class="comment">//     [3] R. Byrd, J. Nocedal and R. Schnabel "Representations of</span>
<a name="l00677"></a>00677   <span class="comment">//     Quasi-Newton Matrices and their use in Limited Memory Methods'',</span>
<a name="l00678"></a>00678   <span class="comment">//     Mathematical Programming 63 (1994), no. 4, pp. 129-156.</span>
<a name="l00679"></a>00679   <span class="comment">//</span>
<a name="l00680"></a>00680   <span class="comment">//     (Postscript files of these papers are available via anonymous</span>
<a name="l00681"></a>00681   <span class="comment">//      ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)</span>
<a name="l00682"></a>00682   <span class="comment">//</span>
<a name="l00683"></a>00683   <span class="comment">//                         *  *  *</span>
<a name="l00684"></a>00684   <span class="comment">//</span>
<a name="l00685"></a>00685   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l00686"></a>00686   <span class="comment">//   Optimization Technology Center.</span>
<a name="l00687"></a>00687   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l00688"></a>00688   <span class="comment">//   Written by</span>
<a name="l00689"></a>00689   <span class="comment">//                      Ciyou Zhu</span>
<a name="l00690"></a>00690   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l00691"></a>00691   <span class="comment">//</span>
<a name="l00692"></a>00692   <span class="comment">//</span>
<a name="l00693"></a>00693   <span class="comment">//   ************</span>
<a name="l00694"></a>00694   <span class="comment">//function</span>
<a name="l00695"></a>00695   <span class="keywordtype">void</span> mainlb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, 
<a name="l00696"></a>00696               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, 
<a name="l00697"></a>00697               <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; nbd, <span class="keywordtype">double</span>&amp; f,  <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; g, 
<a name="l00698"></a>00698               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; factr, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; pgtol, 
<a name="l00699"></a>00699               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ws, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wy, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sy,
<a name="l00700"></a>00700               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ss, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; yy, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wt,
<a name="l00701"></a>00701               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wn, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; snd, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; z,
<a name="l00702"></a>00702               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; r, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; d, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; t, 
<a name="l00703"></a>00703               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wa, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sg, <span class="keywordtype">double</span>* <span class="keyword">const</span>&amp; sgo,
<a name="l00704"></a>00704               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; yg, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ygo, <span class="keywordtype">int</span>* <span class="keyword">const</span>&amp; index,
<a name="l00705"></a>00705               <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; iwhere, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; indx2, <span class="keywordtype">char</span>* <span class="keyword">const</span>&amp; task,
<a name="l00706"></a>00706               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint, <span class="keywordtype">char</span>* <span class="keyword">const</span>&amp; csave, <span class="keywordtype">bool</span> * <span class="keyword">const</span>&amp; lsave,
<a name="l00707"></a>00707               <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; isave, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dsave, ofstream* itfile)
<a name="l00708"></a>00708   {
<a name="l00709"></a>00709     <span class="keywordtype">bool</span>   prjctd,cnstnd,boxed,updatd,wrk;
<a name="l00710"></a>00710     <span class="keywordtype">char</span>   word[4];
<a name="l00711"></a>00711     <span class="keywordtype">int</span>    k,nintol,iback,nskip,
<a name="l00712"></a>00712            head,col,iter,itail,iupdat,
<a name="l00713"></a>00713            nint,nfgv,info,ifun=0,
<a name="l00714"></a>00714            iword,nfree,nact,ileave,nenter;
<a name="l00715"></a>00715     <span class="keywordtype">double</span> theta,fold=0,dr,rr,tol,
<a name="l00716"></a>00716            xstep,sbgnrm,ddum,dnorm=0,dtd,epsmch,
<a name="l00717"></a>00717            cpu1=0,cpu2,cachyt,sbtime,lnscht,time1,time2,
<a name="l00718"></a>00718            gd,gdold=0,stp,stpmx=0,time;
<a name="l00719"></a>00719     <span class="keywordtype">double</span> one=1.0,zero=0.0;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     <span class="keywordflow">if</span> (iprint &gt; 1) { assert(itfile); }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723     <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"START"</span>,5)==0)
<a name="l00724"></a>00724     {
<a name="l00725"></a>00725       time1 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>();
<a name="l00726"></a>00726 
<a name="l00727"></a>00727       <span class="comment">//Generate the current machine precision.</span>
<a name="l00728"></a>00728       epsmch = dpmeps();
<a name="l00729"></a>00729       <span class="comment">//epsmch = 1.08420217E-19;</span>
<a name="l00730"></a>00730       <span class="comment">//cout &lt;&lt; "L-BFGS-B computed machine precision = " &lt;&lt; epsmch &lt;&lt; endl;</span>
<a name="l00731"></a>00731 
<a name="l00732"></a>00732       <span class="comment">//Initialize counters and scalars when task='START'.</span>
<a name="l00733"></a>00733 
<a name="l00734"></a>00734       <span class="comment">//for the limited memory BFGS matrices:</span>
<a name="l00735"></a>00735       col    = 0;
<a name="l00736"></a>00736       head   = 1;
<a name="l00737"></a>00737       theta  = one;
<a name="l00738"></a>00738       iupdat = 0;
<a name="l00739"></a>00739       updatd = <span class="keyword">false</span>;
<a name="l00740"></a>00740  
<a name="l00741"></a>00741       <span class="comment">//for operation counts:</span>
<a name="l00742"></a>00742       iter   = 0;
<a name="l00743"></a>00743       nfgv   = 0;
<a name="l00744"></a>00744       nint   = 0;
<a name="l00745"></a>00745       nintol = 0;
<a name="l00746"></a>00746       nskip  = 0;
<a name="l00747"></a>00747       nfree  = n;
<a name="l00748"></a>00748 
<a name="l00749"></a>00749       <span class="comment">//for stopping tolerance:</span>
<a name="l00750"></a>00750       tol = factr*epsmch;
<a name="l00751"></a>00751 
<a name="l00752"></a>00752       <span class="comment">//for measuring running time:</span>
<a name="l00753"></a>00753       cachyt = 0;
<a name="l00754"></a>00754       sbtime = 0;
<a name="l00755"></a>00755       lnscht = 0;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757  
<a name="l00758"></a>00758       <span class="comment">//'word' records the status of subspace solutions.</span>
<a name="l00759"></a>00759       strcpy(word, <span class="stringliteral">"---"</span>);
<a name="l00760"></a>00760 
<a name="l00761"></a>00761       <span class="comment">//'info' records the termination information.</span>
<a name="l00762"></a>00762       info = 0;
<a name="l00763"></a>00763 
<a name="l00764"></a>00764       <span class="comment">//commented out: file opened at beginning of function</span>
<a name="l00765"></a>00765       <span class="comment">//if (iprint &gt;= 1)</span>
<a name="l00766"></a>00766       <span class="comment">//{</span>
<a name="l00767"></a>00767       <span class="comment">//  //open a summary file 'iterate.dat'</span>
<a name="l00768"></a>00768       <span class="comment">//  ofstream itfile("lbfgsb-iterate.dat");</span>
<a name="l00769"></a>00769       <span class="comment">//}</span>
<a name="l00770"></a>00770 
<a name="l00771"></a>00771       <span class="comment">//Check the input arguments for errors.</span>
<a name="l00772"></a>00772       errclb(n,m,factr,l,u,nbd,task,info,k);
<a name="l00773"></a>00773       <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"ERROR"</span>,5)==0)
<a name="l00774"></a>00774       {
<a name="l00775"></a>00775         prn3lb(n,x,f,task,iprint,info,itfile,
<a name="l00776"></a>00776                iter,nfgv,nintol,nskip,nact,sbgnrm,
<a name="l00777"></a>00777                zero,nint,word,iback,stp,xstep,k,
<a name="l00778"></a>00778                cachyt,sbtime,lnscht);
<a name="l00779"></a>00779         <span class="keywordflow">return</span>;
<a name="l00780"></a>00780       }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782       prn1lb(n,m,l,u,x,iprint,itfile,epsmch);
<a name="l00783"></a>00783  
<a name="l00784"></a>00784       <span class="comment">//Initialize iwhere &amp; project x onto the feasible set.</span>
<a name="l00785"></a>00785       active(n,l,u,nbd,x,iwhere,iprint,prjctd,cnstnd,boxed) ;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787       <span class="comment">//The end of the initialization.</span>
<a name="l00788"></a>00788     } <span class="comment">//if (strncmp(task,"START",5)==0)</span>
<a name="l00789"></a>00789     <span class="keywordflow">else</span>
<a name="l00790"></a>00790     {
<a name="l00791"></a>00791       <span class="comment">//restore local variables.</span>
<a name="l00792"></a>00792 
<a name="l00793"></a>00793       prjctd = lsave[1];
<a name="l00794"></a>00794       cnstnd = lsave[2];
<a name="l00795"></a>00795       boxed  = lsave[3];
<a name="l00796"></a>00796       updatd = lsave[4];
<a name="l00797"></a>00797       
<a name="l00798"></a>00798       nintol = isave[1];
<a name="l00799"></a>00799       <span class="comment">//itfile = isave[3];</span>
<a name="l00800"></a>00800       iback  = isave[4];
<a name="l00801"></a>00801       nskip  = isave[5];
<a name="l00802"></a>00802       head   = isave[6];
<a name="l00803"></a>00803       col    = isave[7];
<a name="l00804"></a>00804       itail  = isave[8];
<a name="l00805"></a>00805       iter   = isave[9];
<a name="l00806"></a>00806       iupdat = isave[10];
<a name="l00807"></a>00807       nint   = isave[12];
<a name="l00808"></a>00808       nfgv   = isave[13];
<a name="l00809"></a>00809       info   = isave[14];
<a name="l00810"></a>00810       ifun   = isave[15];
<a name="l00811"></a>00811       iword  = isave[16];
<a name="l00812"></a>00812       nfree  = isave[17];
<a name="l00813"></a>00813       nact   = isave[18];
<a name="l00814"></a>00814       ileave = isave[19];
<a name="l00815"></a>00815       nenter = isave[20];
<a name="l00816"></a>00816 
<a name="l00817"></a>00817       theta  = dsave[1];
<a name="l00818"></a>00818       fold   = dsave[2];
<a name="l00819"></a>00819       tol    = dsave[3];
<a name="l00820"></a>00820       dnorm  = dsave[4];
<a name="l00821"></a>00821       epsmch = dsave[5];
<a name="l00822"></a>00822       cpu1   = dsave[6];
<a name="l00823"></a>00823       cachyt = dsave[7];
<a name="l00824"></a>00824       sbtime = dsave[8];
<a name="l00825"></a>00825       lnscht = dsave[9];
<a name="l00826"></a>00826       time1  = dsave[10];
<a name="l00827"></a>00827       gd     = dsave[11];
<a name="l00828"></a>00828       stpmx  = dsave[12];
<a name="l00829"></a>00829       sbgnrm = dsave[13];
<a name="l00830"></a>00830       stp    = dsave[14];
<a name="l00831"></a>00831       gdold  = dsave[15];
<a name="l00832"></a>00832       dtd    = dsave[16];
<a name="l00833"></a>00833          
<a name="l00834"></a>00834    
<a name="l00835"></a>00835       <span class="comment">//After returning from the driver go to the point where execution</span>
<a name="l00836"></a>00836       <span class="comment">//is to resume.</span>
<a name="l00837"></a>00837       <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"FG_LN"</span>,5)==0) <span class="keywordflow">goto</span> goto66;
<a name="l00838"></a>00838       <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"NEW_X"</span>,5)==0) <span class="keywordflow">goto</span> goto777;
<a name="l00839"></a>00839       <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"FG_ST"</span>,5)==0) <span class="keywordflow">goto</span> goto111;
<a name="l00840"></a>00840       <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"STOP"</span>,4)==0)  
<a name="l00841"></a>00841       {
<a name="l00842"></a>00842         <span class="keywordflow">if</span> (strncmp(&amp;(task[6]),<span class="stringliteral">"CPU"</span>,3)==0)
<a name="l00843"></a>00843         {
<a name="l00844"></a>00844           <span class="comment">//restore the previous iterate.</span>
<a name="l00845"></a>00845           dcopy(n,t,1,x,1);
<a name="l00846"></a>00846           dcopy(n,r,1,g,1);
<a name="l00847"></a>00847           f = fold;
<a name="l00848"></a>00848         }
<a name="l00849"></a>00849         <span class="keywordflow">goto</span> goto999;
<a name="l00850"></a>00850       }
<a name="l00851"></a>00851     }
<a name="l00852"></a>00852 
<a name="l00853"></a>00853     <span class="comment">//Compute f0 and g0.</span>
<a name="l00854"></a>00854     
<a name="l00855"></a>00855     strcpy(task, <span class="stringliteral">"FG_START"</span>);
<a name="l00856"></a>00856     <span class="comment">//return to the driver to calculate f and g; reenter at goto111.</span>
<a name="l00857"></a>00857     <span class="keywordflow">goto</span> goto1000;
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   goto111:
<a name="l00860"></a>00860     
<a name="l00861"></a>00861     nfgv = 1;
<a name="l00862"></a>00862  
<a name="l00863"></a>00863     <span class="comment">//Compute the infinity norm of the (-) projected gradient.</span>
<a name="l00864"></a>00864  
<a name="l00865"></a>00865     projgr(n,l,u,nbd,x,g,sbgnrm);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867     <span class="keywordflow">if</span> (iprint &gt;= 1)
<a name="l00868"></a>00868     {
<a name="l00869"></a>00869       cout &lt;&lt; <span class="stringliteral">"At iterate "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">": f="</span> &lt;&lt;f&lt;&lt;<span class="stringliteral">",  |proj g|="</span>&lt;&lt;sbgnrm&lt;&lt;endl;
<a name="l00870"></a>00870       *itfile &lt;&lt; <span class="stringliteral">"At iterate "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">": nfgv="</span> &lt;&lt; nfgv 
<a name="l00871"></a>00871               &lt;&lt; <span class="stringliteral">", sbgnrm="</span> &lt;&lt; sbgnrm &lt;&lt; <span class="stringliteral">", f="</span> &lt;&lt; f &lt;&lt; endl;
<a name="l00872"></a>00872     }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     <span class="keywordflow">if</span> (sbgnrm &lt;= pgtol) 
<a name="l00875"></a>00875     {
<a name="l00876"></a>00876       <span class="comment">//terminate the algorithm.</span>
<a name="l00877"></a>00877       strcpy(task,<span class="stringliteral">"CONVERGENCE: NORM OF PROJECTED GRADIENT &lt;= PGTOL"</span>);
<a name="l00878"></a>00878       <span class="keywordflow">goto</span> goto999;
<a name="l00879"></a>00879     }
<a name="l00880"></a>00880  
<a name="l00881"></a>00881     <span class="comment">//----------------- the beginning of the loop ---------------------</span>
<a name="l00882"></a>00882  
<a name="l00883"></a>00883   goto222:
<a name="l00884"></a>00884     <span class="keywordflow">if</span> (iprint &gt;= 99) cout &lt;&lt; <span class="stringliteral">"ITERATION "</span> &lt;&lt; (iter + 1) &lt;&lt; endl;
<a name="l00885"></a>00885     iword = -1;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887     <span class="keywordflow">if</span> (!cnstnd &amp;&amp; col &gt; 0) 
<a name="l00888"></a>00888     {
<a name="l00889"></a>00889       <span class="comment">//skip the search for GCP.</span>
<a name="l00890"></a>00890       dcopy(n,x,1,z,1);
<a name="l00891"></a>00891       wrk = updatd;
<a name="l00892"></a>00892       nint = 0;
<a name="l00893"></a>00893       <span class="keywordflow">goto</span> goto333;
<a name="l00894"></a>00894     }
<a name="l00895"></a>00895 
<a name="l00896"></a>00896     <span class="comment">/*********************************************************************</span>
<a name="l00897"></a>00897 <span class="comment">     *</span>
<a name="l00898"></a>00898 <span class="comment">     *     Compute the Generalized Cauchy Point (GCP).</span>
<a name="l00899"></a>00899 <span class="comment">     *</span>
<a name="l00900"></a>00900 <span class="comment">     *********************************************************************/</span>
<a name="l00901"></a>00901 
<a name="l00902"></a>00902     cpu1 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>();
<a name="l00903"></a>00903 
<a name="l00904"></a>00904     cauchy(n,x,l,u,nbd,g,indx2,iwhere,t,d,z,
<a name="l00905"></a>00905            m,wy,ws,sy,wt,theta,col,head,
<a name="l00906"></a>00906            &amp;(wa[1-1]),&amp;(wa[2*m+1-1]),&amp;(wa[4*m+1-1]),&amp;(wa[6*m+1-1]),nint,
<a name="l00907"></a>00907            sg,yg,iprint,sbgnrm,info,epsmch);
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     <span class="keywordflow">if</span> (info &gt; 0)
<a name="l00910"></a>00910     { 
<a name="l00911"></a>00911       <span class="comment">//singular triangular system detected; refresh the lbfgs memory.</span>
<a name="l00912"></a>00912       <span class="keywordflow">if</span> (iprint &gt;= 1) 
<a name="l00913"></a>00913         cout &lt;&lt; <span class="stringliteral">"Singular triangular system detected; "</span> 
<a name="l00914"></a>00914              &lt;&lt; <span class="stringliteral">"refresh the lbfgs memory and restart the iteration."</span> &lt;&lt;endl;
<a name="l00915"></a>00915       info   = 0;
<a name="l00916"></a>00916       col    = 0;
<a name="l00917"></a>00917       head   = 1;
<a name="l00918"></a>00918       theta  = one;
<a name="l00919"></a>00919       iupdat = 0;
<a name="l00920"></a>00920       updatd = <span class="keyword">false</span>;
<a name="l00921"></a>00921       cpu2 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>();
<a name="l00922"></a>00922       cachyt = cachyt + cpu2 - cpu1;
<a name="l00923"></a>00923       <span class="keywordflow">goto</span> goto222;
<a name="l00924"></a>00924     }
<a name="l00925"></a>00925     cpu2 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>(); 
<a name="l00926"></a>00926     cachyt = cachyt + cpu2 - cpu1;
<a name="l00927"></a>00927     nintol = nintol + nint;
<a name="l00928"></a>00928 
<a name="l00929"></a>00929     <span class="comment">//Count the entering and leaving variables for iter &gt; 0; </span>
<a name="l00930"></a>00930     <span class="comment">//find the index set of free and active variables at the GCP.</span>
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     freev(n,nfree,index,nenter,ileave,indx2,
<a name="l00933"></a>00933           iwhere,wrk,updatd,cnstnd,iprint,iter);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935     nact = n - nfree;
<a name="l00936"></a>00936  
<a name="l00937"></a>00937   goto333:
<a name="l00938"></a>00938  
<a name="l00939"></a>00939     <span class="comment">//If there are no free variables or B=theta*I, then</span>
<a name="l00940"></a>00940     <span class="comment">//skip the subspace minimization.</span>
<a name="l00941"></a>00941  
<a name="l00942"></a>00942     <span class="keywordflow">if</span> (nfree == 0 || col == 0) <span class="keywordflow">goto</span> goto555;
<a name="l00943"></a>00943  
<a name="l00944"></a>00944     <span class="comment">/**********************************************************************</span>
<a name="l00945"></a>00945 <span class="comment">     *</span>
<a name="l00946"></a>00946 <span class="comment">     *     Subspace minimization.</span>
<a name="l00947"></a>00947 <span class="comment">     *</span>
<a name="l00948"></a>00948 <span class="comment">     **********************************************************************/</span>
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     cpu1 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>();
<a name="l00951"></a>00951 
<a name="l00952"></a>00952     <span class="comment">//Form  the LEL^T factorization of the indefinite</span>
<a name="l00953"></a>00953     <span class="comment">//matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]</span>
<a name="l00954"></a>00954     <span class="comment">//              [L_a -R_z           theta*S'AA'S ]</span>
<a name="l00955"></a>00955     <span class="comment">//where     E = [-I  0]</span>
<a name="l00956"></a>00956     <span class="comment">//              [ 0  I]</span>
<a name="l00957"></a>00957 
<a name="l00958"></a>00958     <span class="keywordflow">if</span> (wrk) formk(n,nfree,index,nenter,ileave,indx2,iupdat,
<a name="l00959"></a>00959                    updatd,wn,snd,m,ws,wy,sy,theta,col,head,info);
<a name="l00960"></a>00960 
<a name="l00961"></a>00961     <span class="keywordflow">if</span> (info != 0) 
<a name="l00962"></a>00962     {
<a name="l00963"></a>00963       <span class="comment">//nonpositive definiteness in Cholesky factorization;</span>
<a name="l00964"></a>00964       <span class="comment">//refresh the lbfgs memory and restart the iteration.</span>
<a name="l00965"></a>00965       <span class="keywordflow">if</span>(iprint &gt;= 1) 
<a name="l00966"></a>00966         cout &lt;&lt; <span class="stringliteral">"Nonpositive definiteness in Cholesky factorization in formk;"</span>
<a name="l00967"></a>00967              &lt;&lt; <span class="stringliteral">"refresh the lbfgs memory and restart the iteration."</span> &lt;&lt; endl;
<a name="l00968"></a>00968       info   = 0;
<a name="l00969"></a>00969       col    = 0;
<a name="l00970"></a>00970       head   = 1;
<a name="l00971"></a>00971       theta  = one;
<a name="l00972"></a>00972       iupdat = 0;
<a name="l00973"></a>00973       updatd = <span class="keyword">false</span>;
<a name="l00974"></a>00974       cpu2 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>() ;
<a name="l00975"></a>00975       sbtime = sbtime + cpu2 - cpu1;
<a name="l00976"></a>00976       <span class="keywordflow">goto</span> goto222;
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979     <span class="comment">//compute r=-Z'B(xcp-xk)-Z'g (using wa(2m+1)=W'(xcp-x)</span>
<a name="l00980"></a>00980     <span class="comment">//from 'cauchy').</span>
<a name="l00981"></a>00981     cmprlb(n,m,x,g,ws,wy,sy,wt,z,r,wa,index,
<a name="l00982"></a>00982            theta,col,head,nfree,cnstnd,info);
<a name="l00983"></a>00983     
<a name="l00984"></a>00984     <span class="keywordflow">if</span> (info != 0) <span class="keywordflow">goto</span> goto444;
<a name="l00985"></a>00985     <span class="comment">//call the direct method.</span>
<a name="l00986"></a>00986     subsm(n,m,nfree,index,l,u,nbd,z,r,ws,wy,theta,
<a name="l00987"></a>00987           col,head,iword,wa,wn,iprint,info);
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   goto444:
<a name="l00991"></a>00991     <span class="keywordflow">if</span> (info != 0) 
<a name="l00992"></a>00992     {
<a name="l00993"></a>00993       <span class="comment">//singular triangular system detected;</span>
<a name="l00994"></a>00994       <span class="comment">//refresh the lbfgs memory and restart the iteration.</span>
<a name="l00995"></a>00995       <span class="keywordflow">if</span>(iprint &gt;= 1)         
<a name="l00996"></a>00996         cout &lt;&lt; <span class="stringliteral">"Singular triangular system detected; "</span> 
<a name="l00997"></a>00997              &lt;&lt; <span class="stringliteral">"refresh the lbfgs memory and restart the iteration."</span> &lt;&lt;endl;
<a name="l00998"></a>00998       info   = 0;
<a name="l00999"></a>00999       col    = 0;
<a name="l01000"></a>01000       head   = 1;
<a name="l01001"></a>01001       theta  = one;
<a name="l01002"></a>01002       iupdat = 0;
<a name="l01003"></a>01003       updatd = <span class="keyword">false</span>;
<a name="l01004"></a>01004       cpu2   = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>(); 
<a name="l01005"></a>01005       sbtime = sbtime + cpu2 - cpu1;
<a name="l01006"></a>01006       <span class="keywordflow">goto</span> goto222;
<a name="l01007"></a>01007     }
<a name="l01008"></a>01008  
<a name="l01009"></a>01009     cpu2 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>(); 
<a name="l01010"></a>01010     sbtime = sbtime + cpu2 - cpu1 ;
<a name="l01011"></a>01011   goto555:  
<a name="l01012"></a>01012 
<a name="l01013"></a>01013     <span class="comment">/*********************************************************************</span>
<a name="l01014"></a>01014 <span class="comment">     *</span>
<a name="l01015"></a>01015 <span class="comment">     *     Line search and optimality tests.</span>
<a name="l01016"></a>01016 <span class="comment">     *</span>
<a name="l01017"></a>01017 <span class="comment">     *********************************************************************/</span>
<a name="l01018"></a>01018  
<a name="l01019"></a>01019     <span class="comment">//Generate the search direction d:=z-x.</span>
<a name="l01020"></a>01020 
<a name="l01021"></a>01021     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l01022"></a>01022       d[i] = z[i] - x[i];
<a name="l01023"></a>01023     
<a name="l01024"></a>01024     cpu1 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>();
<a name="l01025"></a>01025   goto66: 
<a name="l01026"></a>01026 
<a name="l01027"></a>01027     lnsrlb(n,l,u,nbd,x,f,fold,gd,gdold,g,d,r,t,z,stp,dnorm,
<a name="l01028"></a>01028            dtd,xstep,stpmx,iter,ifun,iback,nfgv,info,task,
<a name="l01029"></a>01029            boxed,cnstnd,csave,&amp;(isave[22-1]),&amp;(dsave[17-1]));
<a name="l01030"></a>01030 
<a name="l01031"></a>01031     <span class="keywordflow">if</span> (info != 0 || iback &gt;= 20)
<a name="l01032"></a>01032     {
<a name="l01033"></a>01033       <span class="comment">//restore the previous iterate.</span>
<a name="l01034"></a>01034       dcopy(n,t,1,x,1);
<a name="l01035"></a>01035       dcopy(n,r,1,g,1);
<a name="l01036"></a>01036       f = fold;
<a name="l01037"></a>01037       <span class="keywordflow">if</span> (col == 0) 
<a name="l01038"></a>01038       {
<a name="l01039"></a>01039         <span class="comment">//abnormal termination.</span>
<a name="l01040"></a>01040         <span class="keywordflow">if</span> (info == 0) 
<a name="l01041"></a>01041         {
<a name="l01042"></a>01042           info = -9;
<a name="l01043"></a>01043           <span class="comment">//restore the actual number of f and g evaluations etc.</span>
<a name="l01044"></a>01044           nfgv  -=  1;
<a name="l01045"></a>01045           ifun  -=  1;
<a name="l01046"></a>01046           iback -= 1;
<a name="l01047"></a>01047         }
<a name="l01048"></a>01048         strcpy(task, <span class="stringliteral">"ABNORMAL_TERMINATION_IN_LNSRCH"</span>);
<a name="l01049"></a>01049         iter += 1;
<a name="l01050"></a>01050         <span class="keywordflow">goto</span> goto999;
<a name="l01051"></a>01051       }
<a name="l01052"></a>01052       <span class="keywordflow">else</span>
<a name="l01053"></a>01053       {
<a name="l01054"></a>01054         <span class="comment">//refresh the lbfgs memory and restart the iteration.</span>
<a name="l01055"></a>01055         <span class="keywordflow">if</span>(iprint &gt;= 1)
<a name="l01056"></a>01056           cout &lt;&lt; <span class="stringliteral">"Bad direction in the line search; "</span> 
<a name="l01057"></a>01057                &lt;&lt; <span class="stringliteral">"the lbfgs memory and restart the iteration"</span> &lt;&lt; endl;
<a name="l01058"></a>01058         <span class="keywordflow">if</span> (info == 0) nfgv = nfgv - 1;
<a name="l01059"></a>01059         info   = 0;
<a name="l01060"></a>01060         col    = 0;
<a name="l01061"></a>01061         head   = 1;
<a name="l01062"></a>01062         theta  = one;
<a name="l01063"></a>01063         iupdat = 0;
<a name="l01064"></a>01064         updatd = <span class="keyword">false</span>;
<a name="l01065"></a>01065         strcpy(task, <span class="stringliteral">"RESTART_FROM_LNSRCH"</span>);
<a name="l01066"></a>01066         cpu2 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>();
<a name="l01067"></a>01067         lnscht += cpu2 - cpu1;
<a name="l01068"></a>01068         <span class="keywordflow">goto</span> goto222;
<a name="l01069"></a>01069       }
<a name="l01070"></a>01070     }
<a name="l01071"></a>01071     <span class="keywordflow">else</span> 
<a name="l01072"></a>01072     <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"FG_LN"</span>,5)==0) 
<a name="l01073"></a>01073     {
<a name="l01074"></a>01074       <span class="comment">//return to the driver for calculating f and g; reenter at goto66.</span>
<a name="l01075"></a>01075       <span class="keywordflow">goto</span> goto1000;
<a name="l01076"></a>01076     }
<a name="l01077"></a>01077     <span class="keywordflow">else</span> 
<a name="l01078"></a>01078     {
<a name="l01079"></a>01079       <span class="comment">//calculate and print out the quantities related to the new X.</span>
<a name="l01080"></a>01080       cpu2 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>() ;
<a name="l01081"></a>01081       lnscht += cpu2 - cpu1;
<a name="l01082"></a>01082       iter += 1;
<a name="l01083"></a>01083       
<a name="l01084"></a>01084       <span class="comment">//Compute the infinity norm of the projected (-)gradient.</span>
<a name="l01085"></a>01085       
<a name="l01086"></a>01086       projgr(n,l,u,nbd,x,g,sbgnrm);
<a name="l01087"></a>01087       
<a name="l01088"></a>01088       <span class="comment">//Print iteration information.</span>
<a name="l01089"></a>01089       
<a name="l01090"></a>01090       prn2lb(n,x,f,g,iprint,itfile,iter,nfgv,nact,
<a name="l01091"></a>01091              sbgnrm,nint,word,iword,iback,stp,xstep);
<a name="l01092"></a>01092       <span class="keywordflow">goto</span> goto1000;
<a name="l01093"></a>01093     }
<a name="l01094"></a>01094   goto777:
<a name="l01095"></a>01095 
<a name="l01096"></a>01096     <span class="comment">//Test for termination.</span>
<a name="l01097"></a>01097     
<a name="l01098"></a>01098     <span class="keywordflow">if</span> (sbgnrm &lt;= pgtol) 
<a name="l01099"></a>01099     {
<a name="l01100"></a>01100       <span class="comment">//terminate the algorithm.</span>
<a name="l01101"></a>01101       strcpy(task, <span class="stringliteral">"CONVERGENCE: NORM OF PROJECTED GRADIENT &lt;= PGTOL"</span>);
<a name="l01102"></a>01102       <span class="keywordflow">goto</span> goto999;
<a name="l01103"></a>01103     } 
<a name="l01104"></a>01104     
<a name="l01105"></a>01105     ddum = max(fabs(fold), fabs(f), one);
<a name="l01106"></a>01106     <span class="keywordflow">if</span> ((fold - f) &lt;= tol*ddum) 
<a name="l01107"></a>01107     {
<a name="l01108"></a>01108       <span class="comment">//terminate the algorithm.</span>
<a name="l01109"></a>01109       strcpy(task, <span class="stringliteral">"CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH"</span>);
<a name="l01110"></a>01110       <span class="keywordflow">if</span> (iback &gt;= 10) info = -5;
<a name="l01111"></a>01111         <span class="comment">//i.e., to issue a warning if iback&gt;10 in the line search.</span>
<a name="l01112"></a>01112       <span class="keywordflow">goto</span> goto999;
<a name="l01113"></a>01113     } 
<a name="l01114"></a>01114     
<a name="l01115"></a>01115     <span class="comment">//Compute d=newx-oldx, r=newg-oldg, rr=y'y and dr=y's.</span>
<a name="l01116"></a>01116     
<a name="l01117"></a>01117     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l01118"></a>01118       r[i] = g[i] - r[i];
<a name="l01119"></a>01119     rr = ddot(n,r,1,r,1);
<a name="l01120"></a>01120     <span class="keywordflow">if</span> (stp == one) 
<a name="l01121"></a>01121     {  
<a name="l01122"></a>01122       dr = gd - gdold;
<a name="l01123"></a>01123       ddum = -gdold;
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     <span class="keywordflow">else</span>
<a name="l01126"></a>01126     {
<a name="l01127"></a>01127       dr = (gd - gdold)*stp;
<a name="l01128"></a>01128       dscal(n,stp,d,1);
<a name="l01129"></a>01129       ddum = -gdold*stp;
<a name="l01130"></a>01130     }
<a name="l01131"></a>01131     
<a name="l01132"></a>01132     <span class="keywordflow">if</span> (dr &lt;= epsmch*ddum) 
<a name="l01133"></a>01133     {
<a name="l01134"></a>01134       <span class="comment">//skip the L-BFGS update.</span>
<a name="l01135"></a>01135       nskip = nskip + 1;
<a name="l01136"></a>01136       updatd = <span class="keyword">false</span>;
<a name="l01137"></a>01137       <span class="keywordflow">if</span> (iprint &gt;= 1) 
<a name="l01138"></a>01138         cout &lt;&lt; <span class="stringliteral">"  ys="</span> &lt;&lt; dr &lt;&lt; <span class="stringliteral">"   -gs="</span> &lt;&lt;ddum&lt;&lt;<span class="stringliteral">" BFSG update SKIPPED"</span>&lt;&lt;endl;
<a name="l01139"></a>01139       <span class="keywordflow">goto</span> goto888;
<a name="l01140"></a>01140     } 
<a name="l01141"></a>01141     
<a name="l01142"></a>01142   <span class="comment">/*********************************************************************</span>
<a name="l01143"></a>01143 <span class="comment">   *</span>
<a name="l01144"></a>01144 <span class="comment">   *     Update the L-BFGS matrix.</span>
<a name="l01145"></a>01145 <span class="comment">   *</span>
<a name="l01146"></a>01146 <span class="comment">   *********************************************************************/</span>
<a name="l01147"></a>01147  
<a name="l01148"></a>01148     updatd = <span class="keyword">true</span>;
<a name="l01149"></a>01149     iupdat += 1;
<a name="l01150"></a>01150 
<a name="l01151"></a>01151     <span class="comment">//Update matrices WS and WY and form the middle matrix in B.</span>
<a name="l01152"></a>01152 
<a name="l01153"></a>01153     matupd(n,m,ws,wy,sy,ss,d,r,itail,
<a name="l01154"></a>01154            iupdat,col,head,theta,rr,dr,stp,dtd);
<a name="l01155"></a>01155 
<a name="l01156"></a>01156     <span class="comment">//Form the upper half of the pds T = theta*SS + L*D^(-1)*L';</span>
<a name="l01157"></a>01157     <span class="comment">//Store T in the upper triangular of the array wt;</span>
<a name="l01158"></a>01158     <span class="comment">//Cholesky factorize T to J*J' with</span>
<a name="l01159"></a>01159     <span class="comment">//J' stored in the upper triangular of wt.</span>
<a name="l01160"></a>01160 
<a name="l01161"></a>01161     formt(m,wt,sy,ss,col,theta,info);
<a name="l01162"></a>01162  
<a name="l01163"></a>01163     <span class="keywordflow">if</span> (info != 0) 
<a name="l01164"></a>01164     {
<a name="l01165"></a>01165       <span class="comment">//nonpositive definiteness in Cholesky factorization;</span>
<a name="l01166"></a>01166       <span class="comment">//refresh the lbfgs memory and restart the iteration.</span>
<a name="l01167"></a>01167       <span class="keywordflow">if</span>(iprint &gt;= 1) 
<a name="l01168"></a>01168         cout &lt;&lt; <span class="stringliteral">"Nonpositive definiteness in Cholesky factorization in formt; "</span>
<a name="l01169"></a>01169              &lt;&lt; <span class="stringliteral">"refresh the lbfgs memory and restart the iteration."</span> &lt;&lt; endl;
<a name="l01170"></a>01170       info = 0;
<a name="l01171"></a>01171       col  = 0;
<a name="l01172"></a>01172       head = 1;
<a name="l01173"></a>01173       theta = one;
<a name="l01174"></a>01174       iupdat = 0;
<a name="l01175"></a>01175       updatd = <span class="keyword">false</span>;
<a name="l01176"></a>01176       <span class="keywordflow">goto</span> goto222;
<a name="l01177"></a>01177     }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <span class="comment">//Now the inverse of the middle matrix in B is</span>
<a name="l01180"></a>01180 
<a name="l01181"></a>01181     <span class="comment">//[  D^(1/2)      O ] [ -D^(1/2)  D^(-1/2)*L' ]</span>
<a name="l01182"></a>01182     <span class="comment">//[ -L*D^(-1/2)   J ] [  0        J'          ]</span>
<a name="l01183"></a>01183 
<a name="l01184"></a>01184   goto888:
<a name="l01185"></a>01185  
<a name="l01186"></a>01186     <span class="comment">//-------------------- the end of the loop -----------------------------</span>
<a name="l01187"></a>01187  
<a name="l01188"></a>01188     <span class="keywordflow">goto</span> goto222;
<a name="l01189"></a>01189 
<a name="l01190"></a>01190   goto999:
<a name="l01191"></a>01191     time2 = timer_.<a class="code" href="classTimer.html#37be13bfa31ef41de4c1dcccacf97bd2">time</a>();
<a name="l01192"></a>01192     time = time2 - time1;
<a name="l01193"></a>01193     prn3lb(n,x,f,task,iprint,info,itfile,
<a name="l01194"></a>01194            iter,nfgv,nintol,nskip,nact,sbgnrm,
<a name="l01195"></a>01195            time,nint,word,iback,stp,xstep,k,
<a name="l01196"></a>01196            cachyt,sbtime,lnscht);
<a name="l01197"></a>01197   goto1000:
<a name="l01198"></a>01198 
<a name="l01199"></a>01199     <span class="comment">//Save local variables.</span>
<a name="l01200"></a>01200     lsave[1]  = prjctd;
<a name="l01201"></a>01201     lsave[2]  = cnstnd;
<a name="l01202"></a>01202     lsave[3]  = boxed;
<a name="l01203"></a>01203     lsave[4]  = updatd;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205     isave[1]  = nintol; 
<a name="l01206"></a>01206     <span class="comment">//isave[3]  = itfile;</span>
<a name="l01207"></a>01207     isave[4]  = iback;
<a name="l01208"></a>01208     isave[5]  = nskip; 
<a name="l01209"></a>01209     isave[6]  = head;
<a name="l01210"></a>01210     isave[7]  = col;
<a name="l01211"></a>01211     isave[8]  = itail;
<a name="l01212"></a>01212     isave[9]  = iter; 
<a name="l01213"></a>01213     isave[10] = iupdat; 
<a name="l01214"></a>01214     isave[12] = nint; 
<a name="l01215"></a>01215     isave[13] = nfgv; 
<a name="l01216"></a>01216     isave[14] = info; 
<a name="l01217"></a>01217     isave[15] = ifun; 
<a name="l01218"></a>01218     isave[16] = iword; 
<a name="l01219"></a>01219     isave[17] = nfree; 
<a name="l01220"></a>01220     isave[18] = nact; 
<a name="l01221"></a>01221     isave[19] = ileave; 
<a name="l01222"></a>01222     isave[20] = nenter; 
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     dsave[1]  = theta; 
<a name="l01225"></a>01225     dsave[2]  = fold; 
<a name="l01226"></a>01226     dsave[3]  = tol; 
<a name="l01227"></a>01227     dsave[4]  = dnorm; 
<a name="l01228"></a>01228     dsave[5]  = epsmch; 
<a name="l01229"></a>01229     dsave[6]  = cpu1; 
<a name="l01230"></a>01230     dsave[7]  = cachyt; 
<a name="l01231"></a>01231     dsave[8]  = sbtime; 
<a name="l01232"></a>01232     dsave[9]  = lnscht; 
<a name="l01233"></a>01233     dsave[10] = time1;
<a name="l01234"></a>01234     dsave[11] = gd;
<a name="l01235"></a>01235     dsave[12] = stpmx; 
<a name="l01236"></a>01236     dsave[13] = sbgnrm;
<a name="l01237"></a>01237     dsave[14] = stp;
<a name="l01238"></a>01238     dsave[15] = gdold;
<a name="l01239"></a>01239     dsave[16] = dtd;
<a name="l01240"></a>01240 
<a name="l01241"></a>01241   }<span class="comment">//mainlb()</span>
<a name="l01242"></a>01242 
<a name="l01243"></a>01243 
<a name="l01244"></a>01244   <span class="comment">//   ************</span>
<a name="l01245"></a>01245   <span class="comment">//</span>
<a name="l01246"></a>01246   <span class="comment">//   Subroutine active</span>
<a name="l01247"></a>01247   <span class="comment">//</span>
<a name="l01248"></a>01248   <span class="comment">//   This subroutine initializes iwhere and projects the initial x to</span>
<a name="l01249"></a>01249   <span class="comment">//     the feasible set if necessary.</span>
<a name="l01250"></a>01250   <span class="comment">//</span>
<a name="l01251"></a>01251   <span class="comment">//   iwhere is an integer array of dimension n.</span>
<a name="l01252"></a>01252   <span class="comment">//     On entry iwhere is unspecified.</span>
<a name="l01253"></a>01253   <span class="comment">//     On exit iwhere(i)=-1  if x(i) has no bounds</span>
<a name="l01254"></a>01254   <span class="comment">//                       3   if l(i)=u(i)</span>
<a name="l01255"></a>01255   <span class="comment">//                       0   otherwise.</span>
<a name="l01256"></a>01256   <span class="comment">//     In cauchy, iwhere is given finer gradations.</span>
<a name="l01257"></a>01257   <span class="comment">//</span>
<a name="l01258"></a>01258   <span class="comment">//</span>
<a name="l01259"></a>01259   <span class="comment">//                         *  *  *</span>
<a name="l01260"></a>01260   <span class="comment">//</span>
<a name="l01261"></a>01261   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l01262"></a>01262   <span class="comment">//   Optimization Technology Center.</span>
<a name="l01263"></a>01263   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l01264"></a>01264   <span class="comment">//   Written by</span>
<a name="l01265"></a>01265   <span class="comment">//                      Ciyou Zhu</span>
<a name="l01266"></a>01266   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l01267"></a>01267   <span class="comment">//</span>
<a name="l01268"></a>01268   <span class="comment">//</span>
<a name="l01269"></a>01269   <span class="comment">//   ************</span>
<a name="l01270"></a>01270     <span class="comment">//function</span>
<a name="l01271"></a>01271   <span class="keywordtype">void</span> active(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, 
<a name="l01272"></a>01272               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; nbd, 
<a name="l01273"></a>01273               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; iwhere, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint,
<a name="l01274"></a>01274               <span class="keywordtype">bool</span>&amp; prjctd, <span class="keywordtype">bool</span>&amp; cnstnd, <span class="keywordtype">bool</span>&amp; boxed)
<a name="l01275"></a>01275   {
<a name="l01276"></a>01276     <span class="comment">//int i;</span>
<a name="l01277"></a>01277     <span class="keywordtype">int</span> nbdd;
<a name="l01278"></a>01278     <span class="keywordtype">double</span> zero=0.0;
<a name="l01279"></a>01279 
<a name="l01280"></a>01280     <span class="comment">//Initialize nbdd, prjctd, cnstnd and boxed.</span>
<a name="l01281"></a>01281     nbdd   = 0;
<a name="l01282"></a>01282     prjctd = <span class="keyword">false</span>;
<a name="l01283"></a>01283     cnstnd = <span class="keyword">false</span>;
<a name="l01284"></a>01284     boxed  = <span class="keyword">true</span>;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="comment">//Project the initial x to the easible set if necessary.</span>
<a name="l01287"></a>01287 
<a name="l01288"></a>01288     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l01289"></a>01289     {
<a name="l01290"></a>01290       <span class="keywordflow">if</span> (nbd[i] &gt; 0)
<a name="l01291"></a>01291       {
<a name="l01292"></a>01292         <span class="keywordflow">if</span> (nbd[i] &lt;= 2 &amp;&amp; x[i] &lt;= l[i])
<a name="l01293"></a>01293         {
<a name="l01294"></a>01294                 <span class="keywordflow">if</span> (x[i] &lt; l[i])
<a name="l01295"></a>01295           {
<a name="l01296"></a>01296             prjctd = <span class="keyword">true</span>;
<a name="l01297"></a>01297                   x[i] = l[i];
<a name="l01298"></a>01298           }
<a name="l01299"></a>01299           nbdd += 1;
<a name="l01300"></a>01300         }
<a name="l01301"></a>01301         <span class="keywordflow">else</span> 
<a name="l01302"></a>01302         <span class="keywordflow">if</span> (nbd[i] &gt;= 2 &amp;&amp; x[i] &gt;= u[i])
<a name="l01303"></a>01303         {
<a name="l01304"></a>01304                 <span class="keywordflow">if</span> (x[i] &gt; u[i])
<a name="l01305"></a>01305           {
<a name="l01306"></a>01306             prjctd = <span class="keyword">true</span>;
<a name="l01307"></a>01307                   x[i] = u[i];
<a name="l01308"></a>01308           }
<a name="l01309"></a>01309           nbdd += 1;
<a name="l01310"></a>01310         }
<a name="l01311"></a>01311       }
<a name="l01312"></a>01312     }
<a name="l01313"></a>01313 
<a name="l01314"></a>01314     <span class="comment">//Initialize iwhere and assign values to cnstnd and boxed.</span>
<a name="l01315"></a>01315 
<a name="l01316"></a>01316     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l01317"></a>01317     {
<a name="l01318"></a>01318       <span class="keywordflow">if</span> (nbd[i] != 2) boxed = <span class="keyword">false</span>;
<a name="l01319"></a>01319       <span class="keywordflow">if</span> (nbd[i] == 0)
<a name="l01320"></a>01320       {
<a name="l01321"></a>01321         <span class="comment">//this variable is always free</span>
<a name="l01322"></a>01322         iwhere[i] = -1;
<a name="l01323"></a>01323         <span class="comment">//otherwise set x(i)=mid(x(i), u(i), l(i)).</span>
<a name="l01324"></a>01324       }
<a name="l01325"></a>01325       <span class="keywordflow">else</span>
<a name="l01326"></a>01326       {
<a name="l01327"></a>01327         cnstnd = <span class="keyword">true</span>;
<a name="l01328"></a>01328         <span class="keywordflow">if</span> (nbd[i] == 2 &amp;&amp; (u[i]-l[i]) &lt;= zero)
<a name="l01329"></a>01329         {
<a name="l01330"></a>01330           <span class="comment">//this variable is always fixed</span>
<a name="l01331"></a>01331           iwhere[i] = 3;
<a name="l01332"></a>01332         }
<a name="l01333"></a>01333         <span class="keywordflow">else</span> 
<a name="l01334"></a>01334           iwhere[i] = 0;
<a name="l01335"></a>01335       }
<a name="l01336"></a>01336     }
<a name="l01337"></a>01337     
<a name="l01338"></a>01338     <span class="keywordflow">if</span> (iprint &gt;= 0)
<a name="l01339"></a>01339     {
<a name="l01340"></a>01340       <span class="keywordflow">if</span> (prjctd) 
<a name="l01341"></a>01341         cout &lt;&lt; <span class="stringliteral">"The initial X is infeasible.  Restart with its projection."</span>
<a name="l01342"></a>01342              &lt;&lt; endl;
<a name="l01343"></a>01343       <span class="keywordflow">if</span> (!cnstnd) cout &lt;&lt; <span class="stringliteral">"This problem is unconstrained."</span> &lt;&lt; endl;
<a name="l01344"></a>01344     }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346     <span class="keywordflow">if</span> (iprint &gt; 0) 
<a name="l01347"></a>01347       cout &lt;&lt; <span class="stringliteral">"At X0 "</span> &lt;&lt; nbdd &lt;&lt; <span class="stringliteral">" variables are exactly at the bounds"</span> &lt;&lt;endl;
<a name="l01348"></a>01348   }<span class="comment">//active()</span>
<a name="l01349"></a>01349 
<a name="l01350"></a>01350 
<a name="l01351"></a>01351   <span class="comment">//   ************</span>
<a name="l01352"></a>01352   <span class="comment">//</span>
<a name="l01353"></a>01353   <span class="comment">//   Subroutine bmv</span>
<a name="l01354"></a>01354   <span class="comment">//</span>
<a name="l01355"></a>01355   <span class="comment">//   This subroutine computes the product of the 2m x 2m middle matrix </span>
<a name="l01356"></a>01356   <span class="comment">//     in the compact L-BFGS formula of B and a 2m vector v;  </span>
<a name="l01357"></a>01357   <span class="comment">//     it returns the product in p.</span>
<a name="l01358"></a>01358   <span class="comment">//    </span>
<a name="l01359"></a>01359   <span class="comment">//   m is an integer variable.</span>
<a name="l01360"></a>01360   <span class="comment">//     On entry m is the maximum number of variable metric corrections</span>
<a name="l01361"></a>01361   <span class="comment">//       used to define the limited memory matrix.</span>
<a name="l01362"></a>01362   <span class="comment">//     On exit m is unchanged.</span>
<a name="l01363"></a>01363   <span class="comment">//</span>
<a name="l01364"></a>01364   <span class="comment">//   sy is a double precision array of dimension m x m.</span>
<a name="l01365"></a>01365   <span class="comment">//     On entry sy specifies the matrix S'Y.</span>
<a name="l01366"></a>01366   <span class="comment">//     On exit sy is unchanged.</span>
<a name="l01367"></a>01367   <span class="comment">//</span>
<a name="l01368"></a>01368   <span class="comment">//   wt is a double precision array of dimension m x m.</span>
<a name="l01369"></a>01369   <span class="comment">//     On entry wt specifies the upper triangular matrix J' which is </span>
<a name="l01370"></a>01370   <span class="comment">//       the Cholesky factor of (thetaS'S+LD^(-1)L').</span>
<a name="l01371"></a>01371   <span class="comment">//     On exit wt is unchanged.</span>
<a name="l01372"></a>01372   <span class="comment">//</span>
<a name="l01373"></a>01373   <span class="comment">//   col is an integer variable.</span>
<a name="l01374"></a>01374   <span class="comment">//     On entry col specifies the number of s-vectors (or y-vectors)</span>
<a name="l01375"></a>01375   <span class="comment">//       stored in the compact L-BFGS formula.</span>
<a name="l01376"></a>01376   <span class="comment">//     On exit col is unchanged.</span>
<a name="l01377"></a>01377   <span class="comment">//</span>
<a name="l01378"></a>01378   <span class="comment">//   v is a double precision array of dimension 2col.</span>
<a name="l01379"></a>01379   <span class="comment">//     On entry v specifies vector v.</span>
<a name="l01380"></a>01380   <span class="comment">//     On exit v is unchanged.</span>
<a name="l01381"></a>01381   <span class="comment">//</span>
<a name="l01382"></a>01382   <span class="comment">//   p is a double precision array of dimension 2col.</span>
<a name="l01383"></a>01383   <span class="comment">//     On entry p is unspecified.</span>
<a name="l01384"></a>01384   <span class="comment">//     On exit p is the product Mv.</span>
<a name="l01385"></a>01385   <span class="comment">//</span>
<a name="l01386"></a>01386   <span class="comment">//   info is an integer variable.</span>
<a name="l01387"></a>01387   <span class="comment">//     On entry info is unspecified.</span>
<a name="l01388"></a>01388   <span class="comment">//     On exit info = 0       for normal return,</span>
<a name="l01389"></a>01389   <span class="comment">//                  = nonzero for abnormal return when the system</span>
<a name="l01390"></a>01390   <span class="comment">//                              to be solved by dtrsl is singular.</span>
<a name="l01391"></a>01391   <span class="comment">//</span>
<a name="l01392"></a>01392   <span class="comment">//   Subprograms called:</span>
<a name="l01393"></a>01393   <span class="comment">//</span>
<a name="l01394"></a>01394   <span class="comment">//     Linpack ... dtrsl.</span>
<a name="l01395"></a>01395   <span class="comment">//</span>
<a name="l01396"></a>01396   <span class="comment">//</span>
<a name="l01397"></a>01397   <span class="comment">//                         *  *  *</span>
<a name="l01398"></a>01398   <span class="comment">//</span>
<a name="l01399"></a>01399   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l01400"></a>01400   <span class="comment">//   Optimization Technology Center.</span>
<a name="l01401"></a>01401   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l01402"></a>01402   <span class="comment">//   Written by</span>
<a name="l01403"></a>01403   <span class="comment">//                      Ciyou Zhu</span>
<a name="l01404"></a>01404   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l01405"></a>01405   <span class="comment">//</span>
<a name="l01406"></a>01406   <span class="comment">//</span>
<a name="l01407"></a>01407   <span class="comment">//   ************</span>
<a name="l01408"></a>01408     <span class="comment">//function</span>
<a name="l01409"></a>01409   <span class="keywordtype">void</span> bmv(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sy, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wt, 
<a name="l01410"></a>01410            <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; col, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; v, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; p, 
<a name="l01411"></a>01411            <span class="keywordtype">int</span>&amp; info)
<a name="l01412"></a>01412   {
<a name="l01413"></a>01413     <span class="comment">//int i,k;</span>
<a name="l01414"></a>01414     <span class="keywordtype">int</span> i2;
<a name="l01415"></a>01415     <span class="keywordtype">double</span> sum;
<a name="l01416"></a>01416  
<a name="l01417"></a>01417     <span class="keywordflow">if</span> (col == 0) <span class="keywordflow">return</span>;
<a name="l01418"></a>01418  
<a name="l01419"></a>01419     <span class="comment">//PART I: solve [  D^(1/2)      O ] [ p1 ] = [ v1 ]</span>
<a name="l01420"></a>01420     <span class="comment">//              [ -L*D^(-1/2)   J ] [ p2 ]   [ v2 ].</span>
<a name="l01421"></a>01421 
<a name="l01422"></a>01422     <span class="comment">//solve Jp2=v2+LD^(-1)v1.</span>
<a name="l01423"></a>01423     p[col+1] = v[col+1];
<a name="l01424"></a>01424 
<a name="l01425"></a>01425     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt;= col; i++)
<a name="l01426"></a>01426     {
<a name="l01427"></a>01427       i2 = col + i;
<a name="l01428"></a>01428       sum = 0;
<a name="l01429"></a>01429       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt;= i-1; k++)
<a name="l01430"></a>01430         sum += sy[getIdx(i,k,m)]*v[k]/sy[getIdx(k,k,m)];
<a name="l01431"></a>01431       
<a name="l01432"></a>01432       p[i2] = v[i2] + sum;
<a name="l01433"></a>01433     }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435     <span class="comment">//Solve the triangular system</span>
<a name="l01436"></a>01436     dtrsl(wt,m,col,&amp;(p[col+1-1]),11,info);
<a name="l01437"></a>01437     <span class="keywordflow">if</span> (info != 0) <span class="keywordflow">return</span>; 
<a name="l01438"></a>01438  
<a name="l01439"></a>01439     <span class="comment">//solve D^(1/2)p1=v1.</span>
<a name="l01440"></a>01440     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= col; i++)
<a name="l01441"></a>01441       p[i] = v[i]/sqrt(sy[getIdx(i,i,m)]);
<a name="l01442"></a>01442  
<a name="l01443"></a>01443     <span class="comment">//PART II: solve [ -D^(1/2)   D^(-1/2)*L'  ] [ p1 ] = [ p1 ]</span>
<a name="l01444"></a>01444     <span class="comment">//               [  0         J'           ] [ p2 ]   [ p2 ]. </span>
<a name="l01445"></a>01445  
<a name="l01446"></a>01446     <span class="comment">//solve J^Tp2=p2. </span>
<a name="l01447"></a>01447     dtrsl(wt,m,col,&amp;(p[col+1-1]),1,info);
<a name="l01448"></a>01448     <span class="keywordflow">if</span> (info != 0) <span class="keywordflow">return</span>;
<a name="l01449"></a>01449  
<a name="l01450"></a>01450     <span class="comment">//compute p1=-D^(-1/2)(p1-D^(-1/2)L'p2)</span>
<a name="l01451"></a>01451     <span class="comment">//          =-D^(-1/2)p1+D^(-1)L'p2.  </span>
<a name="l01452"></a>01452     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= col; i++)
<a name="l01453"></a>01453       p[i] = -p[i]/sqrt(sy[getIdx(i,i,m)]);
<a name="l01454"></a>01454     
<a name="l01455"></a>01455     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= col; i++)
<a name="l01456"></a>01456     {
<a name="l01457"></a>01457       sum = 0;
<a name="l01458"></a>01458       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = i+1; i &lt;= col; i++)
<a name="l01459"></a>01459         sum += sy[getIdx(k,i,m)]*p[col+k]/sy[getIdx(i,i,m)];
<a name="l01460"></a>01460       p[i] += sum;
<a name="l01461"></a>01461     }
<a name="l01462"></a>01462   }<span class="comment">//bmv()</span>
<a name="l01463"></a>01463 
<a name="l01464"></a>01464 
<a name="l01465"></a>01465   <span class="comment">//   ************</span>
<a name="l01466"></a>01466   <span class="comment">//</span>
<a name="l01467"></a>01467   <span class="comment">//   Subroutine cauchy</span>
<a name="l01468"></a>01468   <span class="comment">//</span>
<a name="l01469"></a>01469   <span class="comment">//   For given x, l, u, g (with sbgnrm &gt; 0), and a limited memory</span>
<a name="l01470"></a>01470   <span class="comment">//     BFGS matrix B defined in terms of matrices WY, WS, WT, and</span>
<a name="l01471"></a>01471   <span class="comment">//     scalars head, col, and theta, this subroutine computes the</span>
<a name="l01472"></a>01472   <span class="comment">//     generalized Cauchy point (GCP), defined as the first local</span>
<a name="l01473"></a>01473   <span class="comment">//     minimizer of the quadrati//</span>
<a name="l01474"></a>01474   <span class="comment">//</span>
<a name="l01475"></a>01475   <span class="comment">//                Q(x + s) = g's + 1/2 s'Bs</span>
<a name="l01476"></a>01476   <span class="comment">//</span>
<a name="l01477"></a>01477   <span class="comment">//     along the projected gradient direction P(x-tg,l,u).</span>
<a name="l01478"></a>01478   <span class="comment">//     The routine returns the GCP in xcp. </span>
<a name="l01479"></a>01479   <span class="comment">//     </span>
<a name="l01480"></a>01480   <span class="comment">//   n is an integer variable.</span>
<a name="l01481"></a>01481   <span class="comment">//     On entry n is the dimension of the problem.</span>
<a name="l01482"></a>01482   <span class="comment">//     On exit n is unchanged.</span>
<a name="l01483"></a>01483   <span class="comment">//</span>
<a name="l01484"></a>01484   <span class="comment">//   x is a double precision array of dimension n.</span>
<a name="l01485"></a>01485   <span class="comment">//     On entry x is the starting point for the GCP computation.</span>
<a name="l01486"></a>01486   <span class="comment">//     On exit x is unchanged.</span>
<a name="l01487"></a>01487   <span class="comment">//</span>
<a name="l01488"></a>01488   <span class="comment">//   l is a double precision array of dimension n.</span>
<a name="l01489"></a>01489   <span class="comment">//     On entry l is the lower bound of x.</span>
<a name="l01490"></a>01490   <span class="comment">//     On exit l is unchanged.</span>
<a name="l01491"></a>01491   <span class="comment">//</span>
<a name="l01492"></a>01492   <span class="comment">//   u is a double precision array of dimension n.</span>
<a name="l01493"></a>01493   <span class="comment">//     On entry u is the upper bound of x.</span>
<a name="l01494"></a>01494   <span class="comment">//     On exit u is unchanged.</span>
<a name="l01495"></a>01495   <span class="comment">//</span>
<a name="l01496"></a>01496   <span class="comment">//   nbd is an integer array of dimension n.</span>
<a name="l01497"></a>01497   <span class="comment">//     On entry nbd represents the type of bounds imposed on the</span>
<a name="l01498"></a>01498   <span class="comment">//       variables, and must be specified as follows:</span>
<a name="l01499"></a>01499   <span class="comment">//       nbd(i)=0 if x(i) is unbounded,</span>
<a name="l01500"></a>01500   <span class="comment">//              1 if x(i) has only a lower bound,</span>
<a name="l01501"></a>01501   <span class="comment">//              2 if x(i) has both lower and upper bounds, and</span>
<a name="l01502"></a>01502   <span class="comment">//              3 if x(i) has only an upper bound. </span>
<a name="l01503"></a>01503   <span class="comment">//     On exit nbd is unchanged.</span>
<a name="l01504"></a>01504   <span class="comment">//</span>
<a name="l01505"></a>01505   <span class="comment">//   g is a double precision array of dimension n.</span>
<a name="l01506"></a>01506   <span class="comment">//     On entry g is the gradient of f(x).  g must be a nonzero vector.</span>
<a name="l01507"></a>01507   <span class="comment">//     On exit g is unchanged.</span>
<a name="l01508"></a>01508   <span class="comment">//</span>
<a name="l01509"></a>01509   <span class="comment">//   iorder is an integer working array of dimension n.</span>
<a name="l01510"></a>01510   <span class="comment">//     iorder will be used to store the breakpoints in the piecewise</span>
<a name="l01511"></a>01511   <span class="comment">//     linear path and free variables encountered. On exit,</span>
<a name="l01512"></a>01512   <span class="comment">//       iorder(1),...,iorder(nleft) are indices of breakpoints</span>
<a name="l01513"></a>01513   <span class="comment">//                              which have not been encountered; </span>
<a name="l01514"></a>01514   <span class="comment">//       iorder(nleft+1),...,iorder(nbreak) are indices of</span>
<a name="l01515"></a>01515   <span class="comment">//                                   encountered breakpoints; and</span>
<a name="l01516"></a>01516   <span class="comment">//       iorder(nfree),...,iorder(n) are indices of variables which</span>
<a name="l01517"></a>01517   <span class="comment">//               have no bound constraits along the search direction.</span>
<a name="l01518"></a>01518   <span class="comment">//</span>
<a name="l01519"></a>01519   <span class="comment">//   iwhere is an integer array of dimension n.</span>
<a name="l01520"></a>01520   <span class="comment">//     On entry iwhere indicates only the permanently fixed (iwhere=3)</span>
<a name="l01521"></a>01521   <span class="comment">//     or free (iwhere= -1) components of x.</span>
<a name="l01522"></a>01522   <span class="comment">//     On exit iwhere records the status of the current x variables.</span>
<a name="l01523"></a>01523   <span class="comment">//     iwhere(i)=-3  if x(i) is free and has bounds, but is not moved</span>
<a name="l01524"></a>01524   <span class="comment">//               0   if x(i) is free and has bounds, and is moved</span>
<a name="l01525"></a>01525   <span class="comment">//               1   if x(i) is fixed at l(i), and l(i) != u(i)</span>
<a name="l01526"></a>01526   <span class="comment">//               2   if x(i) is fixed at u(i), and u(i) != l(i)</span>
<a name="l01527"></a>01527   <span class="comment">//               3   if x(i) is always fixed, i.e.,  u(i)=x(i)=l(i)</span>
<a name="l01528"></a>01528   <span class="comment">//               -1  if x(i) is always free, i.e., it has no bounds.</span>
<a name="l01529"></a>01529   <span class="comment">//</span>
<a name="l01530"></a>01530   <span class="comment">//   t is a double precision working array of dimension n. </span>
<a name="l01531"></a>01531   <span class="comment">//     t will be used to store the break points.</span>
<a name="l01532"></a>01532   <span class="comment">//</span>
<a name="l01533"></a>01533   <span class="comment">//   d is a double precision array of dimension n used to store</span>
<a name="l01534"></a>01534   <span class="comment">//     the Cauchy direction P(x-tg)-x.</span>
<a name="l01535"></a>01535   <span class="comment">//</span>
<a name="l01536"></a>01536   <span class="comment">//   xcp is a double precision array of dimension n used to return the</span>
<a name="l01537"></a>01537   <span class="comment">//     GCP on exit.</span>
<a name="l01538"></a>01538   <span class="comment">//</span>
<a name="l01539"></a>01539   <span class="comment">//   m is an integer variable.</span>
<a name="l01540"></a>01540   <span class="comment">//     On entry m is the maximum number of variable metric corrections </span>
<a name="l01541"></a>01541   <span class="comment">//       used to define the limited memory matrix.</span>
<a name="l01542"></a>01542   <span class="comment">//     On exit m is unchanged.</span>
<a name="l01543"></a>01543   <span class="comment">//</span>
<a name="l01544"></a>01544   <span class="comment">//   ws, wy, sy, and wt are double precision arrays.</span>
<a name="l01545"></a>01545   <span class="comment">//     On entry they store information that defines the</span>
<a name="l01546"></a>01546   <span class="comment">//                           limited memory BFGS matrix:</span>
<a name="l01547"></a>01547   <span class="comment">//       ws(n,m) stores S, a set of s-vectors;</span>
<a name="l01548"></a>01548   <span class="comment">//       wy(n,m) stores Y, a set of y-vectors;</span>
<a name="l01549"></a>01549   <span class="comment">//       sy(m,m) stores S'Y;</span>
<a name="l01550"></a>01550   <span class="comment">//       wt(m,m) stores the</span>
<a name="l01551"></a>01551   <span class="comment">//               Cholesky factorization of (theta*S'S+LD^(-1)L').</span>
<a name="l01552"></a>01552   <span class="comment">//     On exit these arrays are unchanged.</span>
<a name="l01553"></a>01553   <span class="comment">//</span>
<a name="l01554"></a>01554   <span class="comment">//   theta is a double precision variable.</span>
<a name="l01555"></a>01555   <span class="comment">//     On entry theta is the scaling factor specifying B_0 = theta I.</span>
<a name="l01556"></a>01556   <span class="comment">//     On exit theta is unchanged.</span>
<a name="l01557"></a>01557   <span class="comment">//</span>
<a name="l01558"></a>01558   <span class="comment">//   col is an integer variable.</span>
<a name="l01559"></a>01559   <span class="comment">//     On entry col is the actual number of variable metri//</span>
<a name="l01560"></a>01560   <span class="comment">//       corrections stored so far.</span>
<a name="l01561"></a>01561   <span class="comment">//     On exit col is unchanged.</span>
<a name="l01562"></a>01562   <span class="comment">//</span>
<a name="l01563"></a>01563   <span class="comment">//   head is an integer variable.</span>
<a name="l01564"></a>01564   <span class="comment">//     On entry head is the location of the first s-vector (or y-vector)</span>
<a name="l01565"></a>01565   <span class="comment">//       in S (or Y).</span>
<a name="l01566"></a>01566   <span class="comment">//     On exit col is unchanged.</span>
<a name="l01567"></a>01567   <span class="comment">//</span>
<a name="l01568"></a>01568   <span class="comment">//   p is a double precision working array of dimension 2m.</span>
<a name="l01569"></a>01569   <span class="comment">//     p will be used to store the vector p = W^(T)d.</span>
<a name="l01570"></a>01570   <span class="comment">//</span>
<a name="l01571"></a>01571   <span class="comment">//   c is a double precision working array of dimension 2m.</span>
<a name="l01572"></a>01572   <span class="comment">//     c will be used to store the vector c = W^(T)(xcp-x).</span>
<a name="l01573"></a>01573   <span class="comment">//</span>
<a name="l01574"></a>01574   <span class="comment">//   wbp is a double precision working array of dimension 2m.</span>
<a name="l01575"></a>01575   <span class="comment">//     wbp will be used to store the row of W corresponding</span>
<a name="l01576"></a>01576   <span class="comment">//       to a breakpoint.</span>
<a name="l01577"></a>01577   <span class="comment">//</span>
<a name="l01578"></a>01578   <span class="comment">//   v is a double precision working array of dimension 2m.</span>
<a name="l01579"></a>01579   <span class="comment">//</span>
<a name="l01580"></a>01580   <span class="comment">//   nint is an integer variable.</span>
<a name="l01581"></a>01581   <span class="comment">//     On exit nint records the number of quadratic segments explored</span>
<a name="l01582"></a>01582   <span class="comment">//       in searching for the GCP.</span>
<a name="l01583"></a>01583   <span class="comment">//</span>
<a name="l01584"></a>01584   <span class="comment">//   sg and yg are double precision arrays of dimension m.</span>
<a name="l01585"></a>01585   <span class="comment">//     On entry sg  and yg store S'g and Y'g correspondingly.</span>
<a name="l01586"></a>01586   <span class="comment">//     On exit they are unchanged. </span>
<a name="l01587"></a>01587   <span class="comment">// </span>
<a name="l01588"></a>01588   <span class="comment">//   iprint is an INTEGER variable that must be set by the user.</span>
<a name="l01589"></a>01589   <span class="comment">//     It controls the frequency and type of output generated:</span>
<a name="l01590"></a>01590   <span class="comment">//      iprint&lt;0    no output is generated;</span>
<a name="l01591"></a>01591   <span class="comment">//      iprint=0    print only one line at the last iteration;</span>
<a name="l01592"></a>01592   <span class="comment">//      0&lt;iprint&lt;99 print also f and |proj g| every iprint iterations;</span>
<a name="l01593"></a>01593   <span class="comment">//      iprint=99   print details of every iteration except n-vectors;</span>
<a name="l01594"></a>01594   <span class="comment">//      iprint=100  print also the changes of active set and final x;</span>
<a name="l01595"></a>01595   <span class="comment">//      iprint&gt;100  print details of every iteration including x and g;</span>
<a name="l01596"></a>01596   <span class="comment">//     When iprint &gt; 0, the file iterate.dat will be created to</span>
<a name="l01597"></a>01597   <span class="comment">//                      summarize the iteration.</span>
<a name="l01598"></a>01598   <span class="comment">//</span>
<a name="l01599"></a>01599   <span class="comment">//   sbgnrm is a double precision variable.</span>
<a name="l01600"></a>01600   <span class="comment">//     On entry sbgnrm is the norm of the projected gradient at x.</span>
<a name="l01601"></a>01601   <span class="comment">//     On exit sbgnrm is unchanged.</span>
<a name="l01602"></a>01602   <span class="comment">//</span>
<a name="l01603"></a>01603   <span class="comment">//   info is an integer variable.</span>
<a name="l01604"></a>01604   <span class="comment">//     On entry info is 0.</span>
<a name="l01605"></a>01605   <span class="comment">//     On exit info = 0       for normal return,</span>
<a name="l01606"></a>01606   <span class="comment">//                  = nonzero for abnormal return when the the system</span>
<a name="l01607"></a>01607   <span class="comment">//                            used in routine bmv is singular.</span>
<a name="l01608"></a>01608   <span class="comment">//</span>
<a name="l01609"></a>01609   <span class="comment">//   Subprograms called:</span>
<a name="l01610"></a>01610   <span class="comment">// </span>
<a name="l01611"></a>01611   <span class="comment">//     L-BFGS-B Library ... hpsolb, bmv.</span>
<a name="l01612"></a>01612   <span class="comment">//</span>
<a name="l01613"></a>01613   <span class="comment">//     Linpack ... dscal dcopy, daxpy.</span>
<a name="l01614"></a>01614   <span class="comment">//</span>
<a name="l01615"></a>01615   <span class="comment">//</span>
<a name="l01616"></a>01616   <span class="comment">//   References:</span>
<a name="l01617"></a>01617   <span class="comment">//</span>
<a name="l01618"></a>01618   <span class="comment">//     [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited</span>
<a name="l01619"></a>01619   <span class="comment">//     memory algorithm for bound constrained optimization'',</span>
<a name="l01620"></a>01620   <span class="comment">//     SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.</span>
<a name="l01621"></a>01621   <span class="comment">//</span>
<a name="l01622"></a>01622   <span class="comment">//     [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: FORTRAN</span>
<a name="l01623"></a>01623   <span class="comment">//     Subroutines for Large Scale Bound Constrained Optimization''</span>
<a name="l01624"></a>01624   <span class="comment">//     Tech. Report, NAM-11, EECS Department, Northwestern University,</span>
<a name="l01625"></a>01625   <span class="comment">//     1994.</span>
<a name="l01626"></a>01626   <span class="comment">//</span>
<a name="l01627"></a>01627   <span class="comment">//     (Postscript files of these papers are available via anonymous</span>
<a name="l01628"></a>01628   <span class="comment">//      ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)</span>
<a name="l01629"></a>01629   <span class="comment">//</span>
<a name="l01630"></a>01630   <span class="comment">//                         *  *  *</span>
<a name="l01631"></a>01631   <span class="comment">//</span>
<a name="l01632"></a>01632   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l01633"></a>01633   <span class="comment">//   Optimization Technology Center.</span>
<a name="l01634"></a>01634   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l01635"></a>01635   <span class="comment">//   Written by</span>
<a name="l01636"></a>01636   <span class="comment">//                      Ciyou Zhu</span>
<a name="l01637"></a>01637   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l01638"></a>01638   <span class="comment">//</span>
<a name="l01639"></a>01639   <span class="comment">//</span>
<a name="l01640"></a>01640   <span class="comment">//   ************  </span>
<a name="l01641"></a>01641     <span class="comment">//function</span>
<a name="l01642"></a>01642   <span class="keywordtype">void</span> cauchy(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, 
<a name="l01643"></a>01643               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, 
<a name="l01644"></a>01644               <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; nbd, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; g, 
<a name="l01645"></a>01645               <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; iorder, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; iwhere, 
<a name="l01646"></a>01646               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; t, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; d, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; xcp, 
<a name="l01647"></a>01647               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wy, 
<a name="l01648"></a>01648               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ws, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sy, 
<a name="l01649"></a>01649               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wt, <span class="keywordtype">double</span>&amp; theta, 
<a name="l01650"></a>01650               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; col, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; head, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; p, 
<a name="l01651"></a>01651               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; c, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wbp, 
<a name="l01652"></a>01652               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; v, <span class="keywordtype">int</span>&amp; nint, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sg, 
<a name="l01653"></a>01653               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; yg, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint, 
<a name="l01654"></a>01654               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; sbgnrm, <span class="keywordtype">int</span>&amp; info, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; epsmch)
<a name="l01655"></a>01655   {
<a name="l01656"></a>01656     <span class="keywordtype">bool</span> xlower,xupper,bnded;
<a name="l01657"></a>01657     <span class="comment">//int i,j;</span>
<a name="l01658"></a>01658     <span class="keywordtype">int</span> col2,nfree,nbreak,pointr,
<a name="l01659"></a>01659         ibp,nleft,ibkmin,iter;
<a name="l01660"></a>01660     <span class="keywordtype">double</span> f1,f2,dt,dtm,tsum,dibp,zibp,dibp2,bkmin,
<a name="l01661"></a>01661            tu=0,tl=0,wmc,wmp,wmw,tj,tj0,neggi,
<a name="l01662"></a>01662            f2_org;
<a name="l01663"></a>01663     <span class="keywordtype">double</span> one=1,zero=0;
<a name="l01664"></a>01664  
<a name="l01665"></a>01665     <span class="comment">//Check the status of the variables, reset iwhere(i) if necessary;</span>
<a name="l01666"></a>01666     <span class="comment">//compute the Cauchy direction d and the breakpoints t; initialize</span>
<a name="l01667"></a>01667     <span class="comment">//the derivative f1 and the vector p = W'd (for theta = 1).</span>
<a name="l01668"></a>01668  
<a name="l01669"></a>01669     <span class="keywordflow">if</span> (sbgnrm &lt;= zero)
<a name="l01670"></a>01670     {
<a name="l01671"></a>01671       <span class="keywordflow">if</span> (iprint &gt;= 0) cout &lt;&lt; <span class="stringliteral">"Subgnorm = 0.  GCP = X."</span> &lt;&lt; endl;
<a name="l01672"></a>01672       dcopy(n,x,1,xcp,1);
<a name="l01673"></a>01673       <span class="keywordflow">return</span>;
<a name="l01674"></a>01674     }
<a name="l01675"></a>01675     bnded = <span class="keyword">true</span>;
<a name="l01676"></a>01676     nfree = n + 1;
<a name="l01677"></a>01677     nbreak = 0;
<a name="l01678"></a>01678     ibkmin = 0;
<a name="l01679"></a>01679     bkmin = zero;
<a name="l01680"></a>01680     col2 = 2*col;
<a name="l01681"></a>01681     f1 = zero;
<a name="l01682"></a>01682     <span class="keywordflow">if</span> (iprint &gt;= 99) 
<a name="l01683"></a>01683       cout &lt;&lt; <span class="stringliteral">"---------------- CAUCHY entered-------------------"</span> &lt;&lt; endl;
<a name="l01684"></a>01684 
<a name="l01685"></a>01685     <span class="comment">//We set p to zero and build it up as we determine d.</span>
<a name="l01686"></a>01686     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= col2; i++)
<a name="l01687"></a>01687       p[i] = zero;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     <span class="comment">//In the following loop we determine for each variable its bound</span>
<a name="l01690"></a>01690     <span class="comment">//status and its breakpoint, and update p accordingly.</span>
<a name="l01691"></a>01691     <span class="comment">//Smallest breakpoint is identified.</span>
<a name="l01692"></a>01692 
<a name="l01693"></a>01693     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)      
<a name="l01694"></a>01694     {
<a name="l01695"></a>01695       neggi = -g[i];  
<a name="l01696"></a>01696       <span class="keywordflow">if</span> (iwhere[i] != 3 &amp;&amp; iwhere[i] != -1)
<a name="l01697"></a>01697       {
<a name="l01698"></a>01698         <span class="comment">//if x(i) is not a constant and has bounds,</span>
<a name="l01699"></a>01699         <span class="comment">//compute the difference between x(i) and its bounds.</span>
<a name="l01700"></a>01700         <span class="keywordflow">if</span> (nbd[i] &lt;= 2) tl = x[i] - l[i];
<a name="l01701"></a>01701         <span class="keywordflow">if</span> (nbd[i] &gt;= 2) tu = u[i] - x[i];
<a name="l01702"></a>01702 
<a name="l01703"></a>01703         <span class="comment">//If a variable is close enough to a bound</span>
<a name="l01704"></a>01704         <span class="comment">//we treat it as at bound.</span>
<a name="l01705"></a>01705         xlower = (nbd[i] &lt;= 2 &amp;&amp; tl &lt;= zero);
<a name="l01706"></a>01706         xupper = (nbd[i] &gt;= 2 &amp;&amp; tu &lt;= zero);
<a name="l01707"></a>01707 
<a name="l01708"></a>01708         <span class="comment">//reset iwhere(i).</span>
<a name="l01709"></a>01709         iwhere[i] = 0;
<a name="l01710"></a>01710         <span class="keywordflow">if</span> (xlower)
<a name="l01711"></a>01711         { 
<a name="l01712"></a>01712           <span class="keywordflow">if</span> (neggi &lt;= zero) iwhere[i] = 1;
<a name="l01713"></a>01713         }
<a name="l01714"></a>01714         <span class="keywordflow">else</span> 
<a name="l01715"></a>01715         <span class="keywordflow">if</span> (xupper)
<a name="l01716"></a>01716         {
<a name="l01717"></a>01717           <span class="keywordflow">if</span> (neggi &gt;= zero) iwhere[i] = 2;
<a name="l01718"></a>01718         }
<a name="l01719"></a>01719         <span class="keywordflow">else</span>
<a name="l01720"></a>01720         {
<a name="l01721"></a>01721           <span class="keywordflow">if</span> (fabs(neggi) &lt;= zero) iwhere[i] = -3;
<a name="l01722"></a>01722         }
<a name="l01723"></a>01723       }
<a name="l01724"></a>01724       pointr = head;
<a name="l01725"></a>01725       <span class="keywordflow">if</span> (iwhere[i] != 0 &amp;&amp; iwhere[i] != -1)
<a name="l01726"></a>01726         d[i] = zero;
<a name="l01727"></a>01727       <span class="keywordflow">else</span>
<a name="l01728"></a>01728       {
<a name="l01729"></a>01729         d[i] = neggi;
<a name="l01730"></a>01730         f1 -= neggi*neggi;
<a name="l01731"></a>01731         <span class="comment">//calculate p := p - W'e_i* (g_i).</span>
<a name="l01732"></a>01732         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= col; j++)
<a name="l01733"></a>01733         {
<a name="l01734"></a>01734           p[j] += wy[getIdx(i,pointr,n)] * neggi;
<a name="l01735"></a>01735           p[col + j] += ws[getIdx(i,pointr,n)] * neggi;
<a name="l01736"></a>01736           pointr = pointr%m + 1;
<a name="l01737"></a>01737         }
<a name="l01738"></a>01738         <span class="keywordflow">if</span> (nbd[i] &lt;= 2 &amp;&amp; nbd[i] != 0 &amp;&amp; neggi &lt; zero)
<a name="l01739"></a>01739         {
<a name="l01740"></a>01740           <span class="comment">//x[i] + d[i] is bounded; compute t[i].</span>
<a name="l01741"></a>01741           nbreak += 1;
<a name="l01742"></a>01742           iorder[nbreak] = i;
<a name="l01743"></a>01743           t[nbreak] = tl/(-neggi);
<a name="l01744"></a>01744           <span class="keywordflow">if</span> (nbreak == 1 || t[nbreak] &lt; bkmin)
<a name="l01745"></a>01745           {
<a name="l01746"></a>01746             bkmin = t[nbreak];
<a name="l01747"></a>01747             ibkmin = nbreak;
<a name="l01748"></a>01748           }
<a name="l01749"></a>01749         }
<a name="l01750"></a>01750         <span class="keywordflow">else</span>
<a name="l01751"></a>01751         <span class="keywordflow">if</span> (nbd[i] &gt;= 2 &amp;&amp; neggi &gt; zero)
<a name="l01752"></a>01752         {
<a name="l01753"></a>01753           <span class="comment">//x(i) + d(i) is bounded; compute t(i).</span>
<a name="l01754"></a>01754           nbreak += 1;
<a name="l01755"></a>01755           iorder[nbreak] = i;
<a name="l01756"></a>01756           t[nbreak] = tu/neggi;
<a name="l01757"></a>01757           <span class="keywordflow">if</span> (nbreak == 1 || t[nbreak] &lt; bkmin)
<a name="l01758"></a>01758           {
<a name="l01759"></a>01759             bkmin = t[nbreak];
<a name="l01760"></a>01760             ibkmin = nbreak;
<a name="l01761"></a>01761           }          
<a name="l01762"></a>01762         }
<a name="l01763"></a>01763         <span class="keywordflow">else</span>
<a name="l01764"></a>01764         {
<a name="l01765"></a>01765           <span class="comment">//x(i) + d(i) is not bounded.</span>
<a name="l01766"></a>01766           nfree -= 1;
<a name="l01767"></a>01767           iorder[nfree] = i;
<a name="l01768"></a>01768           <span class="keywordflow">if</span> (fabs(neggi) &gt; zero) bnded = <span class="keyword">false</span>;
<a name="l01769"></a>01769         }
<a name="l01770"></a>01770       }
<a name="l01771"></a>01771     } <span class="comment">//for (int i = 1; i &lt;= n; i++)      </span>
<a name="l01772"></a>01772 
<a name="l01773"></a>01773  
<a name="l01774"></a>01774     <span class="comment">//The indices of the nonzero components of d are now stored</span>
<a name="l01775"></a>01775     <span class="comment">//in iorder(1),...,iorder(nbreak) and iorder(nfree),...,iorder(n).</span>
<a name="l01776"></a>01776     <span class="comment">//The smallest of the nbreak breakpoints is in t(ibkmin)=bkmin.</span>
<a name="l01777"></a>01777  
<a name="l01778"></a>01778     <span class="keywordflow">if</span> (theta != one)
<a name="l01779"></a>01779     {
<a name="l01780"></a>01780       <span class="comment">//complete the initialization of p for theta not= one.</span>
<a name="l01781"></a>01781       dscal(col,theta,&amp;(p[col+1-1]),1);
<a name="l01782"></a>01782     }
<a name="l01783"></a>01783  
<a name="l01784"></a>01784     <span class="comment">//Initialize GCP xcp = x.</span>
<a name="l01785"></a>01785 
<a name="l01786"></a>01786     dcopy(n,x,1,xcp,1);
<a name="l01787"></a>01787 
<a name="l01788"></a>01788     <span class="keywordflow">if</span> (nbreak == 0 &amp;&amp; nfree == n + 1)
<a name="l01789"></a>01789     {
<a name="l01790"></a>01790       <span class="comment">//is a zero vector, return with the initial xcp as GCP.</span>
<a name="l01791"></a>01791       <span class="keywordflow">if</span> (iprint &gt; 100) 
<a name="l01792"></a>01792       {
<a name="l01793"></a>01793         cout &lt;&lt; <span class="stringliteral">"Cauchy X = "</span>;
<a name="l01794"></a>01794         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l01795"></a>01795           cout &lt;&lt; xcp[i] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l01796"></a>01796         cout &lt;&lt; endl;
<a name="l01797"></a>01797       }
<a name="l01798"></a>01798       <span class="keywordflow">return</span>;
<a name="l01799"></a>01799     }    
<a name="l01800"></a>01800     
<a name="l01801"></a>01801     <span class="comment">//Initialize c = W'(xcp - x) = 0.</span>
<a name="l01802"></a>01802     
<a name="l01803"></a>01803     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= col2; j++)
<a name="l01804"></a>01804       c[j] = zero;
<a name="l01805"></a>01805     
<a name="l01806"></a>01806     <span class="comment">//Initialize derivative f2.</span>
<a name="l01807"></a>01807     
<a name="l01808"></a>01808     f2 = -theta*f1;
<a name="l01809"></a>01809     f2_org = f2;
<a name="l01810"></a>01810     <span class="keywordflow">if</span> (col &gt; 0) 
<a name="l01811"></a>01811     {
<a name="l01812"></a>01812       bmv(m,sy,wt,col,p,v,info);
<a name="l01813"></a>01813       <span class="keywordflow">if</span> (info != 0) <span class="keywordflow">return</span>;
<a name="l01814"></a>01814       f2 -= ddot(col2,v,1,p,1);
<a name="l01815"></a>01815     }
<a name="l01816"></a>01816     dtm = -f1/f2;
<a name="l01817"></a>01817     tsum = zero;
<a name="l01818"></a>01818     nint = 1;
<a name="l01819"></a>01819     <span class="keywordflow">if</span> (iprint &gt;= 99)
<a name="l01820"></a>01820       cout &lt;&lt; <span class="stringliteral">"There are "</span> &lt;&lt; nbreak &lt;&lt; <span class="stringliteral">" breakpoints"</span> &lt;&lt; endl;
<a name="l01821"></a>01821     
<a name="l01822"></a>01822     <span class="comment">//If there are no breakpoints, locate the GCP and return. </span>
<a name="l01823"></a>01823     
<a name="l01824"></a>01824     <span class="keywordflow">if</span> (nbreak == 0) <span class="keywordflow">goto</span> goto888;
<a name="l01825"></a>01825     
<a name="l01826"></a>01826     nleft = nbreak;
<a name="l01827"></a>01827     iter = 1;
<a name="l01828"></a>01828     
<a name="l01829"></a>01829     tj = zero;
<a name="l01830"></a>01830     
<a name="l01831"></a>01831     <span class="comment">//------------------- the beginning of the loop -------------------------</span>
<a name="l01832"></a>01832     
<a name="l01833"></a>01833   goto777:
<a name="l01834"></a>01834     
<a name="l01835"></a>01835     <span class="comment">//Find the next smallest breakpoint;</span>
<a name="l01836"></a>01836     <span class="comment">//compute dt = t(nleft) - t(nleft + 1).</span>
<a name="l01837"></a>01837     
<a name="l01838"></a>01838     tj0 = tj;
<a name="l01839"></a>01839     <span class="keywordflow">if</span> (iter == 1) 
<a name="l01840"></a>01840     {
<a name="l01841"></a>01841       <span class="comment">//Since we already have the smallest breakpoint we need not do</span>
<a name="l01842"></a>01842       <span class="comment">//heapsort yet. Often only one breakpoint is used and the</span>
<a name="l01843"></a>01843       <span class="comment">//cost of heapsort is avoided.</span>
<a name="l01844"></a>01844       tj = bkmin;
<a name="l01845"></a>01845       ibp = iorder[ibkmin];
<a name="l01846"></a>01846     }
<a name="l01847"></a>01847     <span class="keywordflow">else</span>
<a name="l01848"></a>01848     {
<a name="l01849"></a>01849       <span class="keywordflow">if</span> (iter == 2)
<a name="l01850"></a>01850       {
<a name="l01851"></a>01851         <span class="comment">//Replace the already used smallest breakpoint with the</span>
<a name="l01852"></a>01852         <span class="comment">//breakpoint numbered nbreak &gt; nlast, before heapsort call.</span>
<a name="l01853"></a>01853         <span class="keywordflow">if</span> (ibkmin != nbreak)
<a name="l01854"></a>01854         {
<a name="l01855"></a>01855           t[ibkmin] = t[nbreak];
<a name="l01856"></a>01856           iorder[ibkmin] = iorder[nbreak];
<a name="l01857"></a>01857         }
<a name="l01858"></a>01858         <span class="comment">//Update heap structure of breakpoints</span>
<a name="l01859"></a>01859         <span class="comment">//(if iter=2, initialize heap).</span>
<a name="l01860"></a>01860       }
<a name="l01861"></a>01861       
<a name="l01862"></a>01862       hpsolb(nleft,t,iorder,iter-2);
<a name="l01863"></a>01863       tj = t[nleft];
<a name="l01864"></a>01864      ibp = iorder[nleft];    
<a name="l01865"></a>01865     }    
<a name="l01866"></a>01866 
<a name="l01867"></a>01867     dt = tj - tj0;
<a name="l01868"></a>01868     
<a name="l01869"></a>01869     <span class="keywordflow">if</span> (dt != zero &amp;&amp; iprint &gt;= 100)
<a name="l01870"></a>01870     {
<a name="l01871"></a>01871       cout &lt;&lt; <span class="stringliteral">"Piece    "</span> &lt;&lt; nint &lt;&lt; <span class="stringliteral">" --f1, f2 at start point "</span> 
<a name="l01872"></a>01872            &lt;&lt; f1 &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; f2 &lt;&lt; endl;
<a name="l01873"></a>01873       cout &lt;&lt; <span class="stringliteral">"Distance to the next break point = "</span> &lt;&lt; dt &lt;&lt; endl;
<a name="l01874"></a>01874       cout &lt;&lt; <span class="stringliteral">"Distance to the stationary point = "</span> &lt;&lt; dtm &lt;&lt; endl;
<a name="l01875"></a>01875     }
<a name="l01876"></a>01876     
<a name="l01877"></a>01877     <span class="comment">//If a minimizer is within this interval, locate the GCP and return. </span>
<a name="l01878"></a>01878     
<a name="l01879"></a>01879     <span class="keywordflow">if</span> (dtm &lt; dt) <span class="keywordflow">goto</span> goto888;
<a name="l01880"></a>01880     
<a name="l01881"></a>01881     <span class="comment">//Otherwise fix one variable and</span>
<a name="l01882"></a>01882     <span class="comment">//reset the corresponding component of d to zero.</span>
<a name="l01883"></a>01883     
<a name="l01884"></a>01884     tsum += dt;
<a name="l01885"></a>01885     nleft -= 1;
<a name="l01886"></a>01886     iter += 1;
<a name="l01887"></a>01887     dibp = d[ibp];
<a name="l01888"></a>01888     d[ibp] = zero;
<a name="l01889"></a>01889     <span class="keywordflow">if</span> (dibp &gt; zero) 
<a name="l01890"></a>01890     {
<a name="l01891"></a>01891       zibp = u[ibp] - x[ibp];
<a name="l01892"></a>01892       xcp[ibp] = u[ibp];
<a name="l01893"></a>01893       iwhere[ibp] = 2;
<a name="l01894"></a>01894     }
<a name="l01895"></a>01895     <span class="keywordflow">else</span>
<a name="l01896"></a>01896     {
<a name="l01897"></a>01897      zibp = l[ibp] - x[ibp];
<a name="l01898"></a>01898      xcp[ibp] = l[ibp];
<a name="l01899"></a>01899      iwhere[ibp] = 1;
<a name="l01900"></a>01900     }
<a name="l01901"></a>01901     <span class="keywordflow">if</span> (iprint &gt;= 100) cout &lt;&lt; <span class="stringliteral">"Variable  "</span> &lt;&lt; ibp &lt;&lt; <span class="stringliteral">" is fixed."</span> &lt;&lt; endl;
<a name="l01902"></a>01902     <span class="keywordflow">if</span> (nleft == 0 &amp;&amp; nbreak == n) 
<a name="l01903"></a>01903     {
<a name="l01904"></a>01904       <span class="comment">//all n variables are fixed, return with xcp as GCP.</span>
<a name="l01905"></a>01905       dtm = dt;
<a name="l01906"></a>01906       <span class="keywordflow">goto</span> goto999;
<a name="l01907"></a>01907     }
<a name="l01908"></a>01908     
<a name="l01909"></a>01909     <span class="comment">//Update the derivative information.</span>
<a name="l01910"></a>01910     
<a name="l01911"></a>01911     nint += 1;
<a name="l01912"></a>01912     dibp2 = dibp*dibp;
<a name="l01913"></a>01913     
<a name="l01914"></a>01914    <span class="comment">//Update f1 and f2.</span>
<a name="l01915"></a>01915     
<a name="l01916"></a>01916    <span class="comment">//temporarily set f1 and f2 for col=0.</span>
<a name="l01917"></a>01917     f1 += dt*f2 + dibp2 - theta*dibp*zibp;
<a name="l01918"></a>01918     f2 -= theta*dibp2;
<a name="l01919"></a>01919     
<a name="l01920"></a>01920     <span class="keywordflow">if</span> (col &gt; 0)
<a name="l01921"></a>01921     {
<a name="l01922"></a>01922       <span class="comment">//update c = c + dt*p.</span>
<a name="l01923"></a>01923      daxpy(col2,dt,p,1,c,1);
<a name="l01924"></a>01924      
<a name="l01925"></a>01925      <span class="comment">//choose wbp,</span>
<a name="l01926"></a>01926      <span class="comment">//the row of W corresponding to the breakpoint encountered.</span>
<a name="l01927"></a>01927      pointr = head;
<a name="l01928"></a>01928      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= col; j++)
<a name="l01929"></a>01929      {
<a name="l01930"></a>01930        wbp[j] = wy[getIdx(ibp,pointr,n)];
<a name="l01931"></a>01931        wbp[col + j] = theta*ws[getIdx(ibp,pointr,n)];
<a name="l01932"></a>01932        pointr = pointr%m + 1;
<a name="l01933"></a>01933      }
<a name="l01934"></a>01934      <span class="comment">//compute (wbp)Mc, (wbp)Mp, and (wbp)M(wbp)'.</span>
<a name="l01935"></a>01935      bmv(m,sy,wt,col,wbp,v,info);
<a name="l01936"></a>01936      <span class="keywordflow">if</span> (info != 0) <span class="keywordflow">return</span>;
<a name="l01937"></a>01937      wmc = ddot(col2,c,1,v,1);
<a name="l01938"></a>01938      wmp = ddot(col2,p,1,v,1); 
<a name="l01939"></a>01939      wmw = ddot(col2,wbp,1,v,1);
<a name="l01940"></a>01940      
<a name="l01941"></a>01941      <span class="comment">//update p = p - dibp*wbp. </span>
<a name="l01942"></a>01942      daxpy(col2,-dibp,wbp,1,p,1);
<a name="l01943"></a>01943      
<a name="l01944"></a>01944      <span class="comment">//complete updating f1 and f2 while col &gt; 0.</span>
<a name="l01945"></a>01945      f1 += dibp*wmc;
<a name="l01946"></a>01946      f2 += 2.0*dibp*wmp - dibp2*wmw;
<a name="l01947"></a>01947     }
<a name="l01948"></a>01948     
<a name="l01949"></a>01949     f2 = max(epsmch*f2_org,f2);
<a name="l01950"></a>01950     <span class="keywordflow">if</span> (nleft &gt; 0)
<a name="l01951"></a>01951     {
<a name="l01952"></a>01952      dtm = -f1/f2;
<a name="l01953"></a>01953      <span class="keywordflow">goto</span> goto777;
<a name="l01954"></a>01954      <span class="comment">//to repeat the loop for unsearched intervals. </span>
<a name="l01955"></a>01955     }
<a name="l01956"></a>01956     <span class="keywordflow">else</span>
<a name="l01957"></a>01957     <span class="keywordflow">if</span>(bnded)
<a name="l01958"></a>01958     {
<a name="l01959"></a>01959       f1 = zero;
<a name="l01960"></a>01960       f2 = zero;
<a name="l01961"></a>01961       dtm = zero;
<a name="l01962"></a>01962     }
<a name="l01963"></a>01963     <span class="keywordflow">else</span>
<a name="l01964"></a>01964       dtm = -f1/f2;
<a name="l01965"></a>01965     
<a name="l01966"></a>01966     <span class="comment">//------------------- the end of the loop -------------------------------</span>
<a name="l01967"></a>01967     
<a name="l01968"></a>01968   goto888:
<a name="l01969"></a>01969     <span class="keywordflow">if</span> (iprint &gt;= 99)
<a name="l01970"></a>01970     {
<a name="l01971"></a>01971       cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">"GCP found in this segment"</span> &lt;&lt; endl
<a name="l01972"></a>01972            &lt;&lt; <span class="stringliteral">"Piece    "</span> &lt;&lt; nint &lt;&lt; <span class="stringliteral">" --f1, f2 at start point "</span> 
<a name="l01973"></a>01973            &lt;&lt; f1 &lt;&lt; <span class="stringliteral">","</span>  &lt;&lt; f2 &lt;&lt; endl
<a name="l01974"></a>01974            &lt;&lt; <span class="stringliteral">"Distance to the stationary point = "</span> &lt;&lt; dtm &lt;&lt; endl;
<a name="l01975"></a>01975     }
<a name="l01976"></a>01976     
<a name="l01977"></a>01977     <span class="keywordflow">if</span> (dtm &lt;= zero) dtm = zero;
<a name="l01978"></a>01978     tsum += dtm;
<a name="l01979"></a>01979     
<a name="l01980"></a>01980     <span class="comment">//Move free variables (i.e., the ones w/o breakpoints) and </span>
<a name="l01981"></a>01981     <span class="comment">//the variables whose breakpoints haven't been reached.</span>
<a name="l01982"></a>01982     
<a name="l01983"></a>01983     daxpy(n,tsum,d,1,xcp,1);
<a name="l01984"></a>01984     
<a name="l01985"></a>01985   goto999:
<a name="l01986"></a>01986     
<a name="l01987"></a>01987     <span class="comment">//Update c = c + dtm*p = W'(x^c - x) </span>
<a name="l01988"></a>01988     <span class="comment">//which will be used in computing r = Z'(B(x^c - x) + g).</span>
<a name="l01989"></a>01989    
<a name="l01990"></a>01990     <span class="keywordflow">if</span> (col &gt; 0) daxpy(col2,dtm,p,1,c,1);
<a name="l01991"></a>01991     <span class="keywordflow">if</span> (iprint &gt; 100)
<a name="l01992"></a>01992     {
<a name="l01993"></a>01993       cout&lt;&lt; <span class="stringliteral">"Cauchy X = "</span>;
<a name="l01994"></a>01994       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;=n; i++)
<a name="l01995"></a>01995         cout &lt;&lt; xcp[i] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l01996"></a>01996       cout &lt;&lt; endl;
<a name="l01997"></a>01997     }
<a name="l01998"></a>01998     <span class="keywordflow">if</span> (iprint &gt;= 99) 
<a name="l01999"></a>01999       cout &lt;&lt; <span class="stringliteral">"---------------- exit CAUCHY----------------------"</span> &lt;&lt; endl;
<a name="l02000"></a>02000   }<span class="comment">//cauchy()</span>
<a name="l02001"></a>02001 
<a name="l02002"></a>02002 
<a name="l02003"></a>02003 <span class="comment">//   ************</span>
<a name="l02004"></a>02004 <span class="comment">//</span>
<a name="l02005"></a>02005 <span class="comment">//   Subroutine cmprlb </span>
<a name="l02006"></a>02006 <span class="comment">//</span>
<a name="l02007"></a>02007 <span class="comment">//     This subroutine computes r=-Z'B(xcp-xk)-Z'g by using </span>
<a name="l02008"></a>02008 <span class="comment">//       wa(2m+1)=W'(xcp-x) from subroutine cauchy.</span>
<a name="l02009"></a>02009 <span class="comment">//</span>
<a name="l02010"></a>02010 <span class="comment">//   Subprograms called:</span>
<a name="l02011"></a>02011 <span class="comment">//</span>
<a name="l02012"></a>02012 <span class="comment">//     L-BFGS-B Library ... bmv.</span>
<a name="l02013"></a>02013 <span class="comment">//</span>
<a name="l02014"></a>02014 <span class="comment">//</span>
<a name="l02015"></a>02015 <span class="comment">//                         *  *  *</span>
<a name="l02016"></a>02016 <span class="comment">//</span>
<a name="l02017"></a>02017 <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02018"></a>02018 <span class="comment">//   Optimization Technology Center.</span>
<a name="l02019"></a>02019 <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02020"></a>02020 <span class="comment">//   Written by</span>
<a name="l02021"></a>02021 <span class="comment">//                      Ciyou Zhu</span>
<a name="l02022"></a>02022 <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02023"></a>02023 <span class="comment">//</span>
<a name="l02024"></a>02024 <span class="comment">//</span>
<a name="l02025"></a>02025 <span class="comment">//   ************</span>
<a name="l02026"></a>02026     <span class="comment">//function</span>
<a name="l02027"></a>02027   <span class="keywordtype">void</span> cmprlb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, 
<a name="l02028"></a>02028               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; g, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ws, 
<a name="l02029"></a>02029               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wy, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sy, 
<a name="l02030"></a>02030               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wt, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; z, 
<a name="l02031"></a>02031               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; r, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wa, 
<a name="l02032"></a>02032               <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; index, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; theta, 
<a name="l02033"></a>02033               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; col, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; head, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nfree, 
<a name="l02034"></a>02034               <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; cnstnd, <span class="keywordtype">int</span>&amp; info)
<a name="l02035"></a>02035   {
<a name="l02036"></a>02036     <span class="comment">//int i,j;</span>
<a name="l02037"></a>02037     <span class="keywordtype">int</span> k,pointr,idx;
<a name="l02038"></a>02038     <span class="keywordtype">double</span> a1,a2;
<a name="l02039"></a>02039 
<a name="l02040"></a>02040     <span class="keywordflow">if</span> (!cnstnd &amp;&amp; col &gt; 0)
<a name="l02041"></a>02041     {
<a name="l02042"></a>02042       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l02043"></a>02043         r[i] = -g[i];
<a name="l02044"></a>02044     }
<a name="l02045"></a>02045     <span class="keywordflow">else</span>
<a name="l02046"></a>02046     {
<a name="l02047"></a>02047       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nfree; i++)
<a name="l02048"></a>02048       {
<a name="l02049"></a>02049         k = index[i];
<a name="l02050"></a>02050         r[i] = -theta*(z[k] - x[k]) - g[k];
<a name="l02051"></a>02051       }
<a name="l02052"></a>02052       bmv(m,sy,wt,col,&amp;(wa[2*m+1-1]),&amp;(wa[1-1]),info);
<a name="l02053"></a>02053       <span class="keywordflow">if</span> (info != 0)
<a name="l02054"></a>02054       {
<a name="l02055"></a>02055         info = -8;
<a name="l02056"></a>02056         <span class="keywordflow">return</span>;
<a name="l02057"></a>02057       }
<a name="l02058"></a>02058       pointr = head;
<a name="l02059"></a>02059       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= col; j++)
<a name="l02060"></a>02060       {
<a name="l02061"></a>02061         a1 = wa[j];
<a name="l02062"></a>02062         a2 = theta*wa[col + j];
<a name="l02063"></a>02063         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nfree; i++)
<a name="l02064"></a>02064         {
<a name="l02065"></a>02065           k = index[i];
<a name="l02066"></a>02066           idx = getIdx(k,pointr,n);
<a name="l02067"></a>02067           r[i] += wy[idx]*a1 + ws[idx]*a2;
<a name="l02068"></a>02068         }
<a name="l02069"></a>02069             
<a name="l02070"></a>02070         pointr = pointr%m + 1;
<a name="l02071"></a>02071       }
<a name="l02072"></a>02072     }
<a name="l02073"></a>02073   }<span class="comment">//cmprlb()</span>
<a name="l02074"></a>02074 
<a name="l02075"></a>02075 
<a name="l02076"></a>02076   <span class="comment">//   ************</span>
<a name="l02077"></a>02077   <span class="comment">//</span>
<a name="l02078"></a>02078   <span class="comment">//   Subroutine errclb</span>
<a name="l02079"></a>02079   <span class="comment">//</span>
<a name="l02080"></a>02080   <span class="comment">//   This subroutine checks the validity of the input data.</span>
<a name="l02081"></a>02081   <span class="comment">//</span>
<a name="l02082"></a>02082   <span class="comment">//</span>
<a name="l02083"></a>02083   <span class="comment">//                         *  *  *</span>
<a name="l02084"></a>02084   <span class="comment">//</span>
<a name="l02085"></a>02085   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02086"></a>02086   <span class="comment">//   Optimization Technology Center.</span>
<a name="l02087"></a>02087   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02088"></a>02088   <span class="comment">//   Written by</span>
<a name="l02089"></a>02089   <span class="comment">//                      Ciyou Zhu</span>
<a name="l02090"></a>02090   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02091"></a>02091   <span class="comment">//</span>
<a name="l02092"></a>02092   <span class="comment">//</span>
<a name="l02093"></a>02093   <span class="comment">//   ************</span>
<a name="l02094"></a>02094     <span class="comment">//function</span>
<a name="l02095"></a>02095   <span class="keywordtype">void</span> errclb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; factr, 
<a name="l02096"></a>02096               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, 
<a name="l02097"></a>02097               <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; nbd, <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; task, <span class="keywordtype">int</span>&amp; info, 
<a name="l02098"></a>02098               <span class="keywordtype">int</span>&amp; k)
<a name="l02099"></a>02099   {
<a name="l02100"></a>02100     <span class="comment">//int i;</span>
<a name="l02101"></a>02101     <span class="comment">//double one=1.0;</span>
<a name="l02102"></a>02102     <span class="keywordtype">double</span> zero=0.0;
<a name="l02103"></a>02103 
<a name="l02104"></a>02104     <span class="comment">//Check the input arguments for errors.</span>
<a name="l02105"></a>02105     
<a name="l02106"></a>02106     <span class="keywordflow">if</span> (n &lt;= 0) strcpy(task,<span class="stringliteral">"ERROR: N &lt;= 0"</span>);
<a name="l02107"></a>02107     <span class="keywordflow">if</span> (m &lt;= 0) strcpy(task,<span class="stringliteral">"ERROR: M &lt;= 0"</span>);
<a name="l02108"></a>02108     <span class="keywordflow">if</span> (factr &lt; zero) strcpy(task,<span class="stringliteral">"ERROR: FACTR &lt; 0"</span>);
<a name="l02109"></a>02109 
<a name="l02110"></a>02110     <span class="comment">//Check the validity of the arrays nbd[i], u[i], and l[i].</span>
<a name="l02111"></a>02111     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l02112"></a>02112     {
<a name="l02113"></a>02113       <span class="keywordflow">if</span> (nbd[i] &lt; 0 || nbd[i] &gt; 3)
<a name="l02114"></a>02114       {
<a name="l02115"></a>02115         <span class="comment">//return</span>
<a name="l02116"></a>02116         strcpy(task,<span class="stringliteral">"ERROR: INVALID NBD"</span>);
<a name="l02117"></a>02117         info = -6;
<a name="l02118"></a>02118         k = i;
<a name="l02119"></a>02119       }
<a name="l02120"></a>02120       <span class="keywordflow">if</span> (nbd[i] == 2)
<a name="l02121"></a>02121       {
<a name="l02122"></a>02122         <span class="keywordflow">if</span> (l[i] &gt; u[i])
<a name="l02123"></a>02123         {
<a name="l02124"></a>02124           <span class="comment">//return</span>
<a name="l02125"></a>02125           strcpy(task, <span class="stringliteral">"ERROR: NO FEASIBLE SOLUTION"</span>);
<a name="l02126"></a>02126           info = -7;
<a name="l02127"></a>02127           k = i;
<a name="l02128"></a>02128         }
<a name="l02129"></a>02129       }
<a name="l02130"></a>02130     }
<a name="l02131"></a>02131   }<span class="comment">//errclb</span>
<a name="l02132"></a>02132 
<a name="l02133"></a>02133 
<a name="l02134"></a>02134   <span class="comment">//   ************</span>
<a name="l02135"></a>02135   <span class="comment">//</span>
<a name="l02136"></a>02136   <span class="comment">//   Subroutine formk </span>
<a name="l02137"></a>02137   <span class="comment">//</span>
<a name="l02138"></a>02138   <span class="comment">//   This subroutine forms  the LEL^T factorization of the indefinite</span>
<a name="l02139"></a>02139   <span class="comment">//</span>
<a name="l02140"></a>02140   <span class="comment">//     matrix    K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]</span>
<a name="l02141"></a>02141   <span class="comment">//                   [L_a -R_z           theta*S'AA'S ]</span>
<a name="l02142"></a>02142   <span class="comment">//                                                  where E = [-I  0]</span>
<a name="l02143"></a>02143   <span class="comment">//                                                            [ 0  I]</span>
<a name="l02144"></a>02144   <span class="comment">//   The matrix K can be shown to be equal to the matrix M^[-1]N</span>
<a name="l02145"></a>02145   <span class="comment">//     occurring in section 5.1 of [1], as well as to the matrix</span>
<a name="l02146"></a>02146   <span class="comment">//     Mbar^[-1] Nbar in section 5.3.</span>
<a name="l02147"></a>02147   <span class="comment">//</span>
<a name="l02148"></a>02148   <span class="comment">//   n is an integer variable.</span>
<a name="l02149"></a>02149   <span class="comment">//     On entry n is the dimension of the problem.</span>
<a name="l02150"></a>02150   <span class="comment">//     On exit n is unchanged.</span>
<a name="l02151"></a>02151   <span class="comment">//</span>
<a name="l02152"></a>02152   <span class="comment">//   nsub is an integer variable</span>
<a name="l02153"></a>02153   <span class="comment">//     On entry nsub is the number of subspace variables in free set.</span>
<a name="l02154"></a>02154   <span class="comment">//     On exit nsub is not changed.</span>
<a name="l02155"></a>02155   <span class="comment">//</span>
<a name="l02156"></a>02156   <span class="comment">//   ind is an integer array of dimension nsub.</span>
<a name="l02157"></a>02157   <span class="comment">//     On entry ind specifies the indices of subspace variables.</span>
<a name="l02158"></a>02158   <span class="comment">//     On exit ind is unchanged. </span>
<a name="l02159"></a>02159   <span class="comment">//</span>
<a name="l02160"></a>02160   <span class="comment">//   nenter is an integer variable.</span>
<a name="l02161"></a>02161   <span class="comment">//     On entry nenter is the number of variables entering the </span>
<a name="l02162"></a>02162   <span class="comment">//       free set.</span>
<a name="l02163"></a>02163   <span class="comment">//     On exit nenter is unchanged. </span>
<a name="l02164"></a>02164   <span class="comment">//</span>
<a name="l02165"></a>02165   <span class="comment">//   ileave is an integer variable.</span>
<a name="l02166"></a>02166   <span class="comment">//     On entry indx2(ileave),...,indx2(n) are the variables leaving</span>
<a name="l02167"></a>02167   <span class="comment">//       the free set.</span>
<a name="l02168"></a>02168   <span class="comment">//     On exit ileave is unchanged. </span>
<a name="l02169"></a>02169   <span class="comment">//</span>
<a name="l02170"></a>02170   <span class="comment">//   indx2 is an integer array of dimension n.</span>
<a name="l02171"></a>02171   <span class="comment">//     On entry indx2(1),...,indx2(nenter) are the variables entering</span>
<a name="l02172"></a>02172   <span class="comment">//       the free set, while indx2(ileave),...,indx2(n) are the</span>
<a name="l02173"></a>02173   <span class="comment">//       variables leaving the free set.</span>
<a name="l02174"></a>02174   <span class="comment">//     On exit indx2 is unchanged. </span>
<a name="l02175"></a>02175   <span class="comment">//</span>
<a name="l02176"></a>02176   <span class="comment">//   iupdat is an integer variable.</span>
<a name="l02177"></a>02177   <span class="comment">//     On entry iupdat is the total number of BFGS updates made so far.</span>
<a name="l02178"></a>02178   <span class="comment">//     On exit iupdat is unchanged. </span>
<a name="l02179"></a>02179   <span class="comment">//</span>
<a name="l02180"></a>02180   <span class="comment">//   updatd is a logical variable.</span>
<a name="l02181"></a>02181   <span class="comment">//     On entry 'updatd' is true if the L-BFGS matrix is updatd.</span>
<a name="l02182"></a>02182   <span class="comment">//     On exit 'updatd' is unchanged. </span>
<a name="l02183"></a>02183   <span class="comment">//</span>
<a name="l02184"></a>02184   <span class="comment">//   wn is a double precision array of dimension 2m x 2m.</span>
<a name="l02185"></a>02185   <span class="comment">//     On entry wn is unspecified.</span>
<a name="l02186"></a>02186   <span class="comment">//     On exit the upper triangle of wn stores the LEL^T factorization</span>
<a name="l02187"></a>02187   <span class="comment">//       of the 2*col x 2*col indefinite matrix</span>
<a name="l02188"></a>02188   <span class="comment">//                   [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]</span>
<a name="l02189"></a>02189   <span class="comment">//                   [L_a -R_z           theta*S'AA'S ]</span>
<a name="l02190"></a>02190   <span class="comment">//</span>
<a name="l02191"></a>02191   <span class="comment">//   wn1 is a double precision array of dimension 2m x 2m.</span>
<a name="l02192"></a>02192   <span class="comment">//     On entry wn1 stores the lower triangular part of </span>
<a name="l02193"></a>02193   <span class="comment">//                   [Y' ZZ'Y   L_a'+R_z']</span>
<a name="l02194"></a>02194   <span class="comment">//                   [L_a+R_z   S'AA'S   ]</span>
<a name="l02195"></a>02195   <span class="comment">//       in the previous iteration.</span>
<a name="l02196"></a>02196   <span class="comment">//     On exit wn1 stores the corresponding updated matrices.</span>
<a name="l02197"></a>02197   <span class="comment">//     The purpose of wn1 is just to store these inner products</span>
<a name="l02198"></a>02198   <span class="comment">//     so they can be easily updated and inserted into wn.</span>
<a name="l02199"></a>02199   <span class="comment">//</span>
<a name="l02200"></a>02200   <span class="comment">//   m is an integer variable.</span>
<a name="l02201"></a>02201   <span class="comment">//     On entry m is the maximum number of variable metric corrections</span>
<a name="l02202"></a>02202   <span class="comment">//       used to define the limited memory matrix.</span>
<a name="l02203"></a>02203   <span class="comment">//     On exit m is unchanged.</span>
<a name="l02204"></a>02204   <span class="comment">//</span>
<a name="l02205"></a>02205   <span class="comment">//   ws, wy, sy, and wtyy are double precision arrays;</span>
<a name="l02206"></a>02206   <span class="comment">//   theta is a double precision variable;</span>
<a name="l02207"></a>02207   <span class="comment">//   col is an integer variable;</span>
<a name="l02208"></a>02208   <span class="comment">//   head is an integer variable.</span>
<a name="l02209"></a>02209   <span class="comment">//     On entry they store the information defining the</span>
<a name="l02210"></a>02210   <span class="comment">//                                        limited memory BFGS matrix:</span>
<a name="l02211"></a>02211   <span class="comment">//       ws(n,m) stores S, a set of s-vectors;</span>
<a name="l02212"></a>02212   <span class="comment">//       wy(n,m) stores Y, a set of y-vectors;</span>
<a name="l02213"></a>02213   <span class="comment">//       sy(m,m) stores S'Y;</span>
<a name="l02214"></a>02214   <span class="comment">//       wtyy(m,m) stores the Cholesky factorization</span>
<a name="l02215"></a>02215   <span class="comment">//                                 of (theta*S'S+LD^(-1)L')</span>
<a name="l02216"></a>02216   <span class="comment">//       theta is the scaling factor specifying B_0 = theta I;</span>
<a name="l02217"></a>02217   <span class="comment">//       col is the number of variable metric corrections stored;</span>
<a name="l02218"></a>02218   <span class="comment">//       head is the location of the 1st s- (or y-) vector in S (or Y).</span>
<a name="l02219"></a>02219   <span class="comment">//     On exit they are unchanged.</span>
<a name="l02220"></a>02220   <span class="comment">//</span>
<a name="l02221"></a>02221   <span class="comment">//   info is an integer variable.</span>
<a name="l02222"></a>02222   <span class="comment">//     On entry info is unspecified.</span>
<a name="l02223"></a>02223   <span class="comment">//     On exit info =  0 for normal return;</span>
<a name="l02224"></a>02224   <span class="comment">//                  = -1 when the 1st Cholesky factorization failed;</span>
<a name="l02225"></a>02225   <span class="comment">//                  = -2 when the 2st Cholesky factorization failed.</span>
<a name="l02226"></a>02226   <span class="comment">//</span>
<a name="l02227"></a>02227   <span class="comment">//   Subprograms called:</span>
<a name="l02228"></a>02228   <span class="comment">//</span>
<a name="l02229"></a>02229   <span class="comment">//     Linpack ... dcopy, dpofa, dtrsl.</span>
<a name="l02230"></a>02230   <span class="comment">//</span>
<a name="l02231"></a>02231   <span class="comment">//</span>
<a name="l02232"></a>02232   <span class="comment">//   References:</span>
<a name="l02233"></a>02233   <span class="comment">//     [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited</span>
<a name="l02234"></a>02234   <span class="comment">//     memory algorithm for bound constrained optimization'',</span>
<a name="l02235"></a>02235   <span class="comment">//     SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.</span>
<a name="l02236"></a>02236   <span class="comment">//</span>
<a name="l02237"></a>02237   <span class="comment">//     [2] C. Zhu, R.H. Byrd, P. Lu, J. Nocedal, ``L-BFGS-B: a</span>
<a name="l02238"></a>02238   <span class="comment">//     limited memory FORTRAN code for solving bound constrained</span>
<a name="l02239"></a>02239   <span class="comment">//     optimization problems'', Tech. Report, NAM-11, EECS Department,</span>
<a name="l02240"></a>02240   <span class="comment">//     Northwestern University, 1994.</span>
<a name="l02241"></a>02241   <span class="comment">//</span>
<a name="l02242"></a>02242   <span class="comment">//     (Postscript files of these papers are available via anonymous</span>
<a name="l02243"></a>02243   <span class="comment">//      ftp to eecs.nwu.edu in the directory pub/lbfgs/lbfgs_bcm.)</span>
<a name="l02244"></a>02244   <span class="comment">//</span>
<a name="l02245"></a>02245   <span class="comment">//                         *  *  *</span>
<a name="l02246"></a>02246   <span class="comment">//</span>
<a name="l02247"></a>02247   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02248"></a>02248   <span class="comment">//   Optimization Technology Center.</span>
<a name="l02249"></a>02249   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02250"></a>02250   <span class="comment">//   Written by</span>
<a name="l02251"></a>02251   <span class="comment">//                      Ciyou Zhu</span>
<a name="l02252"></a>02252   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02253"></a>02253   <span class="comment">//</span>
<a name="l02254"></a>02254   <span class="comment">//</span>
<a name="l02255"></a>02255   <span class="comment">//   ************</span>
<a name="l02256"></a>02256     <span class="comment">//function</span>
<a name="l02257"></a>02257   <span class="keywordtype">void</span> formk(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nsub, <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; ind, 
<a name="l02258"></a>02258              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nenter, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; ileave, 
<a name="l02259"></a>02259              <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; indx2, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iupdat, 
<a name="l02260"></a>02260              <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; updatd, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wn, 
<a name="l02261"></a>02261              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wn1, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, 
<a name="l02262"></a>02262              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ws, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wy, 
<a name="l02263"></a>02263              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sy, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; theta, 
<a name="l02264"></a>02264              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; col, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; head, <span class="keywordtype">int</span>&amp; info)
<a name="l02265"></a>02265   {
<a name="l02266"></a>02266     <span class="comment">//int i,k;</span>
<a name="l02267"></a>02267     <span class="keywordtype">int</span> m2,ipntr,jpntr,iy,is,jy,js,is1,js1,k1,
<a name="l02268"></a>02268         col2,pbegin,pend,dbegin,dend,upcl;
<a name="l02269"></a>02269     <span class="keywordtype">int</span> idx1, idx2;
<a name="l02270"></a>02270     <span class="keywordtype">double</span> temp1,temp2,temp3,temp4;
<a name="l02271"></a>02271     <span class="comment">//double one=1.0;</span>
<a name="l02272"></a>02272     <span class="keywordtype">double</span> zero=0.0;
<a name="l02273"></a>02273 
<a name="l02274"></a>02274     m2 = 2*m;
<a name="l02275"></a>02275 
<a name="l02276"></a>02276     <span class="comment">//Form the lower triangular part of</span>
<a name="l02277"></a>02277     <span class="comment">//WN1 = [Y' ZZ'Y   L_a'+R_z'] </span>
<a name="l02278"></a>02278     <span class="comment">//      [L_a+R_z   S'AA'S   ]</span>
<a name="l02279"></a>02279     <span class="comment">//where L_a is the strictly lower triangular part of S'AA'Y</span>
<a name="l02280"></a>02280     <span class="comment">//      R_z is the upper triangular part of S'ZZ'Y.</span>
<a name="l02281"></a>02281       
<a name="l02282"></a>02282     <span class="keywordflow">if</span> (updatd)
<a name="l02283"></a>02283     {
<a name="l02284"></a>02284       <span class="keywordflow">if</span> (iupdat &gt; m)
<a name="l02285"></a>02285       { 
<a name="l02286"></a>02286         <span class="comment">//shift old part of WN1.</span>
<a name="l02287"></a>02287         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jy = 1; jy &lt;= m-1; jy++)
<a name="l02288"></a>02288         { 
<a name="l02289"></a>02289           js = m + jy;
<a name="l02290"></a>02290           dcopy(m-jy,&amp;(wn1[getIdx(jy+1,jy+1,m2)-1]),1,
<a name="l02291"></a>02291                      &amp;(wn1[getIdx(jy,jy,m2)-1]),1);
<a name="l02292"></a>02292           dcopy(m-jy,&amp;(wn1[getIdx(js+1,js+1,m2)-1]),1,
<a name="l02293"></a>02293                      &amp;(wn1[getIdx(js,js,m2)-1]), 1);
<a name="l02294"></a>02294           dcopy(m-1, &amp;(wn1[getIdx(m+2,jy+1,m2)-1]), 1,
<a name="l02295"></a>02295                      &amp;(wn1[getIdx(m+1,jy,m2)-1]),1);
<a name="l02296"></a>02296         }
<a name="l02297"></a>02297       }
<a name="l02298"></a>02298 
<a name="l02299"></a>02299       <span class="comment">//put new rows in blocks (1,1), (2,1) and (2,2).</span>
<a name="l02300"></a>02300       pbegin = 1;
<a name="l02301"></a>02301       pend = nsub;
<a name="l02302"></a>02302       dbegin = nsub + 1;
<a name="l02303"></a>02303       dend = n;
<a name="l02304"></a>02304       iy = col;
<a name="l02305"></a>02305       is = m + col;
<a name="l02306"></a>02306       ipntr = head + col - 1;
<a name="l02307"></a>02307       <span class="keywordflow">if</span> (ipntr &gt; m) ipntr -= m ;
<a name="l02308"></a>02308       jpntr = head;
<a name="l02309"></a>02309   
<a name="l02310"></a>02310       <span class="keywordflow">for</span> (jy = 1; jy &lt;= col; jy++)
<a name="l02311"></a>02311       {
<a name="l02312"></a>02312         js = m + jy;
<a name="l02313"></a>02313         temp1 = zero;
<a name="l02314"></a>02314         temp2 = zero;
<a name="l02315"></a>02315         temp3 = zero;
<a name="l02316"></a>02316         <span class="comment">//compute element jy of row 'col' of Y'ZZ'Y</span>
<a name="l02317"></a>02317         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = pbegin; k &lt;= pend; k++)
<a name="l02318"></a>02318         {
<a name="l02319"></a>02319           k1 = ind[k];
<a name="l02320"></a>02320           temp1 += wy[getIdx(k1,ipntr,n)]*wy[getIdx(k1,jpntr,n)];
<a name="l02321"></a>02321         }
<a name="l02322"></a>02322         <span class="comment">//compute elements jy of row 'col' of L_a and S'AA'S</span>
<a name="l02323"></a>02323         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = dbegin; k &lt;= dend; k++)
<a name="l02324"></a>02324         {
<a name="l02325"></a>02325           k1 = ind[k];
<a name="l02326"></a>02326           idx1 = getIdx(k1,ipntr,n);
<a name="l02327"></a>02327           idx2 = getIdx(k1,jpntr,n);
<a name="l02328"></a>02328           temp2 += ws[idx1] * ws[idx2];
<a name="l02329"></a>02329           temp3 += ws[idx1] * wy[idx2];
<a name="l02330"></a>02330         }
<a name="l02331"></a>02331         wn1[getIdx(iy,jy,m2)] = temp1;
<a name="l02332"></a>02332         wn1[getIdx(is,js,m2)] = temp2;
<a name="l02333"></a>02333         wn1[getIdx(is,jy,m2)] = temp3;
<a name="l02334"></a>02334         jpntr = jpntr%m + 1;
<a name="l02335"></a>02335       }
<a name="l02336"></a>02336  
<a name="l02337"></a>02337       <span class="comment">//put new column in block (2,1).</span>
<a name="l02338"></a>02338       jy = col;
<a name="l02339"></a>02339       jpntr = head + col - 1;
<a name="l02340"></a>02340       <span class="keywordflow">if</span> (jpntr &gt; m) jpntr -= m;
<a name="l02341"></a>02341       ipntr = head;
<a name="l02342"></a>02342       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= col; i++)
<a name="l02343"></a>02343       {
<a name="l02344"></a>02344         is = m + i;
<a name="l02345"></a>02345         temp3 = zero;
<a name="l02346"></a>02346         <span class="comment">//compute element i of column 'col' of R_z</span>
<a name="l02347"></a>02347         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = pbegin; k &lt;= pend; k++)
<a name="l02348"></a>02348         {
<a name="l02349"></a>02349           k1 = ind[k];
<a name="l02350"></a>02350           temp3 += ws[getIdx(k1,ipntr,n)]*wy[getIdx(k1,jpntr,n)];
<a name="l02351"></a>02351         }
<a name="l02352"></a>02352         ipntr = ipntr%m + 1;
<a name="l02353"></a>02353         wn1[getIdx(is,jy,m2)] = temp3;
<a name="l02354"></a>02354       }
<a name="l02355"></a>02355       upcl = col - 1;
<a name="l02356"></a>02356     }
<a name="l02357"></a>02357     <span class="keywordflow">else</span>
<a name="l02358"></a>02358       upcl = col;
<a name="l02359"></a>02359 
<a name="l02360"></a>02360     <span class="comment">//modify the old parts in blocks (1,1) and (2,2) due to changes</span>
<a name="l02361"></a>02361     <span class="comment">//in the set of free variables.</span>
<a name="l02362"></a>02362     ipntr = head;
<a name="l02363"></a>02363     
<a name="l02364"></a>02364     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iy = 1; iy &lt;= upcl; iy++)
<a name="l02365"></a>02365     {
<a name="l02366"></a>02366       is = m + iy;
<a name="l02367"></a>02367       jpntr = head;
<a name="l02368"></a>02368 
<a name="l02369"></a>02369       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jy = 1; jy &lt;= iy; jy++)
<a name="l02370"></a>02370       {
<a name="l02371"></a>02371         js = m + jy;
<a name="l02372"></a>02372         temp1 = zero;
<a name="l02373"></a>02373         temp2 = zero;
<a name="l02374"></a>02374         temp3 = zero;
<a name="l02375"></a>02375         temp4 = zero;
<a name="l02376"></a>02376         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt;= nenter; k++)
<a name="l02377"></a>02377         {
<a name="l02378"></a>02378           k1 = indx2[k];
<a name="l02379"></a>02379           idx1 = getIdx(k1,ipntr,n);
<a name="l02380"></a>02380           idx2 = getIdx(k1,jpntr,n);
<a name="l02381"></a>02381           temp1 += wy[idx1]*wy[idx2];
<a name="l02382"></a>02382           temp2 += ws[idx1]*ws[idx2];
<a name="l02383"></a>02383         }
<a name="l02384"></a>02384         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = ileave; k &lt;= n; k++)
<a name="l02385"></a>02385         {
<a name="l02386"></a>02386           k1 = indx2[k];
<a name="l02387"></a>02387           idx1 = getIdx(k1,ipntr,n);
<a name="l02388"></a>02388           idx2 = getIdx(k1,jpntr,n);
<a name="l02389"></a>02389           temp3 += wy[idx1]*wy[idx2];
<a name="l02390"></a>02390           temp4 += ws[idx1]*ws[idx2];
<a name="l02391"></a>02391         }
<a name="l02392"></a>02392         wn1[getIdx(iy,jy,m2)] += temp1 - temp3;
<a name="l02393"></a>02393         wn1[getIdx(is,js,m2)] += temp4 - temp2;
<a name="l02394"></a>02394         jpntr = jpntr%m + 1;
<a name="l02395"></a>02395       }
<a name="l02396"></a>02396       ipntr = ipntr%m + 1;
<a name="l02397"></a>02397     } 
<a name="l02398"></a>02398     <span class="comment">//modify the old parts in block (2,1).</span>
<a name="l02399"></a>02399     ipntr = head;
<a name="l02400"></a>02400 
<a name="l02401"></a>02401     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> is = m+1; is &lt;= m + upcl; is++)
<a name="l02402"></a>02402     {
<a name="l02403"></a>02403       jpntr = head;
<a name="l02404"></a>02404       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jy = 1; jy &lt;= upcl; jy++)
<a name="l02405"></a>02405       {
<a name="l02406"></a>02406         temp1 = zero;
<a name="l02407"></a>02407         temp3 = zero;
<a name="l02408"></a>02408 
<a name="l02409"></a>02409         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt;= nenter; k++)
<a name="l02410"></a>02410         {
<a name="l02411"></a>02411           k1 = indx2[k];
<a name="l02412"></a>02412           temp1 += ws[getIdx(k1,ipntr,n)]*wy[getIdx(k1,jpntr,n)];
<a name="l02413"></a>02413         }
<a name="l02414"></a>02414         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = ileave; k &lt;= n; k++)
<a name="l02415"></a>02415         {
<a name="l02416"></a>02416           k1 = indx2[k];
<a name="l02417"></a>02417           temp3 += ws[getIdx(k1,ipntr,n)]*wy[getIdx(k1,jpntr,n)];
<a name="l02418"></a>02418         }
<a name="l02419"></a>02419         <span class="keywordflow">if</span> (is &lt;= jy + m)
<a name="l02420"></a>02420           wn1[getIdx(is,jy,m2)] += temp1 - temp3;
<a name="l02421"></a>02421         <span class="keywordflow">else</span>
<a name="l02422"></a>02422           wn1[getIdx(is,jy,m2)] += temp3 - temp1;
<a name="l02423"></a>02423             
<a name="l02424"></a>02424         jpntr = jpntr%m + 1;
<a name="l02425"></a>02425       }
<a name="l02426"></a>02426       ipntr = ipntr%m + 1;
<a name="l02427"></a>02427     } 
<a name="l02428"></a>02428     <span class="comment">//Form the upper triangle of WN = [D+Y' ZZ'Y/theta   -L_a'+R_z' ] </span>
<a name="l02429"></a>02429     <span class="comment">//                                [-L_a +R_z        S'AA'S*theta]</span>
<a name="l02430"></a>02430 
<a name="l02431"></a>02431     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iy = 1; iy &lt;= col; iy++)
<a name="l02432"></a>02432     {
<a name="l02433"></a>02433       is = col + iy;
<a name="l02434"></a>02434       is1 = m + iy;
<a name="l02435"></a>02435       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jy = 1; jy &lt;= iy; jy++)
<a name="l02436"></a>02436       {
<a name="l02437"></a>02437         js = col + jy;
<a name="l02438"></a>02438         js1 = m + jy;
<a name="l02439"></a>02439         wn[getIdx(jy,iy,m2)] = wn1[getIdx(iy,jy,m2)]/theta;
<a name="l02440"></a>02440         wn[getIdx(js,is,m2)] = wn1[getIdx(is1,js1,m2)]*theta;
<a name="l02441"></a>02441       }
<a name="l02442"></a>02442 
<a name="l02443"></a>02443       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jy = 1; jy &lt;= iy-1; jy++)
<a name="l02444"></a>02444         wn[getIdx(jy,is,m2)] = -wn1[getIdx(is1,jy,m2)];
<a name="l02445"></a>02445 
<a name="l02446"></a>02446       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jy = iy; jy &lt;= col; jy++)
<a name="l02447"></a>02447         wn[getIdx(jy,is,m2)] = wn1[getIdx(is1,jy,m2)];
<a name="l02448"></a>02448       wn[getIdx(iy,iy,m2)] += sy[getIdx(iy,iy,m)];
<a name="l02449"></a>02449     }
<a name="l02450"></a>02450 
<a name="l02451"></a>02451     <span class="comment">//Form the upper triangle of WN= [  LL'            L^-1(-L_a'+R_z')] </span>
<a name="l02452"></a>02452     <span class="comment">//                               [(-L_a +R_z)L'^-1   S'AA'S*theta  ]</span>
<a name="l02453"></a>02453 
<a name="l02454"></a>02454     <span class="comment">//first Cholesky factor (1,1) block of wn to get LL'</span>
<a name="l02455"></a>02455     <span class="comment">//with L' stored in the upper triangle of wn.</span>
<a name="l02456"></a>02456     dpofa(wn,m2,col,info);
<a name="l02457"></a>02457     <span class="keywordflow">if</span> (info != 0) 
<a name="l02458"></a>02458     {
<a name="l02459"></a>02459       info = -1;
<a name="l02460"></a>02460       <span class="keywordflow">return</span>;
<a name="l02461"></a>02461     }
<a name="l02462"></a>02462 
<a name="l02463"></a>02463     <span class="comment">//then form L^-1(-L_a'+R_z') in the (1,2) block.</span>
<a name="l02464"></a>02464     col2 = 2*col;
<a name="l02465"></a>02465     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> js = col+1; js &lt;= col2; js++)
<a name="l02466"></a>02466       dtrsl(wn,m2,col,&amp;(wn[getIdx(1,js,m2)-1]),11,info);
<a name="l02467"></a>02467 
<a name="l02468"></a>02468 
<a name="l02469"></a>02469 
<a name="l02470"></a>02470     <span class="comment">//Form S'AA'S*theta + (L^-1(-L_a'+R_z'))'L^-1(-L_a'+R_z') in the</span>
<a name="l02471"></a>02471     <span class="comment">//upper triangle of (2,2) block of wn.</span>
<a name="l02472"></a>02472     <span class="comment">//HH                      </span>
<a name="l02473"></a>02473     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> is = col+1; is &lt;= col2; is++)
<a name="l02474"></a>02474       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> js = is; js &lt;= col2; js++)
<a name="l02475"></a>02475         wn[getIdx(is,js,m2)] += ddot(col,&amp;(wn[getIdx(1,is,m2)-1]),1,
<a name="l02476"></a>02476                                          &amp;(wn[getIdx(1,js,m2)-1]),1);
<a name="l02477"></a>02477 
<a name="l02478"></a>02478     <span class="comment">//Cholesky factorization of (2,2) block of wn.</span>
<a name="l02479"></a>02479     dpofa(&amp;(wn[getIdx(col+1,col+1,m2)-1]),m2,col,info);
<a name="l02480"></a>02480 
<a name="l02481"></a>02481     <span class="keywordflow">if</span> (info != 0)
<a name="l02482"></a>02482     {
<a name="l02483"></a>02483       info = -2;
<a name="l02484"></a>02484       <span class="keywordflow">return</span>;
<a name="l02485"></a>02485     }
<a name="l02486"></a>02486   }<span class="comment">//formk()</span>
<a name="l02487"></a>02487 
<a name="l02488"></a>02488 
<a name="l02489"></a>02489   <span class="comment">//   ************</span>
<a name="l02490"></a>02490   <span class="comment">//</span>
<a name="l02491"></a>02491   <span class="comment">//   Subroutine formt</span>
<a name="l02492"></a>02492   <span class="comment">//</span>
<a name="l02493"></a>02493   <span class="comment">//     This subroutine forms the upper half of the pos. def. and symm.</span>
<a name="l02494"></a>02494   <span class="comment">//       T = theta*SS + L*D^(-1)*L', stores T in the upper triangle</span>
<a name="l02495"></a>02495   <span class="comment">//       of the array wt, and performs the Cholesky factorization of T</span>
<a name="l02496"></a>02496   <span class="comment">//       to produce J*J', with J' stored in the upper triangle of wt.</span>
<a name="l02497"></a>02497   <span class="comment">//</span>
<a name="l02498"></a>02498   <span class="comment">//   Subprograms called:</span>
<a name="l02499"></a>02499   <span class="comment">//</span>
<a name="l02500"></a>02500   <span class="comment">//     Linpack ... dpofa.</span>
<a name="l02501"></a>02501   <span class="comment">//</span>
<a name="l02502"></a>02502   <span class="comment">//</span>
<a name="l02503"></a>02503   <span class="comment">//                         *  *  *</span>
<a name="l02504"></a>02504   <span class="comment">//</span>
<a name="l02505"></a>02505   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02506"></a>02506   <span class="comment">//   Optimization Technology Center.</span>
<a name="l02507"></a>02507   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02508"></a>02508   <span class="comment">//   Written by</span>
<a name="l02509"></a>02509   <span class="comment">//                      Ciyou Zhu</span>
<a name="l02510"></a>02510   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02511"></a>02511   <span class="comment">//</span>
<a name="l02512"></a>02512   <span class="comment">//</span>
<a name="l02513"></a>02513   <span class="comment">//   ***********</span>
<a name="l02514"></a>02514     <span class="comment">//function</span>
<a name="l02515"></a>02515   <span class="keywordtype">void</span> formt(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wt, <span class="keywordtype">double</span>* <span class="keyword">const</span>&amp; sy,
<a name="l02516"></a>02516              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp;  ss, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; col, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; theta, 
<a name="l02517"></a>02517              <span class="keywordtype">int</span>&amp; info)
<a name="l02518"></a>02518   {
<a name="l02519"></a>02519     <span class="comment">//int i,j,k;</span>
<a name="l02520"></a>02520     <span class="keywordtype">int</span> k1, idx;
<a name="l02521"></a>02521     <span class="keywordtype">double</span> ddum;
<a name="l02522"></a>02522     <span class="keywordtype">double</span> zero=0.0;
<a name="l02523"></a>02523 
<a name="l02524"></a>02524     <span class="comment">//Form the upper half of  T = theta*SS + L*D^(-1)*L',</span>
<a name="l02525"></a>02525     <span class="comment">//store T in the upper triangle of the array wt.</span>
<a name="l02526"></a>02526     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= col; j++)
<a name="l02527"></a>02527     {
<a name="l02528"></a>02528       idx = getIdx(1,j,m);
<a name="l02529"></a>02529       wt[idx] = theta*ss[idx];
<a name="l02530"></a>02530     }
<a name="l02531"></a>02531 
<a name="l02532"></a>02532     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt;= col; i++) 
<a name="l02533"></a>02533       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i; j &lt;= col; j++) 
<a name="l02534"></a>02534       {
<a name="l02535"></a>02535         k1 = min(i,j) - 1;
<a name="l02536"></a>02536         ddum = zero;
<a name="l02537"></a>02537         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt;= k1; k++) 
<a name="l02538"></a>02538           ddum  += sy[getIdx(i,k,m)]*sy[getIdx(j,k,m)]/sy[getIdx(k,k,m)];
<a name="l02539"></a>02539         wt[getIdx(i,j,m)] = ddum + theta*ss[getIdx(i,j,m)];
<a name="l02540"></a>02540       }
<a name="l02541"></a>02541  
<a name="l02542"></a>02542     <span class="comment">//Cholesky factorize T to J*J' with </span>
<a name="l02543"></a>02543     <span class="comment">//J' stored in the upper triangle of wt.</span>
<a name="l02544"></a>02544  
<a name="l02545"></a>02545     dpofa(wt,m,col,info);
<a name="l02546"></a>02546     <span class="keywordflow">if</span> (info != 0) info = -3;
<a name="l02547"></a>02547   }<span class="comment">//formt()</span>
<a name="l02548"></a>02548 
<a name="l02549"></a>02549 
<a name="l02550"></a>02550   <span class="comment">//   ************</span>
<a name="l02551"></a>02551   <span class="comment">//</span>
<a name="l02552"></a>02552   <span class="comment">//   Subroutine freev </span>
<a name="l02553"></a>02553   <span class="comment">//</span>
<a name="l02554"></a>02554   <span class="comment">//   This subroutine counts the entering and leaving variables when</span>
<a name="l02555"></a>02555   <span class="comment">//     iter &gt; 0, and finds the index set of free and active variables</span>
<a name="l02556"></a>02556   <span class="comment">//     at the GCP.</span>
<a name="l02557"></a>02557   <span class="comment">//</span>
<a name="l02558"></a>02558   <span class="comment">//   cnstnd is a logical variable indicating whether bounds are present</span>
<a name="l02559"></a>02559   <span class="comment">//</span>
<a name="l02560"></a>02560   <span class="comment">//   index is an integer array of dimension n</span>
<a name="l02561"></a>02561   <span class="comment">//     for i=1,...,nfree, index(i) are the indices of free variables</span>
<a name="l02562"></a>02562   <span class="comment">//     for i=nfree+1,...,n, index(i) are the indices of bound variables</span>
<a name="l02563"></a>02563   <span class="comment">//     On entry after the first iteration, index gives </span>
<a name="l02564"></a>02564   <span class="comment">//       the free variables at the previous iteration.</span>
<a name="l02565"></a>02565   <span class="comment">//     On exit it gives the free variables based on the determination</span>
<a name="l02566"></a>02566   <span class="comment">//       in cauchy using the array iwhere.</span>
<a name="l02567"></a>02567   <span class="comment">//</span>
<a name="l02568"></a>02568   <span class="comment">//   indx2 is an integer array of dimension n</span>
<a name="l02569"></a>02569   <span class="comment">//     On entry indx2 is unspecified.</span>
<a name="l02570"></a>02570   <span class="comment">//     On exit with iter&gt;0, indx2 indicates which variables</span>
<a name="l02571"></a>02571   <span class="comment">//        have changed status since the previous iteration.</span>
<a name="l02572"></a>02572   <span class="comment">//     For i= 1,...,nenter, indx2(i) have changed from bound to free.</span>
<a name="l02573"></a>02573   <span class="comment">//     For i= ileave+1,...,n, indx2(i) have changed from free to bound.</span>
<a name="l02574"></a>02574   <span class="comment">// </span>
<a name="l02575"></a>02575   <span class="comment">//</span>
<a name="l02576"></a>02576   <span class="comment">//                         *  *  *</span>
<a name="l02577"></a>02577   <span class="comment">//</span>
<a name="l02578"></a>02578   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02579"></a>02579   <span class="comment">//   Optimization Technology Center.</span>
<a name="l02580"></a>02580   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02581"></a>02581   <span class="comment">//   Written by</span>
<a name="l02582"></a>02582   <span class="comment">//                      Ciyou Zhu</span>
<a name="l02583"></a>02583   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02584"></a>02584   <span class="comment">//</span>
<a name="l02585"></a>02585   <span class="comment">//</span>
<a name="l02586"></a>02586   <span class="comment">//   ************</span>
<a name="l02587"></a>02587     <span class="comment">//function</span>
<a name="l02588"></a>02588   <span class="keywordtype">void</span> freev(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keywordtype">int</span>&amp; nfree, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; index, <span class="keywordtype">int</span>&amp; nenter, 
<a name="l02589"></a>02589              <span class="keywordtype">int</span>&amp; ileave, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; indx2, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; iwhere, 
<a name="l02590"></a>02590              <span class="keywordtype">bool</span>&amp; wrk, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; updatd, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; cnstnd, 
<a name="l02591"></a>02591              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iter)
<a name="l02592"></a>02592   {
<a name="l02593"></a>02593     <span class="comment">//int i;</span>
<a name="l02594"></a>02594     <span class="keywordtype">int</span> iact,k;
<a name="l02595"></a>02595 
<a name="l02596"></a>02596     nenter = 0;
<a name="l02597"></a>02597     ileave = n + 1;
<a name="l02598"></a>02598     <span class="keywordflow">if</span> (iter &gt; 0 &amp;&amp; cnstnd) 
<a name="l02599"></a>02599     {
<a name="l02600"></a>02600       <span class="comment">//count the entering and leaving variables.</span>
<a name="l02601"></a>02601       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nfree; i++) 
<a name="l02602"></a>02602       {
<a name="l02603"></a>02603         k = index[i];
<a name="l02604"></a>02604         <span class="keywordflow">if</span> (iwhere[k] &gt; 0)
<a name="l02605"></a>02605         {
<a name="l02606"></a>02606           ileave -= 1;
<a name="l02607"></a>02607           indx2[ileave] = k;
<a name="l02608"></a>02608           <span class="keywordflow">if</span> (iprint &gt;= 100) 
<a name="l02609"></a>02609             cout &lt;&lt; <span class="stringliteral">"Variable "</span> &lt;&lt; k&lt;&lt;<span class="stringliteral">" leaves the set of free variables"</span>&lt;&lt;endl;
<a name="l02610"></a>02610         }
<a name="l02611"></a>02611       }
<a name="l02612"></a>02612 
<a name="l02613"></a>02613       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1+nfree; i &lt;= n; i++) 
<a name="l02614"></a>02614       {
<a name="l02615"></a>02615         k = index[i];
<a name="l02616"></a>02616         <span class="keywordflow">if</span> (iwhere[k] &lt;= 0)
<a name="l02617"></a>02617         {
<a name="l02618"></a>02618           nenter += 1;
<a name="l02619"></a>02619           indx2[nenter] = k;
<a name="l02620"></a>02620           <span class="keywordflow">if</span> (iprint &gt;= 100) 
<a name="l02621"></a>02621             cout &lt;&lt; <span class="stringliteral">"Variable "</span> &lt;&lt; k&lt;&lt;<span class="stringliteral">" enters the set of free variables"</span>&lt;&lt;endl;
<a name="l02622"></a>02622         }
<a name="l02623"></a>02623       }
<a name="l02624"></a>02624       <span class="keywordflow">if</span> (iprint &gt;= 99) 
<a name="l02625"></a>02625         cout &lt;&lt; n+1-ileave &lt;&lt; <span class="stringliteral">" variables leave; "</span> 
<a name="l02626"></a>02626              &lt;&lt; nenter &lt;&lt; <span class="stringliteral">" variables enter"</span> &lt;&lt; endl;
<a name="l02627"></a>02627     }
<a name="l02628"></a>02628     wrk = (ileave &lt; n+1) || (nenter &gt; 0) || updatd;
<a name="l02629"></a>02629  
<a name="l02630"></a>02630     <span class="comment">//Find the index set of free and active variables at the GCP.</span>
<a name="l02631"></a>02631  
<a name="l02632"></a>02632     nfree = 0;
<a name="l02633"></a>02633     iact = n + 1;
<a name="l02634"></a>02634     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) 
<a name="l02635"></a>02635     {
<a name="l02636"></a>02636       <span class="keywordflow">if</span> (iwhere[i] &lt;= 0)
<a name="l02637"></a>02637       {
<a name="l02638"></a>02638         nfree += 1;
<a name="l02639"></a>02639         index[nfree] = i;
<a name="l02640"></a>02640       }
<a name="l02641"></a>02641       <span class="keywordflow">else</span>
<a name="l02642"></a>02642       {
<a name="l02643"></a>02643         iact -= 1;
<a name="l02644"></a>02644         index[iact] = i;
<a name="l02645"></a>02645       }
<a name="l02646"></a>02646     }
<a name="l02647"></a>02647 
<a name="l02648"></a>02648     <span class="keywordflow">if</span> (iprint &gt;= 99) 
<a name="l02649"></a>02649       cout &lt;&lt; nfree &lt;&lt; <span class="stringliteral">" variables are free at GCP "</span> &lt;&lt; iter + 1 &lt;&lt; endl;
<a name="l02650"></a>02650   }<span class="comment">//freev()</span>
<a name="l02651"></a>02651 
<a name="l02652"></a>02652 
<a name="l02653"></a>02653   <span class="comment">//   ************</span>
<a name="l02654"></a>02654   <span class="comment">//</span>
<a name="l02655"></a>02655   <span class="comment">//   Subroutine hpsolb </span>
<a name="l02656"></a>02656   <span class="comment">//</span>
<a name="l02657"></a>02657   <span class="comment">//   This subroutine sorts out the least element of t, and puts the</span>
<a name="l02658"></a>02658   <span class="comment">//     remaining elements of t in a heap.</span>
<a name="l02659"></a>02659   <span class="comment">// </span>
<a name="l02660"></a>02660   <span class="comment">//   n is an integer variable.</span>
<a name="l02661"></a>02661   <span class="comment">//     On entry n is the dimension of the arrays t and iorder.</span>
<a name="l02662"></a>02662   <span class="comment">//     On exit n is unchanged.</span>
<a name="l02663"></a>02663   <span class="comment">//</span>
<a name="l02664"></a>02664   <span class="comment">//   t is a double precision array of dimension n.</span>
<a name="l02665"></a>02665   <span class="comment">//     On entry t stores the elements to be sorted,</span>
<a name="l02666"></a>02666   <span class="comment">//     On exit t(n) stores the least elements of t, and t(1) to t(n-1)</span>
<a name="l02667"></a>02667   <span class="comment">//       stores the remaining elements in the form of a heap.</span>
<a name="l02668"></a>02668   <span class="comment">//</span>
<a name="l02669"></a>02669   <span class="comment">//   iorder is an integer array of dimension n.</span>
<a name="l02670"></a>02670   <span class="comment">//     On entry iorder(i) is the index of t(i).</span>
<a name="l02671"></a>02671   <span class="comment">//     On exit iorder(i) is still the index of t(i), but iorder may be</span>
<a name="l02672"></a>02672   <span class="comment">//       permuted in accordance with t.</span>
<a name="l02673"></a>02673   <span class="comment">//</span>
<a name="l02674"></a>02674   <span class="comment">//   iheap is an integer variable specifying the task.</span>
<a name="l02675"></a>02675   <span class="comment">//     On entry iheap should be set as follows:</span>
<a name="l02676"></a>02676   <span class="comment">//       iheap == 0 if t(1) to t(n) is not in the form of a heap,</span>
<a name="l02677"></a>02677   <span class="comment">//       iheap != 0 if otherwise.</span>
<a name="l02678"></a>02678   <span class="comment">//     On exit iheap is unchanged.</span>
<a name="l02679"></a>02679   <span class="comment">//</span>
<a name="l02680"></a>02680   <span class="comment">//</span>
<a name="l02681"></a>02681   <span class="comment">//   References:</span>
<a name="l02682"></a>02682   <span class="comment">//     Algorithm 232 of CACM (J. W. J. Williams): HEAPSORT.</span>
<a name="l02683"></a>02683   <span class="comment">//</span>
<a name="l02684"></a>02684   <span class="comment">//                         *  *  *</span>
<a name="l02685"></a>02685   <span class="comment">//</span>
<a name="l02686"></a>02686   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02687"></a>02687   <span class="comment">//   Optimization Technology Center.</span>
<a name="l02688"></a>02688   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02689"></a>02689   <span class="comment">//   Written by</span>
<a name="l02690"></a>02690   <span class="comment">//                      Ciyou Zhu</span>
<a name="l02691"></a>02691   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02692"></a>02692   <span class="comment">//</span>
<a name="l02693"></a>02693   <span class="comment">//   ************</span>
<a name="l02694"></a>02694     <span class="comment">//function</span>
<a name="l02695"></a>02695   <span class="keywordtype">void</span> hpsolb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; t, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; iorder, 
<a name="l02696"></a>02696               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iheap)
<a name="l02697"></a>02697   {
<a name="l02698"></a>02698     <span class="comment">//int k;</span>
<a name="l02699"></a>02699     <span class="keywordtype">int</span> i,j,indxin,indxou;
<a name="l02700"></a>02700     <span class="keywordtype">double</span> ddum,out;
<a name="l02701"></a>02701 
<a name="l02702"></a>02702     <span class="keywordflow">if</span> (iheap == 0)
<a name="l02703"></a>02703     {
<a name="l02704"></a>02704       <span class="comment">//Rearrange the elements t[1] to t[n] to form a heap.</span>
<a name="l02705"></a>02705       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 2; k &lt;= n; k++) 
<a name="l02706"></a>02706       {
<a name="l02707"></a>02707         ddum  = t[k];
<a name="l02708"></a>02708         indxin = iorder[k];
<a name="l02709"></a>02709 
<a name="l02710"></a>02710         <span class="comment">//Add ddum to the heap.</span>
<a name="l02711"></a>02711         i = k;
<a name="l02712"></a>02712       goto10:
<a name="l02713"></a>02713         <span class="keywordflow">if</span> (i&gt;1)
<a name="l02714"></a>02714         {
<a name="l02715"></a>02715           j = i/2;
<a name="l02716"></a>02716           <span class="keywordflow">if</span> (ddum &lt; t[j])
<a name="l02717"></a>02717           {
<a name="l02718"></a>02718             t[i] = t[j];
<a name="l02719"></a>02719             iorder[i] = iorder[j];
<a name="l02720"></a>02720             i = j;
<a name="l02721"></a>02721             <span class="keywordflow">goto</span> goto10;
<a name="l02722"></a>02722           }
<a name="l02723"></a>02723                  
<a name="l02724"></a>02724         }  
<a name="l02725"></a>02725         t[i] = ddum;
<a name="l02726"></a>02726         iorder[i] = indxin;
<a name="l02727"></a>02727       }
<a name="l02728"></a>02728     }
<a name="l02729"></a>02729  
<a name="l02730"></a>02730     <span class="comment">//Assign to 'out' the value of t(1), the least member of the heap,</span>
<a name="l02731"></a>02731     <span class="comment">//and rearrange the remaining members to form a heap as</span>
<a name="l02732"></a>02732     <span class="comment">//elements 1 to n-1 of t.</span>
<a name="l02733"></a>02733  
<a name="l02734"></a>02734     <span class="keywordflow">if</span> (n &gt; 1)
<a name="l02735"></a>02735     {
<a name="l02736"></a>02736       i = 1;
<a name="l02737"></a>02737       out = t[1];
<a name="l02738"></a>02738       indxou = iorder[1];
<a name="l02739"></a>02739       ddum = t[n];
<a name="l02740"></a>02740       indxin = iorder[n];
<a name="l02741"></a>02741 
<a name="l02742"></a>02742       <span class="comment">//Restore the heap </span>
<a name="l02743"></a>02743     goto30:
<a name="l02744"></a>02744       j = i+i;
<a name="l02745"></a>02745       <span class="keywordflow">if</span> (j &lt;= n-1) 
<a name="l02746"></a>02746       {
<a name="l02747"></a>02747         <span class="keywordflow">if</span> (t[j+1] &lt; t[j]) j = j+1;
<a name="l02748"></a>02748         <span class="keywordflow">if</span> (t[j] &lt; ddum )
<a name="l02749"></a>02749         {
<a name="l02750"></a>02750           t[i] = t[j];
<a name="l02751"></a>02751           iorder[i] = iorder[j];
<a name="l02752"></a>02752           i = j;
<a name="l02753"></a>02753           <span class="keywordflow">goto</span> goto30;
<a name="l02754"></a>02754         } 
<a name="l02755"></a>02755       } 
<a name="l02756"></a>02756       t[i] = ddum;
<a name="l02757"></a>02757       iorder[i] = indxin;
<a name="l02758"></a>02758  
<a name="l02759"></a>02759       <span class="comment">//Put the least member in t(n). </span>
<a name="l02760"></a>02760 
<a name="l02761"></a>02761       t[n] = out;
<a name="l02762"></a>02762       iorder[n] = indxou;
<a name="l02763"></a>02763     }
<a name="l02764"></a>02764   }<span class="comment">//hpsolb()</span>
<a name="l02765"></a>02765 
<a name="l02766"></a>02766 
<a name="l02767"></a>02767   <span class="comment">//   **********</span>
<a name="l02768"></a>02768   <span class="comment">//</span>
<a name="l02769"></a>02769   <span class="comment">//   Subroutine lnsrlb</span>
<a name="l02770"></a>02770   <span class="comment">//</span>
<a name="l02771"></a>02771   <span class="comment">//   This subroutine calls subroutine dcsrch from the Minpack2 library</span>
<a name="l02772"></a>02772   <span class="comment">//     to perform the line search.  Subroutine dscrch is safeguarded so</span>
<a name="l02773"></a>02773   <span class="comment">//     that all trial points lie within the feasible region.</span>
<a name="l02774"></a>02774   <span class="comment">//</span>
<a name="l02775"></a>02775   <span class="comment">//   Subprograms called:</span>
<a name="l02776"></a>02776   <span class="comment">//</span>
<a name="l02777"></a>02777   <span class="comment">//     Minpack2 Library ... dcsrch.</span>
<a name="l02778"></a>02778   <span class="comment">//</span>
<a name="l02779"></a>02779   <span class="comment">//     Linpack ... dtrsl, ddot.</span>
<a name="l02780"></a>02780   <span class="comment">//</span>
<a name="l02781"></a>02781   <span class="comment">//</span>
<a name="l02782"></a>02782   <span class="comment">//                         *  *  *</span>
<a name="l02783"></a>02783   <span class="comment">//</span>
<a name="l02784"></a>02784   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02785"></a>02785   <span class="comment">//   Optimization Technology Center.</span>
<a name="l02786"></a>02786   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02787"></a>02787   <span class="comment">//   Written by</span>
<a name="l02788"></a>02788   <span class="comment">//                      Ciyou Zhu</span>
<a name="l02789"></a>02789   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02790"></a>02790   <span class="comment">//</span>
<a name="l02791"></a>02791   <span class="comment">//</span>
<a name="l02792"></a>02792   <span class="comment">//   **********</span>
<a name="l02793"></a>02793     <span class="comment">//function</span>
<a name="l02794"></a>02794   <span class="keywordtype">void</span> lnsrlb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, 
<a name="l02795"></a>02795               <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span>&amp; nbd, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, <span class="keywordtype">double</span>&amp; f, 
<a name="l02796"></a>02796               <span class="keywordtype">double</span>&amp; fold, <span class="keywordtype">double</span>&amp; gd, <span class="keywordtype">double</span>&amp; gdold, <span class="keywordtype">double</span>* <span class="keyword">const</span>&amp; g, 
<a name="l02797"></a>02797               <span class="keywordtype">double</span>* <span class="keyword">const</span>&amp; d, <span class="keywordtype">double</span>* <span class="keyword">const</span>&amp; r, <span class="keywordtype">double</span>* <span class="keyword">const</span>&amp; t,
<a name="l02798"></a>02798               <span class="keywordtype">double</span>* <span class="keyword">const</span>&amp; z, <span class="keywordtype">double</span>&amp; stp, <span class="keywordtype">double</span>&amp; dnorm, <span class="keywordtype">double</span>&amp; dtd, 
<a name="l02799"></a>02799               <span class="keywordtype">double</span>&amp; xstep, <span class="keywordtype">double</span>&amp; stpmx, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iter, <span class="keywordtype">int</span>&amp; ifun,
<a name="l02800"></a>02800               <span class="keywordtype">int</span>&amp; iback, <span class="keywordtype">int</span>&amp; nfgv, <span class="keywordtype">int</span>&amp; info, <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; task, 
<a name="l02801"></a>02801               <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; boxed, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; cnstnd, <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; csave,
<a name="l02802"></a>02802               <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; isave, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dsave)
<a name="l02803"></a>02803   {
<a name="l02804"></a>02804     <span class="comment">//int i;</span>
<a name="l02805"></a>02805     <span class="keywordtype">double</span> a1,a2;
<a name="l02806"></a>02806     <span class="keywordtype">double</span> one=1.0,zero=0.0,big=1e10;
<a name="l02807"></a>02807     <span class="keywordtype">double</span> ftol=1.0e-3,gtol=0.9,xtol=0.1;
<a name="l02808"></a>02808 
<a name="l02809"></a>02809     
<a name="l02810"></a>02810     <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"FG_LN"</span>,5)==0) <span class="keywordflow">goto</span> goto556;
<a name="l02811"></a>02811 
<a name="l02812"></a>02812     dtd = ddot(n,d,1,d,1);
<a name="l02813"></a>02813     dnorm = sqrt(dtd);
<a name="l02814"></a>02814 
<a name="l02815"></a>02815     <span class="comment">//Determine the maximum step length.</span>
<a name="l02816"></a>02816 
<a name="l02817"></a>02817     stpmx = big;
<a name="l02818"></a>02818     <span class="keywordflow">if</span> (cnstnd)
<a name="l02819"></a>02819     {
<a name="l02820"></a>02820       <span class="keywordflow">if</span> (iter == 0)
<a name="l02821"></a>02821         stpmx = one;
<a name="l02822"></a>02822       <span class="keywordflow">else</span>
<a name="l02823"></a>02823       {
<a name="l02824"></a>02824         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) 
<a name="l02825"></a>02825         {
<a name="l02826"></a>02826           a1 = d[i];
<a name="l02827"></a>02827           <span class="keywordflow">if</span> (nbd[i] != 0)
<a name="l02828"></a>02828           {
<a name="l02829"></a>02829             <span class="keywordflow">if</span> (a1 &lt; zero &amp;&amp; nbd[i] &lt;= 2)
<a name="l02830"></a>02830             {
<a name="l02831"></a>02831               a2 = l[i] - x[i];
<a name="l02832"></a>02832               <span class="keywordflow">if</span> (a2 &gt;= zero)
<a name="l02833"></a>02833                 stpmx = zero;
<a name="l02834"></a>02834               <span class="keywordflow">else</span> 
<a name="l02835"></a>02835               <span class="keywordflow">if</span> (a1*stpmx &lt; a2)
<a name="l02836"></a>02836                 stpmx = a2/a1;
<a name="l02837"></a>02837             }
<a name="l02838"></a>02838             <span class="keywordflow">else</span> 
<a name="l02839"></a>02839             <span class="keywordflow">if</span> (a1 &gt; zero &amp;&amp; nbd[i] &gt;= 2)
<a name="l02840"></a>02840             {
<a name="l02841"></a>02841               a2 = u[i] - x[i];
<a name="l02842"></a>02842               <span class="keywordflow">if</span> (a2 &lt;= zero)
<a name="l02843"></a>02843                 stpmx = zero;
<a name="l02844"></a>02844               <span class="keywordflow">else</span> 
<a name="l02845"></a>02845               <span class="keywordflow">if</span> (a1*stpmx &gt; a2)
<a name="l02846"></a>02846                 stpmx = a2/a1;
<a name="l02847"></a>02847             }
<a name="l02848"></a>02848           }
<a name="l02849"></a>02849         } <span class="comment">// for (int i = 1; i &lt;= n; i++) </span>
<a name="l02850"></a>02850       }
<a name="l02851"></a>02851     }
<a name="l02852"></a>02852  
<a name="l02853"></a>02853     <span class="keywordflow">if</span> (iter == 0 &amp;&amp; !boxed)
<a name="l02854"></a>02854       stp = min(one/dnorm, stpmx);
<a name="l02855"></a>02855     <span class="keywordflow">else</span>
<a name="l02856"></a>02856       stp = one;
<a name="l02857"></a>02857 
<a name="l02858"></a>02858     dcopy(n,x,1,t,1);
<a name="l02859"></a>02859     dcopy(n,g,1,r,1);
<a name="l02860"></a>02860     fold = f;
<a name="l02861"></a>02861     ifun = 0;
<a name="l02862"></a>02862     iback = 0;
<a name="l02863"></a>02863     strcpy(csave,<span class="stringliteral">"START"</span>);
<a name="l02864"></a>02864   goto556:
<a name="l02865"></a>02865     gd = ddot(n,g,1,d,1);
<a name="l02866"></a>02866     <span class="keywordflow">if</span> (ifun == 0)
<a name="l02867"></a>02867     {
<a name="l02868"></a>02868       gdold=gd;
<a name="l02869"></a>02869       <span class="keywordflow">if</span> (gd &gt;= zero)
<a name="l02870"></a>02870       {
<a name="l02871"></a>02871         <span class="comment">//the directional derivative &gt;=0.</span>
<a name="l02872"></a>02872         <span class="comment">//Line search is impossible.</span>
<a name="l02873"></a>02873         info = -4;
<a name="l02874"></a>02874         <span class="keywordflow">return</span>;
<a name="l02875"></a>02875       }
<a name="l02876"></a>02876     }
<a name="l02877"></a>02877 
<a name="l02878"></a>02878     dcsrch(f,gd,stp,ftol,gtol,xtol,zero,stpmx,csave,isave,dsave);
<a name="l02879"></a>02879 
<a name="l02880"></a>02880     xstep = stp*dnorm;
<a name="l02881"></a>02881     <span class="keywordflow">if</span> (strncmp(csave,<span class="stringliteral">"CONV"</span>,4) != 0 &amp;&amp; strncmp(csave,<span class="stringliteral">"WARN"</span>,4) != 0) 
<a name="l02882"></a>02882     {
<a name="l02883"></a>02883       strcpy(task,<span class="stringliteral">"FG_LNSRCH"</span>);
<a name="l02884"></a>02884       ifun += 1;
<a name="l02885"></a>02885       nfgv += 1;
<a name="l02886"></a>02886       iback = ifun - 1;
<a name="l02887"></a>02887       <span class="keywordflow">if</span> (stp == one)
<a name="l02888"></a>02888         dcopy(n,z,1,x,1);
<a name="l02889"></a>02889       <span class="keywordflow">else</span>
<a name="l02890"></a>02890       {
<a name="l02891"></a>02891         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) 
<a name="l02892"></a>02892           x[i] = stp*d[i] + t[i];
<a name="l02893"></a>02893       }
<a name="l02894"></a>02894     }
<a name="l02895"></a>02895     <span class="keywordflow">else</span>
<a name="l02896"></a>02896       strcpy(task,<span class="stringliteral">"NEW_X"</span>);    
<a name="l02897"></a>02897   } <span class="comment">//lnsrlb()</span>
<a name="l02898"></a>02898 
<a name="l02899"></a>02899 
<a name="l02900"></a>02900   <span class="comment">//   ************</span>
<a name="l02901"></a>02901   <span class="comment">//</span>
<a name="l02902"></a>02902   <span class="comment">//   Subroutine matupd</span>
<a name="l02903"></a>02903   <span class="comment">//</span>
<a name="l02904"></a>02904   <span class="comment">//     This subroutine updates matrices WS and WY, and forms the</span>
<a name="l02905"></a>02905   <span class="comment">//       middle matrix in B.</span>
<a name="l02906"></a>02906   <span class="comment">//</span>
<a name="l02907"></a>02907   <span class="comment">//   Subprograms called:</span>
<a name="l02908"></a>02908   <span class="comment">//</span>
<a name="l02909"></a>02909   <span class="comment">//     Linpack ... dcopy, ddot.</span>
<a name="l02910"></a>02910   <span class="comment">//</span>
<a name="l02911"></a>02911   <span class="comment">//</span>
<a name="l02912"></a>02912   <span class="comment">//                         *  *  *</span>
<a name="l02913"></a>02913   <span class="comment">//</span>
<a name="l02914"></a>02914   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l02915"></a>02915   <span class="comment">//   Optimization Technology Center.</span>
<a name="l02916"></a>02916   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l02917"></a>02917   <span class="comment">//   Written by</span>
<a name="l02918"></a>02918   <span class="comment">//                      Ciyou Zhu</span>
<a name="l02919"></a>02919   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l02920"></a>02920   <span class="comment">//</span>
<a name="l02921"></a>02921   <span class="comment">//</span>
<a name="l02922"></a>02922   <span class="comment">//   ************</span>
<a name="l02923"></a>02923     <span class="comment">//function</span>
<a name="l02924"></a>02924   <span class="keywordtype">void</span> matupd(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ws, 
<a name="l02925"></a>02925               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wy, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; sy, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ss, 
<a name="l02926"></a>02926               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; d, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; r, <span class="keywordtype">int</span>&amp; itail, <span class="keywordtype">int</span>&amp; iupdat, 
<a name="l02927"></a>02927               <span class="keywordtype">int</span>&amp; col, <span class="keywordtype">int</span>&amp; head, <span class="keywordtype">double</span>&amp; theta, <span class="keywordtype">double</span>&amp; rr, <span class="keywordtype">double</span>&amp; dr, 
<a name="l02928"></a>02928               <span class="keywordtype">double</span>&amp; stp, <span class="keywordtype">double</span>&amp; dtd)
<a name="l02929"></a>02929   {
<a name="l02930"></a>02930     <span class="comment">//int j;</span>
<a name="l02931"></a>02931     <span class="keywordtype">int</span> pointr;
<a name="l02932"></a>02932     <span class="keywordtype">double</span> one=1.0;
<a name="l02933"></a>02933     <span class="keywordtype">int</span> idx;
<a name="l02934"></a>02934 
<a name="l02935"></a>02935     <span class="comment">//Set pointers for matrices WS and WY.</span>
<a name="l02936"></a>02936     <span class="keywordflow">if</span> (iupdat &lt;= m)
<a name="l02937"></a>02937     {
<a name="l02938"></a>02938       col = iupdat;
<a name="l02939"></a>02939       itail = (head+iupdat-2)%m + 1;
<a name="l02940"></a>02940     }
<a name="l02941"></a>02941     <span class="keywordflow">else</span>
<a name="l02942"></a>02942     {
<a name="l02943"></a>02943       itail = itail%m + 1;
<a name="l02944"></a>02944       head = head%m + 1;
<a name="l02945"></a>02945     }
<a name="l02946"></a>02946  
<a name="l02947"></a>02947     <span class="comment">//Update matrices WS and WY.</span>
<a name="l02948"></a>02948     idx = getIdx(1,itail,n)-1;
<a name="l02949"></a>02949     dcopy(n,d,1,&amp;(ws[idx]),1);
<a name="l02950"></a>02950     dcopy(n,r,1,&amp;(wy[idx]),1);
<a name="l02951"></a>02951  
<a name="l02952"></a>02952     <span class="comment">//Set theta=yy/ys.</span>
<a name="l02953"></a>02953     theta = rr/dr;
<a name="l02954"></a>02954  
<a name="l02955"></a>02955     <span class="comment">//Form the middle matrix in B.</span>
<a name="l02956"></a>02956     <span class="comment">//update the upper triangle of SS,</span>
<a name="l02957"></a>02957     <span class="comment">//and the lower triangle of SY:</span>
<a name="l02958"></a>02958     <span class="keywordflow">if</span> (iupdat &gt; m)
<a name="l02959"></a>02959     {
<a name="l02960"></a>02960       <span class="comment">//move old information</span>
<a name="l02961"></a>02961       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= col-1; j++)
<a name="l02962"></a>02962       {
<a name="l02963"></a>02963         dcopy(j,&amp;(ss[getIdx(2,j+1,m)-1]),1,&amp;(ss[getIdx(1,j,m)-1]),1);
<a name="l02964"></a>02964         dcopy(col-j,&amp;(sy[getIdx(j+1,j+1,m)-1]),1,&amp;(sy[getIdx(j,j,m)-1]),1);
<a name="l02965"></a>02965       }
<a name="l02966"></a>02966     }
<a name="l02967"></a>02967 
<a name="l02968"></a>02968     <span class="comment">//add new information: the last row of SY</span>
<a name="l02969"></a>02969     <span class="comment">//and the last column of SS:</span>
<a name="l02970"></a>02970     pointr = head;
<a name="l02971"></a>02971     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= col-1; j++)
<a name="l02972"></a>02972     {
<a name="l02973"></a>02973       idx = getIdx(1,pointr,n)-1;
<a name="l02974"></a>02974       sy[getIdx(col,j,m)] = ddot(n,d,1,&amp;(wy[idx]),1);
<a name="l02975"></a>02975       ss[getIdx(j,col,m)] = ddot(n,&amp;(ws[idx]),1,d,1);   
<a name="l02976"></a>02976       pointr = pointr%m + 1;
<a name="l02977"></a>02977     }
<a name="l02978"></a>02978 
<a name="l02979"></a>02979     idx = getIdx(col,col,m);
<a name="l02980"></a>02980     <span class="keywordflow">if</span> (stp == one)
<a name="l02981"></a>02981       ss[idx] = dtd;
<a name="l02982"></a>02982     <span class="keywordflow">else</span>
<a name="l02983"></a>02983       ss[idx] = stp*stp*dtd;
<a name="l02984"></a>02984     
<a name="l02985"></a>02985     sy[idx] = dr;
<a name="l02986"></a>02986   }<span class="comment">//matupd() </span>
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 
<a name="l02989"></a>02989   <span class="comment">//   ************</span>
<a name="l02990"></a>02990   <span class="comment">//</span>
<a name="l02991"></a>02991   <span class="comment">//   Subroutine prn1lb</span>
<a name="l02992"></a>02992   <span class="comment">//</span>
<a name="l02993"></a>02993   <span class="comment">//   This subroutine prints the input data, initial point, upper and</span>
<a name="l02994"></a>02994   <span class="comment">//     lower bounds of each variable, machine precision, as well as </span>
<a name="l02995"></a>02995   <span class="comment">//     the headings of the output.</span>
<a name="l02996"></a>02996   <span class="comment">//</span>
<a name="l02997"></a>02997   <span class="comment">//</span>
<a name="l02998"></a>02998   <span class="comment">//                         *  *  *</span>
<a name="l02999"></a>02999   <span class="comment">//</span>
<a name="l03000"></a>03000   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l03001"></a>03001   <span class="comment">//   Optimization Technology Center.</span>
<a name="l03002"></a>03002   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l03003"></a>03003   <span class="comment">//   Written by</span>
<a name="l03004"></a>03004   <span class="comment">//                      Ciyou Zhu</span>
<a name="l03005"></a>03005   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l03006"></a>03006   <span class="comment">//</span>
<a name="l03007"></a>03007   <span class="comment">//</span>
<a name="l03008"></a>03008   <span class="comment">//   ************</span>
<a name="l03009"></a>03009     <span class="comment">//function</span>
<a name="l03010"></a>03010   <span class="keywordtype">void</span> prn1lb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, 
<a name="l03011"></a>03011               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, 
<a name="l03012"></a>03012               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint, ofstream* itfile, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; epsmch)
<a name="l03013"></a>03013   {
<a name="l03014"></a>03014     <span class="comment">//int i;</span>
<a name="l03015"></a>03015 
<a name="l03016"></a>03016     <span class="keywordflow">if</span> (iprint &gt;= 0)
<a name="l03017"></a>03017     {
<a name="l03018"></a>03018       cout &lt;&lt; <span class="stringliteral">"RUNNING THE L-BFGS-B CODE, "</span> &lt;&lt; endl
<a name="l03019"></a>03019            &lt;&lt; <span class="stringliteral">"epsmch = machine precision"</span> &lt;&lt; endl
<a name="l03020"></a>03020            &lt;&lt; <span class="stringliteral">"it    = iteration number"</span> &lt;&lt; endl
<a name="l03021"></a>03021            &lt;&lt; <span class="stringliteral">"nf    = number of function evaluations"</span> &lt;&lt; endl
<a name="l03022"></a>03022            &lt;&lt; <span class="stringliteral">"nint  = number of segments explored during the Cauchy search"</span> 
<a name="l03023"></a>03023            &lt;&lt; endl
<a name="l03024"></a>03024            &lt;&lt; <span class="stringliteral">"nact  = number of active bounds at the generalized Cauchy point"</span>
<a name="l03025"></a>03025            &lt;&lt; endl
<a name="l03026"></a>03026            &lt;&lt; <span class="stringliteral">"sub   = manner in which the subspace minimization terminated:"</span>
<a name="l03027"></a>03027            &lt;&lt; endl
<a name="l03028"></a>03028            &lt;&lt;<span class="stringliteral">"con = converged, bnd = a bound was reached"</span> &lt;&lt; endl
<a name="l03029"></a>03029            &lt;&lt; <span class="stringliteral">"itls  = number of iterations performed in the line search"</span> 
<a name="l03030"></a>03030            &lt;&lt; endl
<a name="l03031"></a>03031            &lt;&lt; <span class="stringliteral">"stepl = step length used"</span> &lt;&lt; endl
<a name="l03032"></a>03032            &lt;&lt; <span class="stringliteral">"tstep = norm of the displacement (total step)"</span> &lt;&lt; endl
<a name="l03033"></a>03033            &lt;&lt; <span class="stringliteral">"projg = norm of the projected gradient"</span> &lt;&lt; endl
<a name="l03034"></a>03034            &lt;&lt; <span class="stringliteral">"f     = function value"</span> &lt;&lt; endl
<a name="l03035"></a>03035            &lt;&lt; <span class="stringliteral">"Machine precision = "</span> &lt;&lt; epsmch &lt;&lt; endl;
<a name="l03036"></a>03036       cout &lt;&lt; <span class="stringliteral">"N = "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">",    M = "</span> &lt;&lt; m &lt;&lt; endl;
<a name="l03037"></a>03037       <span class="keywordflow">if</span> (iprint &gt;= 1)
<a name="l03038"></a>03038       {
<a name="l03039"></a>03039         *itfile &lt;&lt; <span class="stringliteral">"RUNNING THE L-BFGS-B CODE, epsmch = "</span> 
<a name="l03040"></a>03040                 &lt;&lt; <span class="stringliteral">"it    = iteration number"</span> &lt;&lt; endl
<a name="l03041"></a>03041                 &lt;&lt; <span class="stringliteral">"nf    = number of function evaluations"</span> &lt;&lt; endl
<a name="l03042"></a>03042                 &lt;&lt;<span class="stringliteral">"nint  = number of segments explored during the Cauchy search"</span>
<a name="l03043"></a>03043                 &lt;&lt; endl
<a name="l03044"></a>03044                 &lt;&lt;<span class="stringliteral">"nact  = number of active bounds at generalized Cauchy point"</span>
<a name="l03045"></a>03045                 &lt;&lt; endl
<a name="l03046"></a>03046                 &lt;&lt;<span class="stringliteral">"sub   =manner in which the subspace minimization terminated:"</span>
<a name="l03047"></a>03047                 &lt;&lt; endl
<a name="l03048"></a>03048                 &lt;&lt;<span class="stringliteral">"con = converged, bnd = a bound was reached"</span> &lt;&lt; endl
<a name="l03049"></a>03049                 &lt;&lt; <span class="stringliteral">"itls  = number of iterations performed in the line search"</span> 
<a name="l03050"></a>03050                 &lt;&lt; endl
<a name="l03051"></a>03051                 &lt;&lt; <span class="stringliteral">"stepl = step length used"</span> &lt;&lt; endl
<a name="l03052"></a>03052                 &lt;&lt; <span class="stringliteral">"tstep = norm of the displacement (total step)"</span> &lt;&lt; endl
<a name="l03053"></a>03053                 &lt;&lt; <span class="stringliteral">"projg = norm of the projected gradient"</span> &lt;&lt; endl
<a name="l03054"></a>03054                 &lt;&lt; <span class="stringliteral">"f     = function value"</span> &lt;&lt; endl
<a name="l03055"></a>03055                 &lt;&lt; <span class="stringliteral">"Machine precision = "</span> &lt;&lt; epsmch &lt;&lt; endl;
<a name="l03056"></a>03056         *itfile &lt;&lt; <span class="stringliteral">"N = "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">",    M = "</span> &lt;&lt; m &lt;&lt; endl;
<a name="l03057"></a>03057         *itfile &lt;&lt; <span class="stringliteral">"   it   nf  nint  nact  sub  itls  stepl    tstep     projg"</span>
<a name="l03058"></a>03058                 &lt;&lt; <span class="stringliteral">"        f"</span> &lt;&lt; endl;
<a name="l03059"></a>03059         <span class="keywordflow">if</span> (iprint &gt; 100)
<a name="l03060"></a>03060         {
<a name="l03061"></a>03061           cout &lt;&lt; <span class="stringliteral">"L = "</span>;
<a name="l03062"></a>03062           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) cout &lt;&lt; l[i] &lt;&lt; <span class="stringliteral">" "</span>; 
<a name="l03063"></a>03063           cout &lt;&lt; endl;
<a name="l03064"></a>03064           cout &lt;&lt; <span class="stringliteral">"X0 = "</span>;
<a name="l03065"></a>03065           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) cout &lt;&lt; x[i] &lt;&lt; <span class="stringliteral">" "</span>; 
<a name="l03066"></a>03066           cout &lt;&lt; endl;
<a name="l03067"></a>03067           cout &lt;&lt; <span class="stringliteral">"U = "</span>;
<a name="l03068"></a>03068           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) cout &lt;&lt; u[i] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l03069"></a>03069           cout &lt;&lt; endl;
<a name="l03070"></a>03070         }
<a name="l03071"></a>03071       }
<a name="l03072"></a>03072     }
<a name="l03073"></a>03073   } <span class="comment">//prn2lb()</span>
<a name="l03074"></a>03074 
<a name="l03075"></a>03075 
<a name="l03076"></a>03076   <span class="comment">//   ************</span>
<a name="l03077"></a>03077   <span class="comment">//</span>
<a name="l03078"></a>03078   <span class="comment">//   Subroutine prn2lb</span>
<a name="l03079"></a>03079   <span class="comment">//</span>
<a name="l03080"></a>03080   <span class="comment">//   This subroutine prints out new information after a successful</span>
<a name="l03081"></a>03081   <span class="comment">//     line search. </span>
<a name="l03082"></a>03082   <span class="comment">//</span>
<a name="l03083"></a>03083   <span class="comment">//</span>
<a name="l03084"></a>03084   <span class="comment">//                         *  *  *</span>
<a name="l03085"></a>03085   <span class="comment">//</span>
<a name="l03086"></a>03086   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l03087"></a>03087   <span class="comment">//   Optimization Technology Center.</span>
<a name="l03088"></a>03088   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l03089"></a>03089   <span class="comment">//   Written by</span>
<a name="l03090"></a>03090   <span class="comment">//                      Ciyou Zhu</span>
<a name="l03091"></a>03091   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l03092"></a>03092   <span class="comment">//</span>
<a name="l03093"></a>03093   <span class="comment">//</span>
<a name="l03094"></a>03094   <span class="comment">//   ************</span>
<a name="l03095"></a>03095     <span class="comment">//function</span>
<a name="l03096"></a>03096   <span class="keywordtype">void</span> prn2lb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; f, 
<a name="l03097"></a>03097               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; g, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint, 
<a name="l03098"></a>03098               ofstream* itfile, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iter, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nfgv, 
<a name="l03099"></a>03099               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nact, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; sbgnrm, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nint, 
<a name="l03100"></a>03100               <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; word, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iword, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iback, 
<a name="l03101"></a>03101               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; stp, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; xstep)
<a name="l03102"></a>03102   {
<a name="l03103"></a>03103     <span class="comment">//int i;</span>
<a name="l03104"></a>03104     <span class="keywordtype">int</span> imod;
<a name="l03105"></a>03105 
<a name="l03106"></a>03106     <span class="comment">//'word' records the status of subspace solutions.</span>
<a name="l03107"></a>03107     <span class="keywordflow">if</span> (iword == 0)
<a name="l03108"></a>03108     {
<a name="l03109"></a>03109       <span class="comment">//the subspace minimization converged.</span>
<a name="l03110"></a>03110       strcpy(word, <span class="stringliteral">"con"</span>);
<a name="l03111"></a>03111     }
<a name="l03112"></a>03112     <span class="keywordflow">else</span> 
<a name="l03113"></a>03113     <span class="keywordflow">if</span> (iword == 1)
<a name="l03114"></a>03114     {
<a name="l03115"></a>03115       <span class="comment">//the subspace minimization stopped at a bound.</span>
<a name="l03116"></a>03116       strcpy(word, <span class="stringliteral">"bnd"</span>);
<a name="l03117"></a>03117     }
<a name="l03118"></a>03118     <span class="keywordflow">else</span> 
<a name="l03119"></a>03119     <span class="keywordflow">if</span> (iword == 5)
<a name="l03120"></a>03120     {
<a name="l03121"></a>03121       <span class="comment">//the truncated Newton step has been used.</span>
<a name="l03122"></a>03122       strcpy(word, <span class="stringliteral">"TNT"</span>);
<a name="l03123"></a>03123 
<a name="l03124"></a>03124     }      
<a name="l03125"></a>03125     <span class="keywordflow">else</span>
<a name="l03126"></a>03126       strcpy(word, <span class="stringliteral">"---"</span>);
<a name="l03127"></a>03127 
<a name="l03128"></a>03128     <span class="keywordflow">if</span> (iprint &gt;= 99)
<a name="l03129"></a>03129     {
<a name="l03130"></a>03130       cout &lt;&lt; <span class="stringliteral">"LINE SEARCH "</span> &lt;&lt; iback &lt;&lt;<span class="stringliteral">" times; norm of step = "</span> &lt;&lt;xstep&lt;&lt;endl;
<a name="l03131"></a>03131       cout &lt;&lt; <span class="stringliteral">"At iterate "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">" f="</span> &lt;&lt; f &lt;&lt;<span class="stringliteral">"  |proj g|="</span>&lt;&lt;sbgnrm&lt;&lt;endl;
<a name="l03132"></a>03132 
<a name="l03133"></a>03133       <span class="keywordflow">if</span> (iprint &gt; 100)
<a name="l03134"></a>03134       { 
<a name="l03135"></a>03135         cout &lt;&lt; <span class="stringliteral">"X = "</span> &lt;&lt; endl;
<a name="l03136"></a>03136         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) cout &lt;&lt; x[i] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l03137"></a>03137         cout &lt;&lt; endl;
<a name="l03138"></a>03138         cout &lt;&lt; <span class="stringliteral">"G = "</span> &lt;&lt; endl;
<a name="l03139"></a>03139         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) cout &lt;&lt; g[i] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l03140"></a>03140         cout &lt;&lt; endl;
<a name="l03141"></a>03141       }
<a name="l03142"></a>03142     }
<a name="l03143"></a>03143     <span class="keywordflow">else</span> 
<a name="l03144"></a>03144     <span class="keywordflow">if</span> (iprint &gt; 0)
<a name="l03145"></a>03145     {
<a name="l03146"></a>03146       imod = iter%iprint;
<a name="l03147"></a>03147       <span class="keywordflow">if</span> (imod == 0) {
<a name="l03148"></a>03148         cout &lt;&lt; <span class="stringliteral">"At iterate "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">" f="</span>&lt;&lt;f&lt;&lt; <span class="stringliteral">"  |proj g|="</span>&lt;&lt;sbgnrm&lt;&lt;endl;
<a name="l03149"></a>03149       }
<a name="l03150"></a>03150     }
<a name="l03151"></a>03151     <span class="keywordflow">if</span> (iprint &gt;= 1)
<a name="l03152"></a>03152       *itfile &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nfgv &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nint &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nact &lt;&lt; <span class="stringliteral">" "</span>
<a name="l03153"></a>03153            &lt;&lt; word &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; iback &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; stp &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; xstep &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l03154"></a>03154            &lt;&lt; sbgnrm &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; f &lt;&lt; endl;
<a name="l03155"></a>03155   }<span class="comment">//prn2lb()</span>
<a name="l03156"></a>03156 
<a name="l03157"></a>03157 
<a name="l03158"></a>03158   <span class="comment">//   ************</span>
<a name="l03159"></a>03159   <span class="comment">//</span>
<a name="l03160"></a>03160   <span class="comment">//   Subroutine prn3lb</span>
<a name="l03161"></a>03161   <span class="comment">//</span>
<a name="l03162"></a>03162   <span class="comment">//   This subroutine prints out information when either a built-in</span>
<a name="l03163"></a>03163   <span class="comment">//     convergence test is satisfied or when an error message is</span>
<a name="l03164"></a>03164   <span class="comment">//     generated.</span>
<a name="l03165"></a>03165   <span class="comment">//     </span>
<a name="l03166"></a>03166   <span class="comment">//</span>
<a name="l03167"></a>03167   <span class="comment">//                         *  *  *</span>
<a name="l03168"></a>03168   <span class="comment">//</span>
<a name="l03169"></a>03169   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l03170"></a>03170   <span class="comment">//   Optimization Technology Center.</span>
<a name="l03171"></a>03171   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l03172"></a>03172   <span class="comment">//   Written by</span>
<a name="l03173"></a>03173   <span class="comment">//                      Ciyou Zhu</span>
<a name="l03174"></a>03174   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l03175"></a>03175   <span class="comment">//</span>
<a name="l03176"></a>03176   <span class="comment">//</span>
<a name="l03177"></a>03177   <span class="comment">//   ************</span>
<a name="l03178"></a>03178     <span class="comment">//function</span>
<a name="l03179"></a>03179   <span class="keywordtype">void</span> prn3lb(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, <span class="keywordtype">double</span>&amp; f, 
<a name="l03180"></a>03180               <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; task, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint, 
<a name="l03181"></a>03181               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; info, ofstream* itfile, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iter, 
<a name="l03182"></a>03182               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nfgv, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nintol, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nskip, 
<a name="l03183"></a>03183               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nact, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; sbgnrm, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; time, 
<a name="l03184"></a>03184               <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nint, <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; word, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iback, 
<a name="l03185"></a>03185               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; stp,<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; xstep, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; k, 
<a name="l03186"></a>03186               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; cachyt, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; sbtime, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; lnscht)
<a name="l03187"></a>03187   {
<a name="l03188"></a>03188     <span class="comment">//int i;</span>
<a name="l03189"></a>03189     <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"ERROR"</span>,5)==0) <span class="keywordflow">goto</span> goto999;
<a name="l03190"></a>03190 
<a name="l03191"></a>03191     <span class="keywordflow">if</span> (iprint &gt;= 0)
<a name="l03192"></a>03192     {
<a name="l03193"></a>03193       cout &lt;&lt; <span class="stringliteral">"           * * *"</span> 
<a name="l03194"></a>03194            &lt;&lt; <span class="stringliteral">"Tit   = total number of iterations"</span> &lt;&lt; endl
<a name="l03195"></a>03195            &lt;&lt; <span class="stringliteral">"Tnf   = total number of function evaluations"</span> &lt;&lt; endl
<a name="l03196"></a>03196            &lt;&lt; <span class="stringliteral">"Tnint = total number of segments explored during"</span>
<a name="l03197"></a>03197            &lt;&lt; <span class="stringliteral">" Cauchy searches"</span> &lt;&lt; endl
<a name="l03198"></a>03198            &lt;&lt; <span class="stringliteral">"Skip  = number of BFGS updates skipped"</span> &lt;&lt; endl
<a name="l03199"></a>03199            &lt;&lt; <span class="stringliteral">"Nact  = number of active bounds at final generalized"</span>
<a name="l03200"></a>03200            &lt;&lt; <span class="stringliteral">" Cauchy point"</span> &lt;&lt; endl
<a name="l03201"></a>03201            &lt;&lt; <span class="stringliteral">"Projg = norm of the final projected gradient"</span> &lt;&lt; endl
<a name="l03202"></a>03202            &lt;&lt; <span class="stringliteral">"F     = final function value"</span> &lt;&lt; endl
<a name="l03203"></a>03203            &lt;&lt; <span class="stringliteral">"           * * *"</span> &lt;&lt; endl;
<a name="l03204"></a>03204       
<a name="l03205"></a>03205       cout &lt;&lt; <span class="stringliteral">"   N   Tit  Tnf  Tnint  Skip  Nact     Projg        F"</span> &lt;&lt; endl;
<a name="l03206"></a>03206       cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nfgv &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nintol &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l03207"></a>03207            &lt;&lt; nskip &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nact &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; sbgnrm &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; f &lt;&lt; endl;
<a name="l03208"></a>03208       <span class="keywordflow">if</span> (iprint &gt;= 100)
<a name="l03209"></a>03209       {
<a name="l03210"></a>03210         cout &lt;&lt; <span class="stringliteral">"X = "</span>;
<a name="l03211"></a>03211         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l03212"></a>03212           cout &lt;&lt; x[i] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l03213"></a>03213         cout &lt;&lt; endl;
<a name="l03214"></a>03214       }
<a name="l03215"></a>03215       <span class="keywordflow">if</span> (iprint &gt;= 1) cout &lt;&lt; <span class="stringliteral">" F = "</span> &lt;&lt; f &lt;&lt; endl;
<a name="l03216"></a>03216     }
<a name="l03217"></a>03217        
<a name="l03218"></a>03218   goto999:
<a name="l03219"></a>03219 
<a name="l03220"></a>03220     <span class="keywordflow">if</span> (iprint &gt;= 0)
<a name="l03221"></a>03221     {
<a name="l03222"></a>03222       cout &lt;&lt; task &lt;&lt; endl;
<a name="l03223"></a>03223       <span class="keywordflow">if</span> (info != 0)
<a name="l03224"></a>03224       {
<a name="l03225"></a>03225         <span class="keywordflow">if</span> (info == -1)
<a name="l03226"></a>03226           cout &lt;&lt; <span class="stringliteral">"Matrix in 1st Cholesky factorization in formk is not "</span> 
<a name="l03227"></a>03227                &lt;&lt; <span class="stringliteral">"Pos. Def."</span> &lt;&lt; endl;
<a name="l03228"></a>03228         <span class="keywordflow">if</span> (info == -2)
<a name="l03229"></a>03229           cout &lt;&lt; <span class="stringliteral">"Matrix in 2st Cholesky factorization in formk is not "</span>
<a name="l03230"></a>03230                &lt;&lt; <span class="stringliteral">"Pos. Def."</span> &lt;&lt; endl;
<a name="l03231"></a>03231         <span class="keywordflow">if</span> (info == -3) 
<a name="l03232"></a>03232           cout &lt;&lt; <span class="stringliteral">"Matrix in the Cholesky factorization in formt is not "</span>
<a name="l03233"></a>03233                &lt;&lt; <span class="stringliteral">"Pos. Def."</span> &lt;&lt; endl;
<a name="l03234"></a>03234         <span class="keywordflow">if</span> (info == -4)
<a name="l03235"></a>03235           cout &lt;&lt; <span class="stringliteral">"Derivative &gt;= 0, backtracking line search impossible."</span>
<a name="l03236"></a>03236                &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Previous x, f and g restored."</span> &lt;&lt; endl
<a name="l03237"></a>03237                &lt;&lt; <span class="stringliteral">"Possible causes: 1 error in function or gradient "</span>
<a name="l03238"></a>03238                &lt;&lt;<span class="stringliteral">"evaluation;"</span> &lt;&lt; endl
<a name="l03239"></a>03239                &lt;&lt; <span class="stringliteral">"2 rounding errors dominate computation."</span> &lt;&lt; endl;
<a name="l03240"></a>03240         <span class="keywordflow">if</span> (info == -5) 
<a name="l03241"></a>03241           cout &lt;&lt; <span class="stringliteral">"Warning:  more than 10 function and gradient"</span> &lt;&lt; endl
<a name="l03242"></a>03242                &lt;&lt; <span class="stringliteral">"evaluations in the last line search.  Termination"</span>
<a name="l03243"></a>03243                &lt;&lt; <span class="stringliteral">"may possibly be caused by a bad search direction."</span>&lt;&lt;endl;
<a name="l03244"></a>03244         <span class="keywordflow">if</span> (info == -6) 
<a name="l03245"></a>03245           cout &lt;&lt; <span class="stringliteral">" Input nbd("</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">") is invalid."</span>&lt;&lt;endl;
<a name="l03246"></a>03246         <span class="keywordflow">if</span> (info == -7)
<a name="l03247"></a>03247           cout &lt;&lt; <span class="stringliteral">" l("</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">") &gt; u("</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">").  No feasible solution."</span>
<a name="l03248"></a>03248                &lt;&lt; endl;
<a name="l03249"></a>03249         <span class="keywordflow">if</span> (info == -8) 
<a name="l03250"></a>03250           cout &lt;&lt; <span class="stringliteral">"The triangular system is singular"</span> &lt;&lt; endl;
<a name="l03251"></a>03251         <span class="keywordflow">if</span> (info == -9)
<a name="l03252"></a>03252           cout &lt;&lt; <span class="stringliteral">" Line search cannot locate an adequate point after"</span>&lt;&lt;endl
<a name="l03253"></a>03253                &lt;&lt; <span class="stringliteral">" 20 function and gradient evaluations. Previous x, f and"</span>
<a name="l03254"></a>03254                &lt;&lt; <span class="stringliteral">" g restored."</span> &lt;&lt; endl
<a name="l03255"></a>03255                &lt;&lt; <span class="stringliteral">"Possible causes: 1 error in function or gradient "</span>
<a name="l03256"></a>03256                &lt;&lt; <span class="stringliteral">"evaluation; 2 rounding error dominate computation"</span> 
<a name="l03257"></a>03257                &lt;&lt; endl;
<a name="l03258"></a>03258       }
<a name="l03259"></a>03259       
<a name="l03260"></a>03260       <span class="keywordflow">if</span> (iprint &gt;= 1) 
<a name="l03261"></a>03261         cout &lt;&lt; <span class="stringliteral">"Cauchy                time "</span> &lt;&lt; cachyt &lt;&lt; <span class="stringliteral">" seconds."</span>&lt;&lt;endl
<a name="l03262"></a>03262              &lt;&lt; <span class="stringliteral">"Subspace minimization time "</span> &lt;&lt; sbtime &lt;&lt; <span class="stringliteral">" seconds."</span>&lt;&lt;endl
<a name="l03263"></a>03263              &lt;&lt; <span class="stringliteral">"Line search           time "</span> &lt;&lt; lnscht &lt;&lt; <span class="stringliteral">" seconds."</span>&lt;&lt;endl;
<a name="l03264"></a>03264       
<a name="l03265"></a>03265       cout &lt;&lt; <span class="stringliteral">"Total User time "</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; endl;
<a name="l03266"></a>03266 
<a name="l03267"></a>03267       <span class="keywordflow">if</span> (iprint &gt;= 1)
<a name="l03268"></a>03268       {
<a name="l03269"></a>03269         <span class="keywordflow">if</span> (info == -4 || info == -9)
<a name="l03270"></a>03270         {              
<a name="l03271"></a>03271           *itfile &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; iter &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nfgv &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nintol 
<a name="l03272"></a>03272                  &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nskip &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; nact &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; sbgnrm &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; f
<a name="l03273"></a>03273                  &lt;&lt; endl;
<a name="l03274"></a>03274         }
<a name="l03275"></a>03275         *itfile &lt;&lt; task &lt;&lt; endl;
<a name="l03276"></a>03276         <span class="keywordflow">if</span> (info != 0)
<a name="l03277"></a>03277         {
<a name="l03278"></a>03278           <span class="keywordflow">if</span> (info == -1)
<a name="l03279"></a>03279             *itfile &lt;&lt; <span class="stringliteral">"Matrix in 1st Cholesky factorization in formk is not"</span>
<a name="l03280"></a>03280                     &lt;&lt; <span class="stringliteral">" Pos. Def."</span> &lt;&lt; endl;
<a name="l03281"></a>03281           <span class="keywordflow">if</span> (info == -2)
<a name="l03282"></a>03282             *itfile &lt;&lt; <span class="stringliteral">"Matrix in 2st Cholesky factorization in formk is not"</span>
<a name="l03283"></a>03283                     &lt;&lt; <span class="stringliteral">" Pos. Def."</span> &lt;&lt; endl;
<a name="l03284"></a>03284           <span class="keywordflow">if</span> (info == -3) 
<a name="l03285"></a>03285             *itfile &lt;&lt; <span class="stringliteral">"Matrix in the Cholesky factorization in formt is not"</span>
<a name="l03286"></a>03286                     &lt;&lt; <span class="stringliteral">" Pos. Def."</span> &lt;&lt; endl;
<a name="l03287"></a>03287           <span class="keywordflow">if</span> (info == -4)
<a name="l03288"></a>03288             *itfile &lt;&lt; <span class="stringliteral">"Derivative&gt;=0, backtracking line search impossible."</span>
<a name="l03289"></a>03289                     &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Previous x, f and g restored."</span> &lt;&lt; endl
<a name="l03290"></a>03290                     &lt;&lt; <span class="stringliteral">"Possible causes: 1 error in function or gradient "</span>
<a name="l03291"></a>03291                     &lt;&lt;<span class="stringliteral">"evaluation;"</span> &lt;&lt; endl
<a name="l03292"></a>03292                     &lt;&lt; <span class="stringliteral">"2 rounding errors dominate computation."</span> &lt;&lt; endl;
<a name="l03293"></a>03293           <span class="keywordflow">if</span> (info == -5) 
<a name="l03294"></a>03294             *itfile &lt;&lt; <span class="stringliteral">"Warning:  more than 10 function and gradient"</span> &lt;&lt; endl
<a name="l03295"></a>03295                     &lt;&lt; <span class="stringliteral">"evaluations in the last line search.  Termination"</span>
<a name="l03296"></a>03296                     &lt;&lt; <span class="stringliteral">"may possibly be caused by a bad search direction."</span>
<a name="l03297"></a>03297                     &lt;&lt; endl;
<a name="l03298"></a>03298           <span class="keywordflow">if</span> (info == -8) 
<a name="l03299"></a>03299             cout &lt;&lt; <span class="stringliteral">"The triangular system is singular"</span> &lt;&lt; endl;
<a name="l03300"></a>03300           <span class="keywordflow">if</span> (info == -9)
<a name="l03301"></a>03301             cout &lt;&lt; <span class="stringliteral">" Line search cannot locate an adequate point after"</span>
<a name="l03302"></a>03302                  &lt;&lt; endl
<a name="l03303"></a>03303                  &lt;&lt; <span class="stringliteral">" 20 function and gradient evaluations. Previous x, f "</span>
<a name="l03304"></a>03304                  &lt;&lt; <span class="stringliteral">"and g restored."</span> &lt;&lt; endl
<a name="l03305"></a>03305                  &lt;&lt; <span class="stringliteral">"Possible causes: 1 error in function or gradient "</span>
<a name="l03306"></a>03306                  &lt;&lt; <span class="stringliteral">"evaluation; 2 rounding error dominate computation"</span> 
<a name="l03307"></a>03307                  &lt;&lt; endl;
<a name="l03308"></a>03308         }
<a name="l03309"></a>03309         *itfile &lt;&lt; <span class="stringliteral">"Total User time "</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">" seconds."</span> &lt;&lt; endl;
<a name="l03310"></a>03310       }
<a name="l03311"></a>03311     }    
<a name="l03312"></a>03312   }<span class="comment">//prn3lb()</span>
<a name="l03313"></a>03313 
<a name="l03314"></a>03314   
<a name="l03315"></a>03315   <span class="comment">//   ************</span>
<a name="l03316"></a>03316   <span class="comment">//</span>
<a name="l03317"></a>03317   <span class="comment">//   Subroutine projgr</span>
<a name="l03318"></a>03318   <span class="comment">//</span>
<a name="l03319"></a>03319   <span class="comment">//   This subroutine computes the infinity norm of the projected</span>
<a name="l03320"></a>03320   <span class="comment">//     gradient.</span>
<a name="l03321"></a>03321   <span class="comment">//</span>
<a name="l03322"></a>03322   <span class="comment">//</span>
<a name="l03323"></a>03323   <span class="comment">//                         *  *  *</span>
<a name="l03324"></a>03324   <span class="comment">//</span>
<a name="l03325"></a>03325   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l03326"></a>03326   <span class="comment">//   Optimization Technology Center.</span>
<a name="l03327"></a>03327   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l03328"></a>03328   <span class="comment">//   Written by</span>
<a name="l03329"></a>03329   <span class="comment">//                      Ciyou Zhu</span>
<a name="l03330"></a>03330   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l03331"></a>03331   <span class="comment">//</span>
<a name="l03332"></a>03332   <span class="comment">//</span>
<a name="l03333"></a>03333   <span class="comment">//   ************</span>
<a name="l03334"></a>03334     <span class="comment">//functions</span>
<a name="l03335"></a>03335   <span class="keywordtype">void</span> projgr(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, 
<a name="l03336"></a>03336               <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; nbd, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, 
<a name="l03337"></a>03337               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; g, <span class="keywordtype">double</span>&amp; sbgnrm)
<a name="l03338"></a>03338   {
<a name="l03339"></a>03339     <span class="comment">//int i;</span>
<a name="l03340"></a>03340     <span class="keywordtype">double</span> gi;
<a name="l03341"></a>03341     <span class="comment">//double one=1.0;</span>
<a name="l03342"></a>03342     <span class="keywordtype">double</span> zero=0.0;
<a name="l03343"></a>03343 
<a name="l03344"></a>03344     sbgnrm = zero;
<a name="l03345"></a>03345     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l03346"></a>03346     {
<a name="l03347"></a>03347       gi = g[i];
<a name="l03348"></a>03348       <span class="keywordflow">if</span> (nbd[i] != 0)
<a name="l03349"></a>03349       {
<a name="l03350"></a>03350         <span class="keywordflow">if</span> (gi &lt; zero)
<a name="l03351"></a>03351         {
<a name="l03352"></a>03352           <span class="keywordflow">if</span> (nbd[i] &gt;= 2) gi = max((x[i]-u[i]),gi);
<a name="l03353"></a>03353         }
<a name="l03354"></a>03354         <span class="keywordflow">else</span>
<a name="l03355"></a>03355         {
<a name="l03356"></a>03356           <span class="keywordflow">if</span> (nbd[i] &lt;= 2) gi = min((x[i]-l[i]),gi);
<a name="l03357"></a>03357         }
<a name="l03358"></a>03358       }
<a name="l03359"></a>03359       sbgnrm = max(sbgnrm,fabs(gi));
<a name="l03360"></a>03360     }
<a name="l03361"></a>03361   }<span class="comment">//projgr()</span>
<a name="l03362"></a>03362 
<a name="l03363"></a>03363 
<a name="l03364"></a>03364   <span class="comment">//   ************</span>
<a name="l03365"></a>03365   <span class="comment">//</span>
<a name="l03366"></a>03366   <span class="comment">//   Subroutine subsm</span>
<a name="l03367"></a>03367   <span class="comment">//</span>
<a name="l03368"></a>03368   <span class="comment">//   Given xcp, l, u, r, an index set that specifies</span>
<a name="l03369"></a>03369   <span class="comment">//     the active set at xcp, and an l-BFGS matrix B </span>
<a name="l03370"></a>03370   <span class="comment">//     (in terms of WY, WS, SY, WT, head, col, and theta), </span>
<a name="l03371"></a>03371   <span class="comment">//     this subroutine computes an approximate solution</span>
<a name="l03372"></a>03372   <span class="comment">//     of the subspace problem</span>
<a name="l03373"></a>03373   <span class="comment">//</span>
<a name="l03374"></a>03374   <span class="comment">//    (P)   min Q(x) = r'(x-xcp) + 1/2 (x-xcp)' B (x-xcp)</span>
<a name="l03375"></a>03375   <span class="comment">//</span>
<a name="l03376"></a>03376   <span class="comment">//           subject to l&lt;=x&lt;=u</span>
<a name="l03377"></a>03377   <span class="comment">//                    x_i=xcp_i for all i in A(xcp)</span>
<a name="l03378"></a>03378   <span class="comment">//                  </span>
<a name="l03379"></a>03379   <span class="comment">//    along the subspace unconstrained Newton direction </span>
<a name="l03380"></a>03380   <span class="comment">//    </span>
<a name="l03381"></a>03381   <span class="comment">//       d = -(Z'BZ)^(-1) r.</span>
<a name="l03382"></a>03382   <span class="comment">//</span>
<a name="l03383"></a>03383   <span class="comment">//     The formula for the Newton direction, given the L-BFGS matrix</span>
<a name="l03384"></a>03384   <span class="comment">//     and the Sherman-Morrison formula, is</span>
<a name="l03385"></a>03385   <span class="comment">//</span>
<a name="l03386"></a>03386   <span class="comment">//       d = (1/theta)r + (1/theta*2) Z'WK^(-1)W'Z r.</span>
<a name="l03387"></a>03387   <span class="comment">//  </span>
<a name="l03388"></a>03388   <span class="comment">//     where</span>
<a name="l03389"></a>03389   <span class="comment">//               K = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]</span>
<a name="l03390"></a>03390   <span class="comment">//                   [L_a -R_z           theta*S'AA'S ]</span>
<a name="l03391"></a>03391   <span class="comment">//</span>
<a name="l03392"></a>03392   <span class="comment">//   Note that this procedure for computing d differs </span>
<a name="l03393"></a>03393   <span class="comment">//   from that described in [1]. One can show that the matrix K is</span>
<a name="l03394"></a>03394   <span class="comment">//   equal to the matrix M^[-1]N in that paper.</span>
<a name="l03395"></a>03395   <span class="comment">//</span>
<a name="l03396"></a>03396   <span class="comment">//   n is an integer variable.</span>
<a name="l03397"></a>03397   <span class="comment">//     On entry n is the dimension of the problem.</span>
<a name="l03398"></a>03398   <span class="comment">//     On exit n is unchanged.</span>
<a name="l03399"></a>03399   <span class="comment">//</span>
<a name="l03400"></a>03400   <span class="comment">//   m is an integer variable.</span>
<a name="l03401"></a>03401   <span class="comment">//     On entry m is the maximum number of variable metric corrections</span>
<a name="l03402"></a>03402   <span class="comment">//       used to define the limited memory matrix.</span>
<a name="l03403"></a>03403   <span class="comment">//     On exit m is unchanged.</span>
<a name="l03404"></a>03404   <span class="comment">//</span>
<a name="l03405"></a>03405   <span class="comment">//   nsub is an integer variable.</span>
<a name="l03406"></a>03406   <span class="comment">//     On entry nsub is the number of free variables.</span>
<a name="l03407"></a>03407   <span class="comment">//     On exit nsub is unchanged.</span>
<a name="l03408"></a>03408   <span class="comment">//</span>
<a name="l03409"></a>03409   <span class="comment">//   ind is an integer array of dimension nsub.</span>
<a name="l03410"></a>03410   <span class="comment">//     On entry ind specifies the coordinate indices of free variables.</span>
<a name="l03411"></a>03411   <span class="comment">//     On exit ind is unchanged.</span>
<a name="l03412"></a>03412   <span class="comment">//</span>
<a name="l03413"></a>03413   <span class="comment">//   l is a double precision array of dimension n.</span>
<a name="l03414"></a>03414   <span class="comment">//     On entry l is the lower bound of x.</span>
<a name="l03415"></a>03415   <span class="comment">//     On exit l is unchanged.</span>
<a name="l03416"></a>03416   <span class="comment">//</span>
<a name="l03417"></a>03417   <span class="comment">//   u is a double precision array of dimension n.</span>
<a name="l03418"></a>03418   <span class="comment">//     On entry u is the upper bound of x.</span>
<a name="l03419"></a>03419   <span class="comment">//     On exit u is unchanged.</span>
<a name="l03420"></a>03420   <span class="comment">//</span>
<a name="l03421"></a>03421   <span class="comment">//   nbd is a integer array of dimension n.</span>
<a name="l03422"></a>03422   <span class="comment">//     On entry nbd represents the type of bounds imposed on the</span>
<a name="l03423"></a>03423   <span class="comment">//       variables, and must be specified as follows:</span>
<a name="l03424"></a>03424   <span class="comment">//       nbd(i)=0 if x(i) is unbounded,</span>
<a name="l03425"></a>03425   <span class="comment">//              1 if x(i) has only a lower bound,</span>
<a name="l03426"></a>03426   <span class="comment">//              2 if x(i) has both lower and upper bounds, and</span>
<a name="l03427"></a>03427   <span class="comment">//              3 if x(i) has only an upper bound.</span>
<a name="l03428"></a>03428   <span class="comment">//     On exit nbd is unchanged.</span>
<a name="l03429"></a>03429   <span class="comment">//</span>
<a name="l03430"></a>03430   <span class="comment">//   x is a double precision array of dimension n.</span>
<a name="l03431"></a>03431   <span class="comment">//     On entry x specifies the Cauchy point xcp. </span>
<a name="l03432"></a>03432   <span class="comment">//     On exit x(i) is the minimizer of Q over the subspace of</span>
<a name="l03433"></a>03433   <span class="comment">//                                                      free variables. </span>
<a name="l03434"></a>03434   <span class="comment">//</span>
<a name="l03435"></a>03435   <span class="comment">//   d is a double precision array of dimension n.</span>
<a name="l03436"></a>03436   <span class="comment">//     On entry d is the reduced gradient of Q at xcp.</span>
<a name="l03437"></a>03437   <span class="comment">//     On exit d is the Newton direction of Q. </span>
<a name="l03438"></a>03438   <span class="comment">//</span>
<a name="l03439"></a>03439   <span class="comment">//   ws and wy are double precision arrays;</span>
<a name="l03440"></a>03440   <span class="comment">//   theta is a double precision variable;</span>
<a name="l03441"></a>03441   <span class="comment">//   col is an integer variable;</span>
<a name="l03442"></a>03442   <span class="comment">//   head is an integer variable.</span>
<a name="l03443"></a>03443   <span class="comment">//     On entry they store the information defining the</span>
<a name="l03444"></a>03444   <span class="comment">//                                        limited memory BFGS matrix:</span>
<a name="l03445"></a>03445   <span class="comment">//       ws(n,m) stores S, a set of s-vectors;</span>
<a name="l03446"></a>03446   <span class="comment">//       wy(n,m) stores Y, a set of y-vectors;</span>
<a name="l03447"></a>03447   <span class="comment">//       theta is the scaling factor specifying B_0 = theta I;</span>
<a name="l03448"></a>03448   <span class="comment">//       col is the number of variable metric corrections stored;</span>
<a name="l03449"></a>03449   <span class="comment">//       head is the location of the 1st s- (or y-) vector in S (or Y).</span>
<a name="l03450"></a>03450   <span class="comment">//     On exit they are unchanged.</span>
<a name="l03451"></a>03451   <span class="comment">//</span>
<a name="l03452"></a>03452   <span class="comment">//   iword is an integer variable.</span>
<a name="l03453"></a>03453   <span class="comment">//     On entry iword is unspecified.</span>
<a name="l03454"></a>03454   <span class="comment">//     On exit iword specifies the status of the subspace solution.</span>
<a name="l03455"></a>03455   <span class="comment">//       iword = 0 if the solution is in the box,</span>
<a name="l03456"></a>03456   <span class="comment">//               1 if some bound is encountered.</span>
<a name="l03457"></a>03457   <span class="comment">//</span>
<a name="l03458"></a>03458   <span class="comment">//   wv is a double precision working array of dimension 2m.</span>
<a name="l03459"></a>03459   <span class="comment">//</span>
<a name="l03460"></a>03460   <span class="comment">//   wn is a double precision array of dimension 2m x 2m.</span>
<a name="l03461"></a>03461   <span class="comment">//     On entry the upper triangle of wn stores the LEL^T factorization</span>
<a name="l03462"></a>03462   <span class="comment">//       of the indefinite matrix</span>
<a name="l03463"></a>03463   <span class="comment">//</span>
<a name="l03464"></a>03464   <span class="comment">//            k = [-D -Y'ZZ'Y/theta     L_a'-R_z'  ]</span>
<a name="l03465"></a>03465   <span class="comment">//                [L_a -R_z           theta*S'AA'S ]</span>
<a name="l03466"></a>03466   <span class="comment">//                                                  where E = [-I  0]</span>
<a name="l03467"></a>03467   <span class="comment">//                                                            [ 0  I]</span>
<a name="l03468"></a>03468   <span class="comment">//     On exit wn is unchanged.</span>
<a name="l03469"></a>03469   <span class="comment">//</span>
<a name="l03470"></a>03470   <span class="comment">//   iprint is an INTEGER variable that must be set by the user.</span>
<a name="l03471"></a>03471   <span class="comment">//     It controls the frequency and type of output generated:</span>
<a name="l03472"></a>03472   <span class="comment">//      iprint&lt;0    no output is generated;</span>
<a name="l03473"></a>03473   <span class="comment">//      iprint=0    print only one line at the last iteration;</span>
<a name="l03474"></a>03474   <span class="comment">//      0&lt;iprint&lt;99 print also f and |proj g| every iprint iterations;</span>
<a name="l03475"></a>03475   <span class="comment">//      iprint=99   print details of every iteration except n-vectors;</span>
<a name="l03476"></a>03476   <span class="comment">//      iprint=100  print also the changes of active set and final x;</span>
<a name="l03477"></a>03477   <span class="comment">//      iprint&gt;100  print details of every iteration including x and g;</span>
<a name="l03478"></a>03478   <span class="comment">//     When iprint &gt; 0, the file iterate.dat will be created to</span>
<a name="l03479"></a>03479   <span class="comment">//                      summarize the iteration.</span>
<a name="l03480"></a>03480   <span class="comment">//</span>
<a name="l03481"></a>03481   <span class="comment">//   info is an integer variable.</span>
<a name="l03482"></a>03482   <span class="comment">//     On entry info is unspecified.</span>
<a name="l03483"></a>03483   <span class="comment">//     On exit info = 0       for normal return,</span>
<a name="l03484"></a>03484   <span class="comment">//                  = nonzero for abnormal return </span>
<a name="l03485"></a>03485   <span class="comment">//                                when the matrix K is ill-conditioned.</span>
<a name="l03486"></a>03486   <span class="comment">//</span>
<a name="l03487"></a>03487   <span class="comment">//   Subprograms called:</span>
<a name="l03488"></a>03488   <span class="comment">//</span>
<a name="l03489"></a>03489   <span class="comment">//     Linpack dtrsl.</span>
<a name="l03490"></a>03490   <span class="comment">//</span>
<a name="l03491"></a>03491   <span class="comment">//</span>
<a name="l03492"></a>03492   <span class="comment">//   References:</span>
<a name="l03493"></a>03493   <span class="comment">//</span>
<a name="l03494"></a>03494   <span class="comment">//     [1] R. H. Byrd, P. Lu, J. Nocedal and C. Zhu, ``A limited</span>
<a name="l03495"></a>03495   <span class="comment">//     memory algorithm for bound constrained optimization'',</span>
<a name="l03496"></a>03496   <span class="comment">//     SIAM J. Scientific Computing 16 (1995), no. 5, pp. 1190--1208.</span>
<a name="l03497"></a>03497   <span class="comment">//</span>
<a name="l03498"></a>03498   <span class="comment">//</span>
<a name="l03499"></a>03499   <span class="comment">//</span>
<a name="l03500"></a>03500   <span class="comment">//                         *  *  *</span>
<a name="l03501"></a>03501   <span class="comment">//</span>
<a name="l03502"></a>03502   <span class="comment">//   NEOS, November 1994. (Latest revision June 1996.)</span>
<a name="l03503"></a>03503   <span class="comment">//   Optimization Technology Center.</span>
<a name="l03504"></a>03504   <span class="comment">//   Argonne National Laboratory and Northwestern University.</span>
<a name="l03505"></a>03505   <span class="comment">//   Written by</span>
<a name="l03506"></a>03506   <span class="comment">//                      Ciyou Zhu</span>
<a name="l03507"></a>03507   <span class="comment">//   in collaboration with R.H. Byrd, P. Lu-Chen and J. Nocedal.</span>
<a name="l03508"></a>03508   <span class="comment">//</span>
<a name="l03509"></a>03509   <span class="comment">//</span>
<a name="l03510"></a>03510   <span class="comment">//   ************</span>
<a name="l03511"></a>03511     <span class="comment">//function</span>
<a name="l03512"></a>03512   <span class="keywordtype">void</span> subsm(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; m, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; nsub, <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span>&amp; ind,
<a name="l03513"></a>03513              <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; l, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; u, 
<a name="l03514"></a>03514              <span class="keyword">const</span> <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; nbd, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; d, 
<a name="l03515"></a>03515              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; ws, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wy, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; theta, 
<a name="l03516"></a>03516              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; col, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; head, <span class="keywordtype">int</span>&amp; iword, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wv, 
<a name="l03517"></a>03517              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wn, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; iprint, <span class="keywordtype">int</span>&amp; info) 
<a name="l03518"></a>03518   {
<a name="l03519"></a>03519     <span class="comment">//int jy,i,j;</span>
<a name="l03520"></a>03520     <span class="keywordtype">int</span> pointr,m2,col2,ibd=0,js,k;
<a name="l03521"></a>03521     <span class="keywordtype">double</span> alpha,dk,temp1,temp2;
<a name="l03522"></a>03522     <span class="keywordtype">double</span> one=1.0,zero=0.0;
<a name="l03523"></a>03523     <span class="keywordtype">int</span> idx;
<a name="l03524"></a>03524 
<a name="l03525"></a>03525     <span class="keywordflow">if</span> (nsub &lt;= 0) <span class="keywordflow">return</span>;
<a name="l03526"></a>03526     <span class="keywordflow">if</span> (iprint &gt;= 99) 
<a name="l03527"></a>03527       cout &lt;&lt; <span class="stringliteral">"----------------SUBSM entered-----------------"</span> &lt;&lt; endl;
<a name="l03528"></a>03528 
<a name="l03529"></a>03529     <span class="comment">//Compute wv = W'Zd.</span>
<a name="l03530"></a>03530 
<a name="l03531"></a>03531     pointr = head;
<a name="l03532"></a>03532     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= col; i++)
<a name="l03533"></a>03533     {
<a name="l03534"></a>03534       temp1 = zero;
<a name="l03535"></a>03535       temp2 = zero;
<a name="l03536"></a>03536       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= nsub; j++)
<a name="l03537"></a>03537       {
<a name="l03538"></a>03538         k = ind[j];
<a name="l03539"></a>03539         idx = getIdx(k,pointr,n);
<a name="l03540"></a>03540         temp1 += wy[idx]*d[j];
<a name="l03541"></a>03541         temp2 += ws[idx]*d[j];
<a name="l03542"></a>03542       }
<a name="l03543"></a>03543       wv[i] = temp1;
<a name="l03544"></a>03544       wv[col + i] = theta*temp2;
<a name="l03545"></a>03545       pointr = pointr%m + 1;
<a name="l03546"></a>03546     }
<a name="l03547"></a>03547 
<a name="l03548"></a>03548 
<a name="l03549"></a>03549     <span class="comment">//Compute wv:=K^(-1)wv.</span>
<a name="l03550"></a>03550 
<a name="l03551"></a>03551     m2 = 2*m;
<a name="l03552"></a>03552     col2 = 2*col;
<a name="l03553"></a>03553     dtrsl(wn,m2,col2,wv,11,info);
<a name="l03554"></a>03554 
<a name="l03555"></a>03555     <span class="keywordflow">if</span> (info != 0) <span class="keywordflow">return</span>;
<a name="l03556"></a>03556     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= col; i++)
<a name="l03557"></a>03557       wv[i] = -wv[i];
<a name="l03558"></a>03558     dtrsl(wn,m2,col2,wv,01,info);
<a name="l03559"></a>03559 
<a name="l03560"></a>03560     <span class="keywordflow">if</span> (info != 0) <span class="keywordflow">return</span>;
<a name="l03561"></a>03561  
<a name="l03562"></a>03562     <span class="comment">//Compute d = (1/theta)d + (1/theta**2)Z'W wv.</span>
<a name="l03563"></a>03563  
<a name="l03564"></a>03564     pointr = head;
<a name="l03565"></a>03565     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jy = 1; jy &lt;= col; jy++)
<a name="l03566"></a>03566     {
<a name="l03567"></a>03567       js = col + jy;
<a name="l03568"></a>03568       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nsub; i++)        
<a name="l03569"></a>03569       {
<a name="l03570"></a>03570         k = ind[i];
<a name="l03571"></a>03571         idx = getIdx(k,pointr,n);
<a name="l03572"></a>03572         d[i] += wy[idx]*wv[jy]/theta + ws[idx]*wv[js];
<a name="l03573"></a>03573       }
<a name="l03574"></a>03574       pointr = pointr%m + 1;
<a name="l03575"></a>03575     }
<a name="l03576"></a>03576 
<a name="l03577"></a>03577     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nsub; i++)
<a name="l03578"></a>03578       d[i] /= theta;
<a name="l03579"></a>03579  
<a name="l03580"></a>03580     <span class="comment">//Backtrack to the feasible region.</span>
<a name="l03581"></a>03581  
<a name="l03582"></a>03582     alpha = one;
<a name="l03583"></a>03583     temp1 = alpha;
<a name="l03584"></a>03584 
<a name="l03585"></a>03585     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nsub; i++)
<a name="l03586"></a>03586     {
<a name="l03587"></a>03587       k = ind[i];
<a name="l03588"></a>03588       dk = d[i];
<a name="l03589"></a>03589       <span class="keywordflow">if</span> (nbd[k] != 0)
<a name="l03590"></a>03590       {
<a name="l03591"></a>03591             <span class="keywordflow">if</span> (dk &lt; zero &amp;&amp; nbd[k] &lt;= 2)
<a name="l03592"></a>03592         {
<a name="l03593"></a>03593                 temp2 = l[k] - x[k];
<a name="l03594"></a>03594                 <span class="keywordflow">if</span> (temp2 &gt;= zero)
<a name="l03595"></a>03595                       temp1 = zero;
<a name="l03596"></a>03596                 <span class="keywordflow">else</span> 
<a name="l03597"></a>03597           <span class="keywordflow">if</span> (dk*alpha &lt; temp2)
<a name="l03598"></a>03598                         temp1 = temp2/dk;               
<a name="l03599"></a>03599         }
<a name="l03600"></a>03600             <span class="keywordflow">else</span> 
<a name="l03601"></a>03601         <span class="keywordflow">if</span> (dk &gt; zero &amp;&amp; nbd[k] &gt;= 2)
<a name="l03602"></a>03602         {
<a name="l03603"></a>03603                 temp2 = u[k] - x[k];
<a name="l03604"></a>03604                 <span class="keywordflow">if</span> (temp2 &lt;= zero)
<a name="l03605"></a>03605                         temp1 = zero;
<a name="l03606"></a>03606           <span class="keywordflow">else</span>
<a name="l03607"></a>03607           <span class="keywordflow">if</span> (dk*alpha &gt; temp2)
<a name="l03608"></a>03608                         temp1 = temp2/dk;
<a name="l03609"></a>03609         }
<a name="l03610"></a>03610         <span class="keywordflow">if</span> (temp1 &lt; alpha)
<a name="l03611"></a>03611         {
<a name="l03612"></a>03612                 alpha = temp1;
<a name="l03613"></a>03613                 ibd = i;
<a name="l03614"></a>03614         }
<a name="l03615"></a>03615       }
<a name="l03616"></a>03616     }
<a name="l03617"></a>03617 
<a name="l03618"></a>03618 
<a name="l03619"></a>03619     <span class="keywordflow">if</span> (alpha &lt; one)
<a name="l03620"></a>03620     {
<a name="l03621"></a>03621       dk = d[ibd];
<a name="l03622"></a>03622       k = ind[ibd];
<a name="l03623"></a>03623       <span class="keywordflow">if</span> (dk &gt; zero)
<a name="l03624"></a>03624       {
<a name="l03625"></a>03625         x[k] = u[k];
<a name="l03626"></a>03626         d[ibd] = zero;
<a name="l03627"></a>03627       }
<a name="l03628"></a>03628       <span class="keywordflow">else</span> 
<a name="l03629"></a>03629       <span class="keywordflow">if</span> (dk &lt; zero)
<a name="l03630"></a>03630       {
<a name="l03631"></a>03631         x[k] = l[k];
<a name="l03632"></a>03632         d[ibd] = zero;
<a name="l03633"></a>03633       }
<a name="l03634"></a>03634     }
<a name="l03635"></a>03635 
<a name="l03636"></a>03636     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nsub; i++)
<a name="l03637"></a>03637     {
<a name="l03638"></a>03638       k = ind[i];
<a name="l03639"></a>03639       x[k] += alpha*d[i];
<a name="l03640"></a>03640     } 
<a name="l03641"></a>03641     
<a name="l03642"></a>03642     <span class="keywordflow">if</span> (iprint &gt;= 99)
<a name="l03643"></a>03643     {
<a name="l03644"></a>03644       <span class="keywordflow">if</span> (alpha &lt; one)
<a name="l03645"></a>03645         cout &lt;&lt; <span class="stringliteral">"ALPHA = "</span> &lt;&lt; alpha &lt;&lt; <span class="stringliteral">" backtrack to the BOX"</span> &lt;&lt; endl;
<a name="l03646"></a>03646       <span class="keywordflow">else</span>
<a name="l03647"></a>03647         cout  &lt;&lt; <span class="stringliteral">"SM solution inside the box"</span> &lt;&lt; endl;
<a name="l03648"></a>03648 
<a name="l03649"></a>03649       <span class="keywordflow">if</span> (iprint &gt;100)
<a name="l03650"></a>03650       {
<a name="l03651"></a>03651         cout &lt;&lt; <span class="stringliteral">"Subspace solution X = "</span>;
<a name="l03652"></a>03652         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++) cout &lt;&lt; x[i] &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l03653"></a>03653         cout &lt;&lt; endl;
<a name="l03654"></a>03654       }
<a name="l03655"></a>03655     }
<a name="l03656"></a>03656  
<a name="l03657"></a>03657     <span class="keywordflow">if</span> (alpha &lt; one)
<a name="l03658"></a>03658       iword = 1;
<a name="l03659"></a>03659     <span class="keywordflow">else</span>
<a name="l03660"></a>03660       iword = 0;
<a name="l03661"></a>03661 
<a name="l03662"></a>03662     <span class="keywordflow">if</span> (iprint &gt;= 99) 
<a name="l03663"></a>03663       cout &lt;&lt; <span class="stringliteral">"----------------exit SUBSM --------------------"</span> &lt;&lt; endl;    
<a name="l03664"></a>03664   }<span class="comment">//subsm()</span>
<a name="l03665"></a>03665 
<a name="l03666"></a>03666 
<a name="l03667"></a>03667   <span class="comment">//   **********</span>
<a name="l03668"></a>03668   <span class="comment">//</span>
<a name="l03669"></a>03669   <span class="comment">//   Subroutine dcsrch</span>
<a name="l03670"></a>03670   <span class="comment">//</span>
<a name="l03671"></a>03671   <span class="comment">//   This subroutine finds a step that satisfies a sufficient</span>
<a name="l03672"></a>03672   <span class="comment">//   decrease condition and a curvature condition.</span>
<a name="l03673"></a>03673   <span class="comment">//</span>
<a name="l03674"></a>03674   <span class="comment">//   Each call of the subroutine updates an interval with </span>
<a name="l03675"></a>03675   <span class="comment">//   endpoints stx and sty. The interval is initially chosen </span>
<a name="l03676"></a>03676   <span class="comment">//   so that it contains a minimizer of the modified function</span>
<a name="l03677"></a>03677   <span class="comment">//</span>
<a name="l03678"></a>03678   <span class="comment">//         psi(stp) = f(stp) - f(0) - ftol*stp*f'(0).</span>
<a name="l03679"></a>03679   <span class="comment">//</span>
<a name="l03680"></a>03680   <span class="comment">//   If psi(stp) &lt;= 0 and f'(stp) &gt;= 0 for some step, then the</span>
<a name="l03681"></a>03681   <span class="comment">//   interval is chosen so that it contains a minimizer of f. </span>
<a name="l03682"></a>03682   <span class="comment">//</span>
<a name="l03683"></a>03683   <span class="comment">//   The algorithm is designed to find a step that satisfies </span>
<a name="l03684"></a>03684   <span class="comment">//   the sufficient decrease condition </span>
<a name="l03685"></a>03685   <span class="comment">//</span>
<a name="l03686"></a>03686   <span class="comment">//         f(stp) &lt;= f(0) + ftol*stp*f'(0),</span>
<a name="l03687"></a>03687   <span class="comment">//</span>
<a name="l03688"></a>03688   <span class="comment">//   and the curvature condition</span>
<a name="l03689"></a>03689   <span class="comment">//</span>
<a name="l03690"></a>03690   <span class="comment">//         abs(f'(stp)) &lt;= gtol*abs(f'(0)).</span>
<a name="l03691"></a>03691   <span class="comment">//</span>
<a name="l03692"></a>03692   <span class="comment">//   If ftol is less than gtol and if, for example, the function</span>
<a name="l03693"></a>03693   <span class="comment">//   is bounded below, then there is always a step which satisfies</span>
<a name="l03694"></a>03694   <span class="comment">//   both conditions. </span>
<a name="l03695"></a>03695   <span class="comment">//</span>
<a name="l03696"></a>03696   <span class="comment">//   If no step can be found that satisfies both conditions, then </span>
<a name="l03697"></a>03697   <span class="comment">//   the algorithm stops with a warning. In this case stp only </span>
<a name="l03698"></a>03698   <span class="comment">//   satisfies the sufficient decrease condition.</span>
<a name="l03699"></a>03699   <span class="comment">//</span>
<a name="l03700"></a>03700   <span class="comment">//   A typical invocation of dcsrch has the following outline:</span>
<a name="l03701"></a>03701   <span class="comment">//</span>
<a name="l03702"></a>03702   <span class="comment">//   task = 'START'</span>
<a name="l03703"></a>03703   <span class="comment">//  10 continue</span>
<a name="l03704"></a>03704   <span class="comment">//      call dcsrch( ... )</span>
<a name="l03705"></a>03705   <span class="comment">//      if (task == 'FG') then</span>
<a name="l03706"></a>03706   <span class="comment">//         Evaluate the function and the gradient at stp </span>
<a name="l03707"></a>03707   <span class="comment">//         goto 10</span>
<a name="l03708"></a>03708   <span class="comment">//         end if</span>
<a name="l03709"></a>03709   <span class="comment">//</span>
<a name="l03710"></a>03710   <span class="comment">//   NOTE: The user must no alter work arrays between calls.</span>
<a name="l03711"></a>03711   <span class="comment">//</span>
<a name="l03712"></a>03712   <span class="comment">//   The subroutine statement is</span>
<a name="l03713"></a>03713   <span class="comment">//</span>
<a name="l03714"></a>03714   <span class="comment">//      subroutine dcsrch(f,g,stp,ftol,gtol,xtol,stpmin,stpmax,</span>
<a name="l03715"></a>03715   <span class="comment">//                        task,isave,dsave)</span>
<a name="l03716"></a>03716   <span class="comment">//   where</span>
<a name="l03717"></a>03717   <span class="comment">//</span>
<a name="l03718"></a>03718   <span class="comment">//     f is a double precision variable.</span>
<a name="l03719"></a>03719   <span class="comment">//       On initial entry f is the value of the function at 0.</span>
<a name="l03720"></a>03720   <span class="comment">//          On subsequent entries f is the value of the </span>
<a name="l03721"></a>03721   <span class="comment">//          function at stp.</span>
<a name="l03722"></a>03722   <span class="comment">//       On exit f is the value of the function at stp.</span>
<a name="l03723"></a>03723   <span class="comment">//</span>
<a name="l03724"></a>03724   <span class="comment">//    g is a double precision variable.</span>
<a name="l03725"></a>03725   <span class="comment">//       On initial entry g is the derivative of the function at 0.</span>
<a name="l03726"></a>03726   <span class="comment">//          On subsequent entries g is the derivative of the </span>
<a name="l03727"></a>03727   <span class="comment">//          function at stp.</span>
<a name="l03728"></a>03728   <span class="comment">//       On exit g is the derivative of the function at stp.</span>
<a name="l03729"></a>03729   <span class="comment">//</span>
<a name="l03730"></a>03730   <span class="comment">//    stp is a double precision variable. </span>
<a name="l03731"></a>03731   <span class="comment">//       On entry stp is the current estimate of a satisfactory </span>
<a name="l03732"></a>03732   <span class="comment">//          step. On initial entry, a positive initial estimate </span>
<a name="l03733"></a>03733   <span class="comment">//          must be provided. </span>
<a name="l03734"></a>03734   <span class="comment">//       On exit stp is the current estimate of a satisfactory step</span>
<a name="l03735"></a>03735   <span class="comment">//          if task = 'FG'. If task = 'CONV' then stp satisfies</span>
<a name="l03736"></a>03736   <span class="comment">//          the sufficient decrease and curvature condition.</span>
<a name="l03737"></a>03737   <span class="comment">//</span>
<a name="l03738"></a>03738   <span class="comment">//     ftol is a double precision variable.</span>
<a name="l03739"></a>03739   <span class="comment">//       On entry ftol specifies a nonnegative tolerance for the </span>
<a name="l03740"></a>03740   <span class="comment">//          sufficient decrease condition.</span>
<a name="l03741"></a>03741   <span class="comment">//       On exit ftol is unchanged.</span>
<a name="l03742"></a>03742   <span class="comment">//</span>
<a name="l03743"></a>03743   <span class="comment">//     gtol is a double precision variable.</span>
<a name="l03744"></a>03744   <span class="comment">//       On entry gtol specifies a nonnegative tolerance for the </span>
<a name="l03745"></a>03745   <span class="comment">//          curvature condition. </span>
<a name="l03746"></a>03746   <span class="comment">//       On exit gtol is unchanged.</span>
<a name="l03747"></a>03747   <span class="comment">//</span>
<a name="l03748"></a>03748   <span class="comment">//    xtol is a double precision variable.</span>
<a name="l03749"></a>03749   <span class="comment">//       On entry xtol specifies a nonnegative relative tolerance</span>
<a name="l03750"></a>03750   <span class="comment">//          for an acceptable step. The subroutine exits with a</span>
<a name="l03751"></a>03751   <span class="comment">//          warning if the relative difference between sty and stx</span>
<a name="l03752"></a>03752   <span class="comment">//          is less than xtol.</span>
<a name="l03753"></a>03753   <span class="comment">//       On exit xtol is unchanged.</span>
<a name="l03754"></a>03754   <span class="comment">//</span>
<a name="l03755"></a>03755   <span class="comment">//    stpmin is a double precision variable.</span>
<a name="l03756"></a>03756   <span class="comment">//       On entry stpmin is a nonnegative lower bound for the step.</span>
<a name="l03757"></a>03757   <span class="comment">//       On exit stpmin is unchanged.</span>
<a name="l03758"></a>03758   <span class="comment">//</span>
<a name="l03759"></a>03759   <span class="comment">//    stpmax is a double precision variable.</span>
<a name="l03760"></a>03760   <span class="comment">//       On entry stpmax is a nonnegative upper bound for the step.</span>
<a name="l03761"></a>03761   <span class="comment">//       On exit stpmax is unchanged.</span>
<a name="l03762"></a>03762   <span class="comment">//</span>
<a name="l03763"></a>03763   <span class="comment">//     task is a character variable of length at least 60.</span>
<a name="l03764"></a>03764   <span class="comment">//       On initial entry task must be set to 'START'.</span>
<a name="l03765"></a>03765   <span class="comment">//       On exit task indicates the required action:</span>
<a name="l03766"></a>03766   <span class="comment">//</span>
<a name="l03767"></a>03767   <span class="comment">//          If task(1:2) = 'FG' then evaluate the function and </span>
<a name="l03768"></a>03768   <span class="comment">//          derivative at stp and call dcsrch again.</span>
<a name="l03769"></a>03769   <span class="comment">//</span>
<a name="l03770"></a>03770   <span class="comment">//          If task(1:4) = 'CONV' then the search is successful.</span>
<a name="l03771"></a>03771   <span class="comment">//</span>
<a name="l03772"></a>03772   <span class="comment">//          If task(1:4) = 'WARN' then the subroutine is not able</span>
<a name="l03773"></a>03773   <span class="comment">//          to satisfy the convergence conditions. The exit value of</span>
<a name="l03774"></a>03774   <span class="comment">//          stp contains the best point found during the search.</span>
<a name="l03775"></a>03775   <span class="comment">//</span>
<a name="l03776"></a>03776   <span class="comment">//          If task(1:5) = 'ERROR' then there is an error in the</span>
<a name="l03777"></a>03777   <span class="comment">//          input arguments.</span>
<a name="l03778"></a>03778   <span class="comment">//</span>
<a name="l03779"></a>03779   <span class="comment">//       On exit with convergence, a warning or an error, the</span>
<a name="l03780"></a>03780   <span class="comment">//          variable task contains additional information.</span>
<a name="l03781"></a>03781   <span class="comment">//</span>
<a name="l03782"></a>03782   <span class="comment">//     isave is an integer work array of dimension 2.</span>
<a name="l03783"></a>03783   <span class="comment">//       </span>
<a name="l03784"></a>03784   <span class="comment">//     dsave is a double precision work array of dimension 13.</span>
<a name="l03785"></a>03785   <span class="comment">//</span>
<a name="l03786"></a>03786   <span class="comment">//   Subprograms called</span>
<a name="l03787"></a>03787   <span class="comment">//</span>
<a name="l03788"></a>03788   <span class="comment">//     MINPACK-2 ... dcstep</span>
<a name="l03789"></a>03789   <span class="comment">//</span>
<a name="l03790"></a>03790   <span class="comment">//   MINPACK-1 Project. June 1983.</span>
<a name="l03791"></a>03791   <span class="comment">//   Argonne National Laboratory. </span>
<a name="l03792"></a>03792   <span class="comment">//   Jorge J. More' and David J. Thuente.</span>
<a name="l03793"></a>03793   <span class="comment">//</span>
<a name="l03794"></a>03794   <span class="comment">//   MINPACK-2 Project. October 1993.</span>
<a name="l03795"></a>03795   <span class="comment">//   Argonne National Laboratory and University of Minnesota. </span>
<a name="l03796"></a>03796   <span class="comment">//   Brett M. Averick, Richard G. Carter, and Jorge J. More'. </span>
<a name="l03797"></a>03797   <span class="comment">//</span>
<a name="l03798"></a>03798   <span class="comment">//   **********</span>
<a name="l03799"></a>03799     <span class="comment">//function</span>
<a name="l03800"></a>03800   <span class="keywordtype">void</span> dcsrch(<span class="keywordtype">double</span>&amp; f, <span class="keywordtype">double</span>&amp; g, <span class="keywordtype">double</span>&amp; stp, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; ftol, 
<a name="l03801"></a>03801               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; gtol, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; xtol, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; stpmin, 
<a name="l03802"></a>03802               <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; stpmax, <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; task, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; isave, 
<a name="l03803"></a>03803               <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dsave)
<a name="l03804"></a>03804   {
<a name="l03805"></a>03805     <span class="keywordtype">double</span> zero=0.0,p5=0.5,p66=0.66;
<a name="l03806"></a>03806     <span class="keywordtype">double</span> xtrapl=1.1,xtrapu=4.0;
<a name="l03807"></a>03807     
<a name="l03808"></a>03808     <span class="keywordtype">bool</span> brackt;
<a name="l03809"></a>03809     <span class="keywordtype">int</span> stage;
<a name="l03810"></a>03810     <span class="keywordtype">double</span> finit,ftest,fm,fx,fxm,fy,fym,ginit,gtest,
<a name="l03811"></a>03811            gm,gx,gxm,gy,gym,stx,sty,stmin,stmax,width,width1;
<a name="l03812"></a>03812 
<a name="l03813"></a>03813     <span class="comment">//Initialization block.</span>
<a name="l03814"></a>03814 
<a name="l03815"></a>03815     <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"START"</span>,5)==0)
<a name="l03816"></a>03816     {
<a name="l03817"></a>03817       <span class="comment">//Check the input arguments for errors.</span>
<a name="l03818"></a>03818 
<a name="l03819"></a>03819       <span class="keywordflow">if</span> (stp &lt; stpmin)    strcpy(task, <span class="stringliteral">"ERROR: STP &lt; STPMIN"</span>);
<a name="l03820"></a>03820       <span class="keywordflow">if</span> (stp &gt; stpmax)    strcpy(task, <span class="stringliteral">"ERROR: STP &gt; STPMAX"</span>);
<a name="l03821"></a>03821       <span class="keywordflow">if</span> (g &gt;zero)         strcpy(task, <span class="stringliteral">"ERROR: INITIAL G &gt;ZERO"</span>);
<a name="l03822"></a>03822       <span class="keywordflow">if</span> (ftol &lt; zero)     strcpy(task, <span class="stringliteral">"ERROR: FTOL &lt; ZERO"</span>);
<a name="l03823"></a>03823       <span class="keywordflow">if</span> (gtol &lt; zero)     strcpy(task, <span class="stringliteral">"ERROR: GTOL &lt; ZERO"</span>);
<a name="l03824"></a>03824       <span class="keywordflow">if</span> (xtol &lt; zero)     strcpy(task, <span class="stringliteral">"ERROR: XTOL &lt; ZERO"</span>);
<a name="l03825"></a>03825       <span class="keywordflow">if</span> (stpmin &lt; zero)   strcpy(task, <span class="stringliteral">"ERROR: STPMIN &lt; ZERO"</span>);
<a name="l03826"></a>03826       <span class="keywordflow">if</span> (stpmax &lt; stpmin) strcpy(task, <span class="stringliteral">"ERROR: STPMAX &lt; STPMIN"</span>);
<a name="l03827"></a>03827 
<a name="l03828"></a>03828       <span class="comment">//Exit if there are errors on input.</span>
<a name="l03829"></a>03829       <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"ERROR"</span>,5)==0) <span class="keywordflow">return</span>;
<a name="l03830"></a>03830       
<a name="l03831"></a>03831       <span class="comment">//Initialize local variables.</span>
<a name="l03832"></a>03832 
<a name="l03833"></a>03833       brackt = <span class="keyword">false</span>;
<a name="l03834"></a>03834       stage = 1;
<a name="l03835"></a>03835       finit = f;
<a name="l03836"></a>03836       ginit = g;
<a name="l03837"></a>03837       gtest = ftol*ginit;
<a name="l03838"></a>03838       width = stpmax - stpmin;
<a name="l03839"></a>03839       width1 = width/p5;
<a name="l03840"></a>03840 
<a name="l03841"></a>03841       <span class="comment">//The variables stx, fx, gx contain the values of the step, </span>
<a name="l03842"></a>03842       <span class="comment">//function, and derivative at the best step. </span>
<a name="l03843"></a>03843       <span class="comment">//The variables sty, fy, gy contain the value of the step, </span>
<a name="l03844"></a>03844       <span class="comment">//function, and derivative at sty.</span>
<a name="l03845"></a>03845       <span class="comment">//The variables stp, f, g contain the values of the step, </span>
<a name="l03846"></a>03846       <span class="comment">//function, and derivative at stp.</span>
<a name="l03847"></a>03847       
<a name="l03848"></a>03848       stx = zero;
<a name="l03849"></a>03849       fx = finit;
<a name="l03850"></a>03850       gx = ginit;
<a name="l03851"></a>03851       sty = zero;
<a name="l03852"></a>03852       fy = finit;
<a name="l03853"></a>03853       gy = ginit;
<a name="l03854"></a>03854       stmin = zero;
<a name="l03855"></a>03855       stmax = stp + xtrapu*stp;
<a name="l03856"></a>03856       strcpy(task, <span class="stringliteral">"FG"</span>);
<a name="l03857"></a>03857 
<a name="l03858"></a>03858       <span class="keywordflow">goto</span> goto1000;
<a name="l03859"></a>03859     }
<a name="l03860"></a>03860     <span class="keywordflow">else</span>
<a name="l03861"></a>03861     {
<a name="l03862"></a>03862       <span class="comment">//Restore local variables.</span>
<a name="l03863"></a>03863       
<a name="l03864"></a>03864       <span class="keywordflow">if</span> (isave[1] == 1)
<a name="l03865"></a>03865         brackt = <span class="keyword">true</span>;
<a name="l03866"></a>03866       <span class="keywordflow">else</span>
<a name="l03867"></a>03867         brackt = <span class="keyword">false</span>;
<a name="l03868"></a>03868       
<a name="l03869"></a>03869       stage  = isave[2]; 
<a name="l03870"></a>03870       ginit  = dsave[1]; 
<a name="l03871"></a>03871       gtest  = dsave[2]; 
<a name="l03872"></a>03872       gx     = dsave[3]; 
<a name="l03873"></a>03873       gy     = dsave[4]; 
<a name="l03874"></a>03874       finit  = dsave[5]; 
<a name="l03875"></a>03875       fx     = dsave[6]; 
<a name="l03876"></a>03876       fy     = dsave[7]; 
<a name="l03877"></a>03877       stx    = dsave[8]; 
<a name="l03878"></a>03878       sty    = dsave[9]; 
<a name="l03879"></a>03879       stmin  = dsave[10]; 
<a name="l03880"></a>03880       stmax  = dsave[11]; 
<a name="l03881"></a>03881       width  = dsave[12]; 
<a name="l03882"></a>03882       width1 = dsave[13]; 
<a name="l03883"></a>03883     }
<a name="l03884"></a>03884 
<a name="l03885"></a>03885     <span class="comment">//If psi(stp) &lt;= 0 and f'(stp) &gt;= 0 for some step, then the</span>
<a name="l03886"></a>03886     <span class="comment">//algorithm enters the second stage.</span>
<a name="l03887"></a>03887 
<a name="l03888"></a>03888     ftest = finit + stp*gtest;
<a name="l03889"></a>03889     <span class="keywordflow">if</span> (stage == 1 &amp;&amp; f &lt;= ftest &amp;&amp; g &gt;= zero) stage = 2;
<a name="l03890"></a>03890 
<a name="l03891"></a>03891     <span class="comment">//Test for warnings.</span>
<a name="l03892"></a>03892 
<a name="l03893"></a>03893     <span class="keywordflow">if</span> (brackt &amp;&amp; (stp &lt;= stmin || stp &gt;= stmax))
<a name="l03894"></a>03894       strcpy(task, <span class="stringliteral">"WARNING: ROUNDING ERRORS PREVENT PROGRESS"</span>);
<a name="l03895"></a>03895     <span class="keywordflow">if</span> (brackt &amp;&amp; stmax - stmin &lt;= xtol*stmax) 
<a name="l03896"></a>03896       strcpy(task, <span class="stringliteral">"WARNING: XTOL TEST SATISFIED"</span>);
<a name="l03897"></a>03897     <span class="keywordflow">if</span> (stp == stpmax &amp;&amp; f &lt;= ftest &amp;&amp; g &lt;= gtest) 
<a name="l03898"></a>03898       strcpy(task, <span class="stringliteral">"WARNING: STP = STPMAX"</span>);
<a name="l03899"></a>03899     <span class="keywordflow">if</span> (stp == stpmin &amp;&amp; (f &gt; ftest || g &gt;= gtest)) 
<a name="l03900"></a>03900       strcpy(task, <span class="stringliteral">"WARNING: STP = STPMIN"</span>);
<a name="l03901"></a>03901     
<a name="l03902"></a>03902     <span class="comment">//Test for convergence.</span>
<a name="l03903"></a>03903     
<a name="l03904"></a>03904     <span class="keywordflow">if</span> (f &lt;= ftest &amp;&amp; fabs(g) &lt;= gtol*(-ginit)) 
<a name="l03905"></a>03905       strcpy(task, <span class="stringliteral">"CONVERGENCE"</span>);
<a name="l03906"></a>03906     
<a name="l03907"></a>03907     <span class="comment">//Test for termination.</span>
<a name="l03908"></a>03908     
<a name="l03909"></a>03909     <span class="keywordflow">if</span> (strncmp(task,<span class="stringliteral">"WARN"</span>,4)==0 || strncmp(task,<span class="stringliteral">"CONV"</span>,4)==0) <span class="keywordflow">goto</span> goto1000;
<a name="l03910"></a>03910     
<a name="l03911"></a>03911     <span class="comment">//A modified function is used to predict the step during the</span>
<a name="l03912"></a>03912     <span class="comment">//first stage if a lower function value has been obtained but </span>
<a name="l03913"></a>03913     <span class="comment">//the decrease is not sufficient.</span>
<a name="l03914"></a>03914     
<a name="l03915"></a>03915     <span class="keywordflow">if</span> (stage == 1 &amp;&amp; f &lt;= fx &amp;&amp; f &gt; ftest)
<a name="l03916"></a>03916     {
<a name="l03917"></a>03917       <span class="comment">//Define the modified function and derivative values.</span>
<a name="l03918"></a>03918       
<a name="l03919"></a>03919       fm = f - stp*gtest;
<a name="l03920"></a>03920       fxm = fx - stx*gtest;
<a name="l03921"></a>03921       fym = fy - sty*gtest;
<a name="l03922"></a>03922       gm = g - gtest;
<a name="l03923"></a>03923       gxm = gx - gtest;
<a name="l03924"></a>03924       gym = gy - gtest;
<a name="l03925"></a>03925       
<a name="l03926"></a>03926       <span class="comment">//Call dcstep to update stx, sty, and to compute the new step.</span>
<a name="l03927"></a>03927       
<a name="l03928"></a>03928       dcstep(stx,fxm,gxm,sty,fym,gym,stp,fm,gm,
<a name="l03929"></a>03929              brackt,stmin,stmax);
<a name="l03930"></a>03930       
<a name="l03931"></a>03931       <span class="comment">//Reset the function and derivative values for f.</span>
<a name="l03932"></a>03932       
<a name="l03933"></a>03933       fx = fxm + stx*gtest;
<a name="l03934"></a>03934       fy = fym + sty*gtest;
<a name="l03935"></a>03935       gx = gxm + gtest;
<a name="l03936"></a>03936       gy = gym + gtest;
<a name="l03937"></a>03937     }
<a name="l03938"></a>03938     <span class="keywordflow">else</span>
<a name="l03939"></a>03939     {
<a name="l03940"></a>03940       <span class="comment">//Call dcstep to update stx, sty, and to compute the new step.</span>
<a name="l03941"></a>03941       
<a name="l03942"></a>03942       dcstep(stx,fx,gx,sty,fy,gy,stp,f,g,
<a name="l03943"></a>03943              brackt,stmin,stmax);
<a name="l03944"></a>03944     }
<a name="l03945"></a>03945     
<a name="l03946"></a>03946     <span class="comment">//Decide if a bisection step is needed.</span>
<a name="l03947"></a>03947     
<a name="l03948"></a>03948     <span class="keywordflow">if</span> (brackt)
<a name="l03949"></a>03949     {
<a name="l03950"></a>03950       <span class="keywordflow">if</span> (fabs(sty-stx) &gt;= p66*width1) stp = stx + p5*(sty - stx);
<a name="l03951"></a>03951       width1 = width;
<a name="l03952"></a>03952       width = fabs(sty-stx);
<a name="l03953"></a>03953     }
<a name="l03954"></a>03954     
<a name="l03955"></a>03955     <span class="comment">//Set the minimum and maximum steps allowed for stp.</span>
<a name="l03956"></a>03956     
<a name="l03957"></a>03957     <span class="keywordflow">if</span> (brackt)
<a name="l03958"></a>03958     {
<a name="l03959"></a>03959       stmin = min(stx,sty);
<a name="l03960"></a>03960       stmax = max(stx,sty);
<a name="l03961"></a>03961     }
<a name="l03962"></a>03962     <span class="keywordflow">else</span>
<a name="l03963"></a>03963     {
<a name="l03964"></a>03964       stmin = stp + xtrapl*(stp - stx);
<a name="l03965"></a>03965       stmax = stp + xtrapu*(stp - stx);
<a name="l03966"></a>03966     }
<a name="l03967"></a>03967     
<a name="l03968"></a>03968     <span class="comment">//Force the step to be within the bounds stpmax and stpmin.</span>
<a name="l03969"></a>03969     
<a name="l03970"></a>03970     stp = max(stp,stpmin);
<a name="l03971"></a>03971     stp = min(stp,stpmax);
<a name="l03972"></a>03972     
<a name="l03973"></a>03973     <span class="comment">//If further progress is not possible, let stp be the best</span>
<a name="l03974"></a>03974     <span class="comment">//point obtained during the search.</span>
<a name="l03975"></a>03975 
<a name="l03976"></a>03976     <span class="keywordflow">if</span> (brackt &amp;&amp; (stp &lt;= stmin || stp &gt;= stmax)
<a name="l03977"></a>03977         || (brackt &amp;&amp; stmax-stmin &lt;= xtol*stmax)) stp = stx;
<a name="l03978"></a>03978     
<a name="l03979"></a>03979     <span class="comment">//Obtain another function and derivative.</span>
<a name="l03980"></a>03980     strcpy(task,<span class="stringliteral">"FG"</span>);
<a name="l03981"></a>03981     
<a name="l03982"></a>03982   goto1000:
<a name="l03983"></a>03983     
<a name="l03984"></a>03984     <span class="comment">//Save local variables.</span>
<a name="l03985"></a>03985     
<a name="l03986"></a>03986     <span class="keywordflow">if</span> (brackt)
<a name="l03987"></a>03987       isave[1]  = 1;
<a name="l03988"></a>03988     <span class="keywordflow">else</span>    
<a name="l03989"></a>03989       isave[1]  = 0;
<a name="l03990"></a>03990 
<a name="l03991"></a>03991     isave[2]  = stage;
<a name="l03992"></a>03992     dsave[1]  = ginit;
<a name="l03993"></a>03993     dsave[2]  = gtest;
<a name="l03994"></a>03994     dsave[3]  = gx;
<a name="l03995"></a>03995     dsave[4]  = gy;
<a name="l03996"></a>03996     dsave[5]  = finit;
<a name="l03997"></a>03997     dsave[6]  = fx;
<a name="l03998"></a>03998     dsave[7]  = fy;
<a name="l03999"></a>03999     dsave[8]  = stx;
<a name="l04000"></a>04000     dsave[9]  = sty;
<a name="l04001"></a>04001     dsave[10] = stmin;
<a name="l04002"></a>04002     dsave[11] = stmax;
<a name="l04003"></a>04003     dsave[12] = width;
<a name="l04004"></a>04004     dsave[13] = width1;
<a name="l04005"></a>04005   }<span class="comment">//dcsrch()</span>
<a name="l04006"></a>04006 
<a name="l04007"></a>04007 
<a name="l04008"></a>04008   <span class="comment">//   **********</span>
<a name="l04009"></a>04009   <span class="comment">//</span>
<a name="l04010"></a>04010   <span class="comment">//   Subroutine dcstep</span>
<a name="l04011"></a>04011   <span class="comment">//</span>
<a name="l04012"></a>04012   <span class="comment">//   This subroutine computes a safeguarded step for a search</span>
<a name="l04013"></a>04013   <span class="comment">//   procedure and updates an interval that contains a step that</span>
<a name="l04014"></a>04014   <span class="comment">//   satisfies a sufficient decrease and a curvature condition.</span>
<a name="l04015"></a>04015   <span class="comment">//</span>
<a name="l04016"></a>04016   <span class="comment">//   The parameter stx contains the step with the least function</span>
<a name="l04017"></a>04017   <span class="comment">//   value. If brackt is set to true then a minimizer has</span>
<a name="l04018"></a>04018   <span class="comment">//   been bracketed in an interval with endpoints stx and sty.</span>
<a name="l04019"></a>04019   <span class="comment">//   The parameter stp contains the current step. </span>
<a name="l04020"></a>04020   <span class="comment">//   The subroutine assumes that if brackt is set to true then</span>
<a name="l04021"></a>04021   <span class="comment">//</span>
<a name="l04022"></a>04022   <span class="comment">//         min(stx,sty) &lt; stp &lt; max(stx,sty),</span>
<a name="l04023"></a>04023   <span class="comment">//</span>
<a name="l04024"></a>04024   <span class="comment">//   and that the derivative at stx is negative in the direction </span>
<a name="l04025"></a>04025   <span class="comment">//   of the step.</span>
<a name="l04026"></a>04026   <span class="comment">//</span>
<a name="l04027"></a>04027   <span class="comment">//   The subroutine statement is</span>
<a name="l04028"></a>04028   <span class="comment">//</span>
<a name="l04029"></a>04029   <span class="comment">//     subroutine dcstep(stx,fx,dx,sty,fy,dy,stp,fp,dp,brackt,</span>
<a name="l04030"></a>04030   <span class="comment">//                       stpmin,stpmax)</span>
<a name="l04031"></a>04031   <span class="comment">//</span>
<a name="l04032"></a>04032   <span class="comment">//   where</span>
<a name="l04033"></a>04033   <span class="comment">//</span>
<a name="l04034"></a>04034   <span class="comment">//     stx is a double precision variable.</span>
<a name="l04035"></a>04035   <span class="comment">//       On entry stx is the best step obtained so far and is an</span>
<a name="l04036"></a>04036   <span class="comment">//          endpoint of the interval that contains the minimizer. </span>
<a name="l04037"></a>04037   <span class="comment">//       On exit stx is the updated best step.</span>
<a name="l04038"></a>04038   <span class="comment">//</span>
<a name="l04039"></a>04039   <span class="comment">//     fx is a double precision variable.</span>
<a name="l04040"></a>04040   <span class="comment">//       On entry fx is the function at stx.</span>
<a name="l04041"></a>04041   <span class="comment">//       On exit fx is the function at stx.</span>
<a name="l04042"></a>04042   <span class="comment">//</span>
<a name="l04043"></a>04043   <span class="comment">//     dx is a double precision variable.</span>
<a name="l04044"></a>04044   <span class="comment">//       On entry dx is the derivative of the function at </span>
<a name="l04045"></a>04045   <span class="comment">//          stx. The derivative must be negative in the direction of </span>
<a name="l04046"></a>04046   <span class="comment">//          the step, that is, dx and stp - stx must have opposite </span>
<a name="l04047"></a>04047   <span class="comment">//          signs.</span>
<a name="l04048"></a>04048   <span class="comment">//       On exit dx is the derivative of the function at stx.</span>
<a name="l04049"></a>04049   <span class="comment">//</span>
<a name="l04050"></a>04050   <span class="comment">//     sty is a double precision variable.</span>
<a name="l04051"></a>04051   <span class="comment">//       On entry sty is the second endpoint of the interval that </span>
<a name="l04052"></a>04052   <span class="comment">//          contains the minimizer.</span>
<a name="l04053"></a>04053   <span class="comment">//       On exit sty is the updated endpoint of the interval that </span>
<a name="l04054"></a>04054   <span class="comment">//          contains the minimizer.</span>
<a name="l04055"></a>04055   <span class="comment">//</span>
<a name="l04056"></a>04056   <span class="comment">//     fy is a double precision variable.</span>
<a name="l04057"></a>04057   <span class="comment">//       On entry fy is the function at sty.</span>
<a name="l04058"></a>04058   <span class="comment">//       On exit fy is the function at sty.</span>
<a name="l04059"></a>04059   <span class="comment">//</span>
<a name="l04060"></a>04060   <span class="comment">//     dy is a double precision variable.</span>
<a name="l04061"></a>04061   <span class="comment">//       On entry dy is the derivative of the function at sty.</span>
<a name="l04062"></a>04062   <span class="comment">//       On exit dy is the derivative of the function at the exit sty.</span>
<a name="l04063"></a>04063   <span class="comment">//</span>
<a name="l04064"></a>04064   <span class="comment">//     stp is a double precision variable.</span>
<a name="l04065"></a>04065   <span class="comment">//       On entry stp is the current step. If brackt is set to true</span>
<a name="l04066"></a>04066   <span class="comment">//          then on input stp must be between stx and sty. </span>
<a name="l04067"></a>04067   <span class="comment">//       On exit stp is a new trial step.</span>
<a name="l04068"></a>04068   <span class="comment">//</span>
<a name="l04069"></a>04069   <span class="comment">//     fp is a double precision variable.</span>
<a name="l04070"></a>04070   <span class="comment">//       On entry fp is the function at stp</span>
<a name="l04071"></a>04071   <span class="comment">//       On exit fp is unchanged.</span>
<a name="l04072"></a>04072   <span class="comment">//</span>
<a name="l04073"></a>04073   <span class="comment">//     dp is a double precision variable.</span>
<a name="l04074"></a>04074   <span class="comment">//       On entry dp is the the derivative of the function at stp.</span>
<a name="l04075"></a>04075   <span class="comment">//       On exit dp is unchanged.</span>
<a name="l04076"></a>04076   <span class="comment">//</span>
<a name="l04077"></a>04077   <span class="comment">//     brackt is an logical variable.</span>
<a name="l04078"></a>04078   <span class="comment">//       On entry brackt specifies if a minimizer has been bracketed.</span>
<a name="l04079"></a>04079   <span class="comment">//          Initially brackt must be set to false</span>
<a name="l04080"></a>04080   <span class="comment">//       On exit brackt specifies if a minimizer has been bracketed.</span>
<a name="l04081"></a>04081   <span class="comment">//          When a minimizer is bracketed brackt is set to true</span>
<a name="l04082"></a>04082   <span class="comment">//</span>
<a name="l04083"></a>04083   <span class="comment">//     stpmin is a double precision variable.</span>
<a name="l04084"></a>04084   <span class="comment">//       On entry stpmin is a lower bound for the step.</span>
<a name="l04085"></a>04085   <span class="comment">//       On exit stpmin is unchanged.</span>
<a name="l04086"></a>04086   <span class="comment">//</span>
<a name="l04087"></a>04087   <span class="comment">//     stpmax is a double precision variable.</span>
<a name="l04088"></a>04088   <span class="comment">//       On entry stpmax is an upper bound for the step.</span>
<a name="l04089"></a>04089   <span class="comment">//       On exit stpmax is unchanged.</span>
<a name="l04090"></a>04090   <span class="comment">//</span>
<a name="l04091"></a>04091   <span class="comment">//   MINPACK-1 Project. June 1983</span>
<a name="l04092"></a>04092   <span class="comment">//   Argonne National Laboratory. </span>
<a name="l04093"></a>04093   <span class="comment">//   Jorge J. More' and David J. Thuente.</span>
<a name="l04094"></a>04094   <span class="comment">//</span>
<a name="l04095"></a>04095   <span class="comment">//   MINPACK-2 Project. October 1993.</span>
<a name="l04096"></a>04096   <span class="comment">//   Argonne National Laboratory and University of Minnesota. </span>
<a name="l04097"></a>04097   <span class="comment">//   Brett M. Averick and Jorge J. More'.</span>
<a name="l04098"></a>04098   <span class="comment">//</span>
<a name="l04099"></a>04099   <span class="comment">//   **********</span>
<a name="l04100"></a>04100     <span class="comment">//function</span>
<a name="l04101"></a>04101   <span class="keywordtype">void</span> dcstep(<span class="keywordtype">double</span>&amp; stx, <span class="keywordtype">double</span>&amp; fx, <span class="keywordtype">double</span>&amp; dx, <span class="keywordtype">double</span>&amp; sty, <span class="keywordtype">double</span>&amp; fy, 
<a name="l04102"></a>04102               <span class="keywordtype">double</span>&amp; dy, <span class="keywordtype">double</span>&amp; stp, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; fp, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; dp, 
<a name="l04103"></a>04103               <span class="keywordtype">bool</span>&amp; brackt, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; stpmin, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; stpmax)
<a name="l04104"></a>04104   {
<a name="l04105"></a>04105     <span class="keywordtype">double</span> zero=0.0,p66=0.66,two=2.0,three=3.0;
<a name="l04106"></a>04106     <span class="keywordtype">double</span> gamma,p,q,r,s,sgnd,stpc,stpf,stpq,theta;
<a name="l04107"></a>04107 
<a name="l04108"></a>04108     sgnd = dp*(dx/fabs(dx));
<a name="l04109"></a>04109 
<a name="l04110"></a>04110     <span class="comment">//First case: A higher function value. The minimum is bracketed. </span>
<a name="l04111"></a>04111     <span class="comment">//If the cubic step is closer to stx than the quadratic step, the </span>
<a name="l04112"></a>04112     <span class="comment">//cubic step is taken, otherwise the average of the cubic and </span>
<a name="l04113"></a>04113     <span class="comment">//quadratic steps is taken.</span>
<a name="l04114"></a>04114 
<a name="l04115"></a>04115     <span class="keywordflow">if</span> (fp &gt; fx)
<a name="l04116"></a>04116     {
<a name="l04117"></a>04117       theta = three*(fx - fp)/(stp - stx) + dx + dp;
<a name="l04118"></a>04118       s = max(fabs(theta),fabs(dx),fabs(dp));
<a name="l04119"></a>04119       gamma = s*sqrt( (theta/s)*(theta/s) - (dx/s)*(dp/s) );
<a name="l04120"></a>04120       <span class="keywordflow">if</span> (stp &lt; stx) gamma = -gamma;
<a name="l04121"></a>04121       p = (gamma - dx) + theta;
<a name="l04122"></a>04122       q = ((gamma - dx) + gamma) + dp;
<a name="l04123"></a>04123       r = p/q;
<a name="l04124"></a>04124       stpc = stx + r*(stp - stx);
<a name="l04125"></a>04125       stpq = stx + ((dx/((fx - fp)/(stp - stx) + dx))/two)*(stp - stx);
<a name="l04126"></a>04126       <span class="keywordflow">if</span> (fabs(stpc-stx) &lt; fabs(stpq-stx))
<a name="l04127"></a>04127         stpf = stpc;
<a name="l04128"></a>04128       <span class="keywordflow">else</span>
<a name="l04129"></a>04129         stpf = stpc + (stpq - stpc)/two;
<a name="l04130"></a>04130       brackt = <span class="keyword">true</span>;
<a name="l04131"></a>04131     }
<a name="l04132"></a>04132 
<a name="l04133"></a>04133     <span class="comment">//Second case: A lower function value and derivatives of opposite </span>
<a name="l04134"></a>04134     <span class="comment">//sign. The minimum is bracketed. If the cubic step is farther from </span>
<a name="l04135"></a>04135     <span class="comment">//stp than the secant step, the cubic step is taken, otherwise the </span>
<a name="l04136"></a>04136     <span class="comment">//secant step is taken.</span>
<a name="l04137"></a>04137 
<a name="l04138"></a>04138     <span class="keywordflow">else</span> 
<a name="l04139"></a>04139     <span class="keywordflow">if</span> (sgnd &lt; zero)
<a name="l04140"></a>04140     {
<a name="l04141"></a>04141       theta = three*(fx - fp)/(stp - stx) + dx + dp;
<a name="l04142"></a>04142       s = max(fabs(theta),fabs(dx),fabs(dp));
<a name="l04143"></a>04143       gamma = s*sqrt( (theta/s)*(theta/s) - (dx/s)*(dp/s) );
<a name="l04144"></a>04144       <span class="keywordflow">if</span> (stp &gt; stx) gamma = -gamma;
<a name="l04145"></a>04145       p = (gamma - dp) + theta;
<a name="l04146"></a>04146       q = ((gamma - dp) + gamma) + dx;
<a name="l04147"></a>04147       r = p/q;
<a name="l04148"></a>04148       stpc = stp + r*(stx - stp);
<a name="l04149"></a>04149       stpq = stp + (dp/(dp - dx))*(stx - stp);
<a name="l04150"></a>04150       <span class="keywordflow">if</span> (fabs(stpc-stp) &gt; fabs(stpq-stp))
<a name="l04151"></a>04151         stpf = stpc;
<a name="l04152"></a>04152       <span class="keywordflow">else</span>
<a name="l04153"></a>04153         stpf = stpq;
<a name="l04154"></a>04154       brackt = <span class="keyword">true</span>;
<a name="l04155"></a>04155     }
<a name="l04156"></a>04156 
<a name="l04157"></a>04157     <span class="comment">//Third case: A lower function value, derivatives of the same sign,</span>
<a name="l04158"></a>04158     <span class="comment">//and the magnitude of the derivative decreases.</span>
<a name="l04159"></a>04159 
<a name="l04160"></a>04160     <span class="keywordflow">else</span> 
<a name="l04161"></a>04161     <span class="keywordflow">if</span> (fabs(dp) &lt; fabs(dx))
<a name="l04162"></a>04162     {
<a name="l04163"></a>04163       <span class="comment">//The cubic step is computed only if the cubic tends to infinity </span>
<a name="l04164"></a>04164       <span class="comment">//in the direction of the step or if the minimum of the cubic</span>
<a name="l04165"></a>04165       <span class="comment">//is beyond stp. Otherwise the cubic step is defined to be the </span>
<a name="l04166"></a>04166       <span class="comment">//secant step.</span>
<a name="l04167"></a>04167 
<a name="l04168"></a>04168       theta = three*(fx - fp)/(stp - stx) + dx + dp;
<a name="l04169"></a>04169       s = max(fabs(theta),fabs(dx),fabs(dp));
<a name="l04170"></a>04170 
<a name="l04171"></a>04171       <span class="comment">//The case gamma = 0 only arises if the cubic does not tend</span>
<a name="l04172"></a>04172       <span class="comment">//to infinity in the direction of the step.</span>
<a name="l04173"></a>04173       
<a name="l04174"></a>04174       gamma = s*sqrt(max(zero, (theta/s)*(theta/s)-(dx/s)*(dp/s)));
<a name="l04175"></a>04175       <span class="keywordflow">if</span> (stp &gt; stx) gamma = -gamma;
<a name="l04176"></a>04176       p = (gamma - dp) + theta;
<a name="l04177"></a>04177       q = (gamma + (dx - dp)) + gamma;
<a name="l04178"></a>04178       r = p/q;
<a name="l04179"></a>04179       <span class="keywordflow">if</span> (r &lt; zero &amp;&amp; gamma != zero)
<a name="l04180"></a>04180         stpc = stp + r*(stx - stp);
<a name="l04181"></a>04181       <span class="keywordflow">else</span> 
<a name="l04182"></a>04182       <span class="keywordflow">if</span> (stp &gt; stx)
<a name="l04183"></a>04183         stpc = stpmax;
<a name="l04184"></a>04184       <span class="keywordflow">else</span>
<a name="l04185"></a>04185         stpc = stpmin;
<a name="l04186"></a>04186       
<a name="l04187"></a>04187       stpq = stp + (dp/(dp - dx))*(stx - stp);
<a name="l04188"></a>04188 
<a name="l04189"></a>04189       <span class="keywordflow">if</span> (brackt)
<a name="l04190"></a>04190       {
<a name="l04191"></a>04191 
<a name="l04192"></a>04192         <span class="comment">//A minimizer has been bracketed. If the cubic step is </span>
<a name="l04193"></a>04193         <span class="comment">//closer to stp than the secant step, the cubic step is </span>
<a name="l04194"></a>04194         <span class="comment">//taken, otherwise the secant step is taken.</span>
<a name="l04195"></a>04195 
<a name="l04196"></a>04196         <span class="keywordflow">if</span> (fabs(stpc-stp) &lt; fabs(stpq-stp))
<a name="l04197"></a>04197           stpf = stpc;
<a name="l04198"></a>04198         <span class="keywordflow">else</span>
<a name="l04199"></a>04199           stpf = stpq;
<a name="l04200"></a>04200 
<a name="l04201"></a>04201         <span class="keywordflow">if</span> (stp &gt; stx) 
<a name="l04202"></a>04202           stpf = min(stp+p66*(sty-stp),stpf);
<a name="l04203"></a>04203         <span class="keywordflow">else</span>
<a name="l04204"></a>04204           stpf = max(stp+p66*(sty-stp),stpf);
<a name="l04205"></a>04205       }
<a name="l04206"></a>04206       <span class="keywordflow">else</span>
<a name="l04207"></a>04207       {
<a name="l04208"></a>04208         <span class="comment">//A minimizer has not been bracketed. If the cubic step is </span>
<a name="l04209"></a>04209         <span class="comment">//farther from stp than the secant step, the cubic step is </span>
<a name="l04210"></a>04210         <span class="comment">//taken, otherwise the secant step is taken.</span>
<a name="l04211"></a>04211 
<a name="l04212"></a>04212         <span class="keywordflow">if</span> (fabs(stpc-stp) &gt; fabs(stpq-stp))
<a name="l04213"></a>04213           stpf = stpc;
<a name="l04214"></a>04214         <span class="keywordflow">else</span>
<a name="l04215"></a>04215           stpf = stpq;
<a name="l04216"></a>04216         
<a name="l04217"></a>04217         stpf = min(stpmax,stpf);
<a name="l04218"></a>04218         stpf = max(stpmin,stpf);
<a name="l04219"></a>04219       }
<a name="l04220"></a>04220     }
<a name="l04221"></a>04221     <span class="comment">//Fourth case: A lower function value, derivatives of the same sign, </span>
<a name="l04222"></a>04222     <span class="comment">//and the magnitude of the derivative does not decrease. If the </span>
<a name="l04223"></a>04223     <span class="comment">//minimum is not bracketed, the step is either stpmin or stpmax, </span>
<a name="l04224"></a>04224     <span class="comment">//otherwise the cubic step is taken.</span>
<a name="l04225"></a>04225     <span class="keywordflow">else</span>
<a name="l04226"></a>04226     {
<a name="l04227"></a>04227       <span class="keywordflow">if</span> (brackt)
<a name="l04228"></a>04228       {
<a name="l04229"></a>04229         theta = three*(fp - fy)/(sty - stp) + dy + dp;
<a name="l04230"></a>04230         s = max(fabs(theta),fabs(dy),fabs(dp));
<a name="l04231"></a>04231         gamma = s*sqrt((theta/s)*(theta/s) - (dy/s)*(dp/s));
<a name="l04232"></a>04232         <span class="keywordflow">if</span> (stp &gt; sty) gamma = -gamma;
<a name="l04233"></a>04233         p = (gamma - dp) + theta;
<a name="l04234"></a>04234         q = ((gamma - dp) + gamma) + dy;
<a name="l04235"></a>04235         r = p/q;
<a name="l04236"></a>04236         stpc = stp + r*(sty - stp);
<a name="l04237"></a>04237         stpf = stpc;
<a name="l04238"></a>04238       }
<a name="l04239"></a>04239       <span class="keywordflow">else</span> 
<a name="l04240"></a>04240       <span class="keywordflow">if</span> (stp &gt; stx)
<a name="l04241"></a>04241         stpf = stpmax;
<a name="l04242"></a>04242       <span class="keywordflow">else</span>
<a name="l04243"></a>04243         stpf = stpmin;
<a name="l04244"></a>04244     }
<a name="l04245"></a>04245 
<a name="l04246"></a>04246     <span class="comment">//Update the interval which contains a minimizer.</span>
<a name="l04247"></a>04247 
<a name="l04248"></a>04248     <span class="keywordflow">if</span> (fp &gt; fx)
<a name="l04249"></a>04249     {
<a name="l04250"></a>04250       sty = stp;
<a name="l04251"></a>04251       fy = fp;
<a name="l04252"></a>04252       dy = dp;
<a name="l04253"></a>04253     }
<a name="l04254"></a>04254     <span class="keywordflow">else</span>
<a name="l04255"></a>04255     {
<a name="l04256"></a>04256       <span class="keywordflow">if</span> (sgnd &lt; zero)
<a name="l04257"></a>04257       {
<a name="l04258"></a>04258         sty = stx;
<a name="l04259"></a>04259         fy = fx;
<a name="l04260"></a>04260         dy = dx;
<a name="l04261"></a>04261       }
<a name="l04262"></a>04262       stx = stp;
<a name="l04263"></a>04263       fx = fp;
<a name="l04264"></a>04264       dx = dp;
<a name="l04265"></a>04265     }
<a name="l04266"></a>04266 
<a name="l04267"></a>04267     <span class="comment">//Compute the new step.</span>
<a name="l04268"></a>04268 
<a name="l04269"></a>04269     stp = stpf;    
<a name="l04270"></a>04270   }<span class="comment">//dcstep()</span>
<a name="l04271"></a>04271 
<a name="l04272"></a>04272 
<a name="l04273"></a>04273   <span class="comment">//   **********</span>
<a name="l04274"></a>04274   <span class="comment">//</span>
<a name="l04275"></a>04275   <span class="comment">//   Function dnrm2</span>
<a name="l04276"></a>04276   <span class="comment">//</span>
<a name="l04277"></a>04277   <span class="comment">//   Given a vector x of length n, this function calculates the</span>
<a name="l04278"></a>04278   <span class="comment">//   Euclidean norm of x with stride incx.</span>
<a name="l04279"></a>04279   <span class="comment">//</span>
<a name="l04280"></a>04280   <span class="comment">//   The function statement is</span>
<a name="l04281"></a>04281   <span class="comment">//</span>
<a name="l04282"></a>04282   <span class="comment">//     double precision function dnrm2(n,x,incx)</span>
<a name="l04283"></a>04283   <span class="comment">//</span>
<a name="l04284"></a>04284   <span class="comment">//   where</span>
<a name="l04285"></a>04285   <span class="comment">//</span>
<a name="l04286"></a>04286   <span class="comment">//     n is a positive integer input variable.</span>
<a name="l04287"></a>04287   <span class="comment">//</span>
<a name="l04288"></a>04288   <span class="comment">//     x is an input array of length n.</span>
<a name="l04289"></a>04289   <span class="comment">//</span>
<a name="l04290"></a>04290   <span class="comment">//     incx is a positive integer variable that specifies the </span>
<a name="l04291"></a>04291   <span class="comment">//       stride of the vector.</span>
<a name="l04292"></a>04292   <span class="comment">//</span>
<a name="l04293"></a>04293   <span class="comment">//   Subprograms called</span>
<a name="l04294"></a>04294   <span class="comment">//</span>
<a name="l04295"></a>04295   <span class="comment">//     FORTRAN-supplied ... abs, max, sqrt</span>
<a name="l04296"></a>04296   <span class="comment">//</span>
<a name="l04297"></a>04297   <span class="comment">//   MINPACK-2 Project. February 1991.</span>
<a name="l04298"></a>04298   <span class="comment">//   Argonne National Laboratory.</span>
<a name="l04299"></a>04299   <span class="comment">//   Brett M. Averick.</span>
<a name="l04300"></a>04300   <span class="comment">//</span>
<a name="l04301"></a>04301   <span class="comment">//   **********</span>
<a name="l04302"></a>04302     <span class="comment">//function</span>
<a name="l04303"></a>04303   <span class="keywordtype">double</span> dnrm2(<span class="keywordtype">int</span>&amp; n,<span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; x, <span class="keywordtype">int</span>&amp; incx)
<a name="l04304"></a>04304   {
<a name="l04305"></a>04305     <span class="comment">//int i;</span>
<a name="l04306"></a>04306     <span class="keywordtype">double</span> scale = 0.0;
<a name="l04307"></a>04307     <span class="keywordtype">double</span> ddnrm2 = 0.0;
<a name="l04308"></a>04308 
<a name="l04309"></a>04309     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i+=incx)
<a name="l04310"></a>04310       scale = max(scale, fabs(x[i]));
<a name="l04311"></a>04311 
<a name="l04312"></a>04312     <span class="keywordflow">if</span> (scale == 0.0) <span class="keywordflow">return</span> ddnrm2;
<a name="l04313"></a>04313 
<a name="l04314"></a>04314     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i+=incx)  
<a name="l04315"></a>04315       ddnrm2 += (x[i]/scale)*(x[i]/scale);
<a name="l04316"></a>04316 
<a name="l04317"></a>04317     ddnrm2 = scale*sqrt(ddnrm2);
<a name="l04318"></a>04318     <span class="keywordflow">return</span> ddnrm2;
<a name="l04319"></a>04319   }
<a name="l04320"></a>04320 
<a name="l04321"></a>04321 
<a name="l04322"></a>04322   <span class="comment">//   **********</span>
<a name="l04323"></a>04323   <span class="comment">//</span>
<a name="l04324"></a>04324   <span class="comment">//   Subroutine dpeps</span>
<a name="l04325"></a>04325   <span class="comment">//</span>
<a name="l04326"></a>04326   <span class="comment">//   This subroutine computes the machine precision parameter</span>
<a name="l04327"></a>04327   <span class="comment">//   dpmeps as the smallest floating point number such that</span>
<a name="l04328"></a>04328   <span class="comment">//   1 + dpmeps differs from 1.</span>
<a name="l04329"></a>04329   <span class="comment">//</span>
<a name="l04330"></a>04330   <span class="comment">//   This subroutine is based on the subroutine machar described in</span>
<a name="l04331"></a>04331   <span class="comment">//</span>
<a name="l04332"></a>04332   <span class="comment">//   W. J. Cody,</span>
<a name="l04333"></a>04333   <span class="comment">//   MACHAR: A subroutine to dynamically determine machine parameters,</span>
<a name="l04334"></a>04334   <span class="comment">//   ACM Transactions on Mathematical Software, 14, 1988, pages 303-311.</span>
<a name="l04335"></a>04335   <span class="comment">//</span>
<a name="l04336"></a>04336   <span class="comment">//   The subroutine statement is:</span>
<a name="l04337"></a>04337   <span class="comment">//</span>
<a name="l04338"></a>04338   <span class="comment">//     subroutine dpeps(dpmeps)</span>
<a name="l04339"></a>04339   <span class="comment">//</span>
<a name="l04340"></a>04340   <span class="comment">//   where</span>
<a name="l04341"></a>04341   <span class="comment">//</span>
<a name="l04342"></a>04342   <span class="comment">//     dpmeps is a double precision variable.</span>
<a name="l04343"></a>04343   <span class="comment">//       On entry dpmeps need not be specified.</span>
<a name="l04344"></a>04344   <span class="comment">//       On exit dpmeps is the machine precision.</span>
<a name="l04345"></a>04345   <span class="comment">//</span>
<a name="l04346"></a>04346   <span class="comment">//   MINPACK-2 Project. February 1991.</span>
<a name="l04347"></a>04347   <span class="comment">//   Argonne National Laboratory and University of Minnesota.</span>
<a name="l04348"></a>04348   <span class="comment">//   Brett M. Averick.</span>
<a name="l04349"></a>04349   <span class="comment">//</span>
<a name="l04350"></a>04350   <span class="comment">//   *******</span>
<a name="l04351"></a>04351     <span class="comment">//function</span>
<a name="l04352"></a>04352   <span class="keywordtype">double</span> dpmeps()
<a name="l04353"></a>04353   {
<a name="l04354"></a>04354     <span class="comment">//int i ;</span>
<a name="l04355"></a>04355     <span class="keywordtype">long</span> <span class="keywordtype">int</span> ibeta,irnd,it,itemp,negep;
<a name="l04356"></a>04356     <span class="keywordtype">long</span> <span class="keywordtype">double</span> a,b,beta,betain,betah,temp,tempa,temp1,
<a name="l04357"></a>04357            zero=0.0,one=1.0,two=2.0;
<a name="l04358"></a>04358     <span class="keywordtype">long</span> <span class="keywordtype">double</span> ddpmeps;
<a name="l04359"></a>04359  
<a name="l04360"></a>04360     <span class="comment">//determine ibeta, beta ala malcolm.</span>
<a name="l04361"></a>04361 
<a name="l04362"></a>04362     a = one;
<a name="l04363"></a>04363     b = one;
<a name="l04364"></a>04364   goto10:
<a name="l04365"></a>04365     a = a + a;
<a name="l04366"></a>04366     temp = a + one;
<a name="l04367"></a>04367     temp1 = temp - a;
<a name="l04368"></a>04368     <span class="keywordflow">if</span> (temp1 - one == zero) <span class="keywordflow">goto</span> goto10;
<a name="l04369"></a>04369    
<a name="l04370"></a>04370   goto20:
<a name="l04371"></a>04371     b = b + b;
<a name="l04372"></a>04372     temp = a + b;
<a name="l04373"></a>04373     itemp = int(temp - a);
<a name="l04374"></a>04374     <span class="keywordflow">if</span> (itemp == 0) <span class="keywordflow">goto</span> goto20;
<a name="l04375"></a>04375     ibeta = itemp;
<a name="l04376"></a>04376     beta = double(ibeta);
<a name="l04377"></a>04377 
<a name="l04378"></a>04378     <span class="comment">//determine it, irnd.</span>
<a name="l04379"></a>04379 
<a name="l04380"></a>04380     it = 0;
<a name="l04381"></a>04381     b = one;
<a name="l04382"></a>04382   goto30:
<a name="l04383"></a>04383     it += 1;
<a name="l04384"></a>04384     b *= beta;
<a name="l04385"></a>04385     temp = b + one;
<a name="l04386"></a>04386     temp1 = temp - b;
<a name="l04387"></a>04387     <span class="keywordflow">if</span> (temp1 - one == zero) <span class="keywordflow">goto</span> goto30;
<a name="l04388"></a>04388     irnd = 0;
<a name="l04389"></a>04389     betah = beta/two;
<a name="l04390"></a>04390     temp = a + betah;
<a name="l04391"></a>04391     <span class="keywordflow">if</span> (temp - a != zero) irnd = 1;
<a name="l04392"></a>04392     tempa = a + beta;
<a name="l04393"></a>04393     temp = tempa + betah;
<a name="l04394"></a>04394     <span class="keywordflow">if</span> ((irnd == 0) &amp;&amp; (temp - tempa != zero)) irnd = 2;
<a name="l04395"></a>04395 
<a name="l04396"></a>04396     <span class="comment">//determine ddpmeps.</span>
<a name="l04397"></a>04397 
<a name="l04398"></a>04398     negep = it + 3;
<a name="l04399"></a>04399     betain = one/beta;
<a name="l04400"></a>04400     a = one;
<a name="l04401"></a>04401     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= negep; i++)
<a name="l04402"></a>04402       a *= betain;
<a name="l04403"></a>04403 
<a name="l04404"></a>04404   goto50:
<a name="l04405"></a>04405     temp = one + a;
<a name="l04406"></a>04406     <span class="keywordflow">if</span> (temp - one != zero) <span class="keywordflow">goto</span> goto60;
<a name="l04407"></a>04407     a *= beta;
<a name="l04408"></a>04408     <span class="keywordflow">goto</span> goto50;
<a name="l04409"></a>04409 
<a name="l04410"></a>04410   goto60:
<a name="l04411"></a>04411     ddpmeps = a;
<a name="l04412"></a>04412     <span class="keywordflow">if</span> ((ibeta == 2) || (irnd == 0)) <span class="keywordflow">goto</span> goto70;
<a name="l04413"></a>04413     a = (a*(one + a))/two;
<a name="l04414"></a>04414     temp = one + a;
<a name="l04415"></a>04415     <span class="keywordflow">if</span> (temp - one != zero) ddpmeps = a;
<a name="l04416"></a>04416 
<a name="l04417"></a>04417   goto70:
<a name="l04418"></a>04418     <span class="keywordflow">return</span> ddpmeps;
<a name="l04419"></a>04419   }<span class="comment">//dpmeps()</span>
<a name="l04420"></a>04420 
<a name="l04421"></a>04421 
<a name="l04422"></a>04422   <span class="comment">//   constant times a vector plus a vector.</span>
<a name="l04423"></a>04423   <span class="comment">//   uses unrolled loops for increments equal to one.</span>
<a name="l04424"></a>04424   <span class="comment">//   jack dongarra, linpack, 3/11/78.</span>
<a name="l04425"></a>04425     <span class="comment">//function</span>
<a name="l04426"></a>04426   <span class="keywordtype">void</span> daxpy(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; da, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dx, 
<a name="l04427"></a>04427              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; incx, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dy, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; incy)
<a name="l04428"></a>04428   {
<a name="l04429"></a>04429     <span class="comment">//int i;</span>
<a name="l04430"></a>04430     <span class="keywordtype">int</span> ix,iy,m,mp1;
<a name="l04431"></a>04431     <span class="keywordflow">if</span> (n &lt;= 0) <span class="keywordflow">return</span>;
<a name="l04432"></a>04432     <span class="keywordflow">if</span> (da == 0.0) <span class="keywordflow">return</span>;
<a name="l04433"></a>04433     <span class="keywordflow">if</span>(incx==1 &amp;&amp; incy==1) <span class="keywordflow">goto</span> goto20;
<a name="l04434"></a>04434 
<a name="l04435"></a>04435     <span class="comment">//code for unequal increments or equal increments</span>
<a name="l04436"></a>04436     <span class="comment">//not equal to 1</span>
<a name="l04437"></a>04437 
<a name="l04438"></a>04438     ix = 1;
<a name="l04439"></a>04439     iy = 1;
<a name="l04440"></a>04440     <span class="keywordflow">if</span>(incx &lt; 0) ix = (-n+1)*incx + 1;
<a name="l04441"></a>04441     <span class="keywordflow">if</span>(incy &lt; 0) iy = (-n+1)*incy + 1;
<a name="l04442"></a>04442 
<a name="l04443"></a>04443     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l04444"></a>04444     {    
<a name="l04445"></a>04445       dy[iy] += da*dx[ix];
<a name="l04446"></a>04446       ix += incx;
<a name="l04447"></a>04447       iy += incy;
<a name="l04448"></a>04448     }
<a name="l04449"></a>04449     <span class="keywordflow">return</span>;
<a name="l04450"></a>04450 
<a name="l04451"></a>04451     <span class="comment">//code for both increments equal to 1</span>
<a name="l04452"></a>04452     <span class="comment">//clean-up loop</span>
<a name="l04453"></a>04453 
<a name="l04454"></a>04454   goto20:
<a name="l04455"></a>04455     m = n%4;
<a name="l04456"></a>04456     <span class="keywordflow">if</span> (m == 0) <span class="keywordflow">goto</span> goto40;
<a name="l04457"></a>04457     
<a name="l04458"></a>04458     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= m; i++)
<a name="l04459"></a>04459       dy[i] += da*dx[i];
<a name="l04460"></a>04460 
<a name="l04461"></a>04461     <span class="keywordflow">if</span> (n &lt; 4) <span class="keywordflow">return</span>;
<a name="l04462"></a>04462 
<a name="l04463"></a>04463   goto40:
<a name="l04464"></a>04464     mp1 = m + 1;
<a name="l04465"></a>04465 
<a name="l04466"></a>04466     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = mp1; i &lt;= n; i+=4)
<a name="l04467"></a>04467     {
<a name="l04468"></a>04468       dy[i] += da*dx[i];
<a name="l04469"></a>04469       dy[i + 1] += da*dx[i + 1];
<a name="l04470"></a>04470       dy[i + 2] += da*dx[i + 2];
<a name="l04471"></a>04471       dy[i + 3] += da*dx[i + 3];
<a name="l04472"></a>04472     }
<a name="l04473"></a>04473   }<span class="comment">//daxpy()</span>
<a name="l04474"></a>04474 
<a name="l04475"></a>04475 
<a name="l04476"></a>04476   <span class="comment">//   copies a vector, x, to a vector, y.</span>
<a name="l04477"></a>04477   <span class="comment">//   uses unrolled loops for increments equal to one.</span>
<a name="l04478"></a>04478   <span class="comment">//   jack dongarra, linpack, 3/11/78.</span>
<a name="l04479"></a>04479     <span class="comment">//function  </span>
<a name="l04480"></a>04480   <span class="keywordtype">void</span> dcopy(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dx, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; incx, 
<a name="l04481"></a>04481              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dy,<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; incy)
<a name="l04482"></a>04482   {
<a name="l04483"></a>04483     <span class="comment">//int i;</span>
<a name="l04484"></a>04484     <span class="keywordtype">int</span> ix,iy,m,mp1;
<a name="l04485"></a>04485 
<a name="l04486"></a>04486     <span class="keywordflow">if</span> (n &lt;= 0) <span class="keywordflow">return</span>;
<a name="l04487"></a>04487     <span class="keywordflow">if</span>(incx==1 &amp;&amp; incy==1) <span class="keywordflow">goto</span> goto20;
<a name="l04488"></a>04488 
<a name="l04489"></a>04489     <span class="comment">//code for unequal increments or equal increments</span>
<a name="l04490"></a>04490     <span class="comment">//not equal to 1</span>
<a name="l04491"></a>04491     
<a name="l04492"></a>04492     ix = 1;
<a name="l04493"></a>04493     iy = 1;
<a name="l04494"></a>04494     <span class="keywordflow">if</span> (incx &lt; 0) ix = (-n+1)*incx + 1;
<a name="l04495"></a>04495     <span class="keywordflow">if</span> (incy &lt; 0) iy = (-n+1)*incy + 1;
<a name="l04496"></a>04496     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l04497"></a>04497     {
<a name="l04498"></a>04498       dy[iy] = dx[ix];
<a name="l04499"></a>04499       ix += incx;
<a name="l04500"></a>04500       iy += incy;
<a name="l04501"></a>04501     }
<a name="l04502"></a>04502     <span class="keywordflow">return</span>;
<a name="l04503"></a>04503 
<a name="l04504"></a>04504     <span class="comment">//code for both increments equal to 1</span>
<a name="l04505"></a>04505 
<a name="l04506"></a>04506     <span class="comment">//clean-up loop</span>
<a name="l04507"></a>04507 
<a name="l04508"></a>04508   goto20:
<a name="l04509"></a>04509     m = n%7;
<a name="l04510"></a>04510     <span class="keywordflow">if</span> (m == 0) <span class="keywordflow">goto</span> goto40;
<a name="l04511"></a>04511     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= m; i++)
<a name="l04512"></a>04512       dy[i] = dx[i];
<a name="l04513"></a>04513 
<a name="l04514"></a>04514     <span class="keywordflow">if</span> (n &lt; 7) <span class="keywordflow">return</span>;
<a name="l04515"></a>04515 
<a name="l04516"></a>04516   goto40:
<a name="l04517"></a>04517     mp1 = m + 1;
<a name="l04518"></a>04518     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = mp1; i &lt;= n; i+=7)
<a name="l04519"></a>04519     {
<a name="l04520"></a>04520       dy[i] = dx[i];
<a name="l04521"></a>04521       dy[i + 1] = dx[i + 1];
<a name="l04522"></a>04522       dy[i + 2] = dx[i + 2];
<a name="l04523"></a>04523       dy[i + 3] = dx[i + 3];
<a name="l04524"></a>04524       dy[i + 4] = dx[i + 4];
<a name="l04525"></a>04525       dy[i + 5] = dx[i + 5];
<a name="l04526"></a>04526       dy[i + 6] = dx[i + 6];
<a name="l04527"></a>04527     }      
<a name="l04528"></a>04528   }<span class="comment">//dcopy()</span>
<a name="l04529"></a>04529 
<a name="l04530"></a>04530 
<a name="l04531"></a>04531   <span class="comment">//forms the dot product of two vectors.</span>
<a name="l04532"></a>04532   <span class="comment">//uses unrolled loops for increments equal to one.</span>
<a name="l04533"></a>04533   <span class="comment">//jack dongarra, linpack, 3/11/78.</span>
<a name="l04534"></a>04534     <span class="comment">//function</span>
<a name="l04535"></a>04535   <span class="keywordtype">double</span> ddot(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dx, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; incx, 
<a name="l04536"></a>04536               <span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dy, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; incy)
<a name="l04537"></a>04537   {
<a name="l04538"></a>04538     <span class="keywordtype">double</span> dtemp;
<a name="l04539"></a>04539     <span class="comment">//int i;</span>
<a name="l04540"></a>04540     <span class="keywordtype">int</span> ix,iy,m,mp1;
<a name="l04541"></a>04541 
<a name="l04542"></a>04542     <span class="keywordtype">double</span> dddot = 0.0;
<a name="l04543"></a>04543     dtemp = 0.0;
<a name="l04544"></a>04544     <span class="keywordflow">if</span> (n &lt;= 0) <span class="keywordflow">return</span> dddot;
<a name="l04545"></a>04545     <span class="keywordflow">if</span> (incx==1 &amp;&amp; incy==1) <span class="keywordflow">goto</span> goto20;
<a name="l04546"></a>04546 
<a name="l04547"></a>04547     <span class="comment">//code for unequal increments or equal increments</span>
<a name="l04548"></a>04548     <span class="comment">//not equal to 1</span>
<a name="l04549"></a>04549     
<a name="l04550"></a>04550     ix = 1;
<a name="l04551"></a>04551     iy = 1;
<a name="l04552"></a>04552     <span class="keywordflow">if</span> (incx &lt; 0) ix = (-n+1)*incx + 1;
<a name="l04553"></a>04553     <span class="keywordflow">if</span> (incy &lt; 0) iy = (-n+1)*incy + 1;
<a name="l04554"></a>04554 
<a name="l04555"></a>04555     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= n; i++)
<a name="l04556"></a>04556     {
<a name="l04557"></a>04557       dtemp += dx[ix]*dy[iy];
<a name="l04558"></a>04558       ix += incx;
<a name="l04559"></a>04559       iy += incy;
<a name="l04560"></a>04560     }
<a name="l04561"></a>04561     dddot = dtemp;
<a name="l04562"></a>04562     <span class="keywordflow">return</span> dddot;
<a name="l04563"></a>04563 
<a name="l04564"></a>04564     <span class="comment">//code for both increments equal to 1</span>
<a name="l04565"></a>04565 
<a name="l04566"></a>04566     <span class="comment">//clean-up loop</span>
<a name="l04567"></a>04567 
<a name="l04568"></a>04568   goto20:
<a name="l04569"></a>04569     m = n%5;
<a name="l04570"></a>04570     <span class="keywordflow">if</span> (m == 0) <span class="keywordflow">goto</span> goto40;
<a name="l04571"></a>04571 
<a name="l04572"></a>04572     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= m; i++)
<a name="l04573"></a>04573       dtemp += dx[i]*dy[i];
<a name="l04574"></a>04574 
<a name="l04575"></a>04575     <span class="keywordflow">if</span>( n &lt; 5 ) <span class="keywordflow">goto</span> goto60;
<a name="l04576"></a>04576 
<a name="l04577"></a>04577   goto40:
<a name="l04578"></a>04578     mp1 = m + 1;
<a name="l04579"></a>04579 
<a name="l04580"></a>04580 
<a name="l04581"></a>04581     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = mp1; i &lt;= n; i+=5)
<a name="l04582"></a>04582     {
<a name="l04583"></a>04583       dtemp += dx[i]*dy[i] + dx[i + 1]*dy[i + 1] +
<a name="l04584"></a>04584                dx[i + 2]*dy[i + 2] + dx[i + 3]*dy[i + 3] + dx[i + 4]*dy[i + 4];
<a name="l04585"></a>04585     }
<a name="l04586"></a>04586 
<a name="l04587"></a>04587   goto60:
<a name="l04588"></a>04588     dddot = dtemp;
<a name="l04589"></a>04589     <span class="keywordflow">return</span> dddot;
<a name="l04590"></a>04590   }<span class="comment">//ddot()</span>
<a name="l04591"></a>04591 
<a name="l04592"></a>04592 
<a name="l04593"></a>04593   <span class="comment">//   dpofa factors a double precision symmetric positive definite</span>
<a name="l04594"></a>04594   <span class="comment">//   matrix.</span>
<a name="l04595"></a>04595   <span class="comment">//</span>
<a name="l04596"></a>04596   <span class="comment">//   dpofa is usually called by dpoco, but it can be called</span>
<a name="l04597"></a>04597   <span class="comment">//   directly with a saving in time if  rcond  is not needed.</span>
<a name="l04598"></a>04598   <span class="comment">//   (time for dpoco) = (1 + 18/n)*(time for dpofa) .</span>
<a name="l04599"></a>04599   <span class="comment">//</span>
<a name="l04600"></a>04600   <span class="comment">//   on entry</span>
<a name="l04601"></a>04601   <span class="comment">//</span>
<a name="l04602"></a>04602   <span class="comment">//      a       double precision(lda, n)</span>
<a name="l04603"></a>04603   <span class="comment">//              the symmetric matrix to be factored.  only the</span>
<a name="l04604"></a>04604   <span class="comment">//              diagonal and upper triangle are used.</span>
<a name="l04605"></a>04605   <span class="comment">//</span>
<a name="l04606"></a>04606   <span class="comment">//      lda     integer</span>
<a name="l04607"></a>04607   <span class="comment">//              the leading dimension of the array  a .</span>
<a name="l04608"></a>04608   <span class="comment">//</span>
<a name="l04609"></a>04609   <span class="comment">//      n       integer</span>
<a name="l04610"></a>04610   <span class="comment">//              the order of the matrix  a .</span>
<a name="l04611"></a>04611   <span class="comment">//</span>
<a name="l04612"></a>04612   <span class="comment">//   on return</span>
<a name="l04613"></a>04613   <span class="comment">//</span>
<a name="l04614"></a>04614   <span class="comment">//      a       an upper triangular matrix  r  so that  a = trans(r)*r</span>
<a name="l04615"></a>04615   <span class="comment">//              where  trans(r)  is the transpose.</span>
<a name="l04616"></a>04616   <span class="comment">//              the strict lower triangle is unaltered.</span>
<a name="l04617"></a>04617   <span class="comment">//              if  info != 0 , the factorization is not complete.</span>
<a name="l04618"></a>04618   <span class="comment">//</span>
<a name="l04619"></a>04619   <span class="comment">//      info    integer</span>
<a name="l04620"></a>04620   <span class="comment">//              = 0  for normal return.</span>
<a name="l04621"></a>04621   <span class="comment">//              = k  signals an error condition.  the leading minor</span>
<a name="l04622"></a>04622   <span class="comment">//                   of order  k  is not positive definite.</span>
<a name="l04623"></a>04623   <span class="comment">//</span>
<a name="l04624"></a>04624   <span class="comment">//   linpack.  this version dated 08/14/78 .</span>
<a name="l04625"></a>04625   <span class="comment">//   cleve moler, university of new mexico, argonne national lab.</span>
<a name="l04626"></a>04626   <span class="comment">//</span>
<a name="l04627"></a>04627   <span class="comment">//   subroutines and functions</span>
<a name="l04628"></a>04628   <span class="comment">//</span>
<a name="l04629"></a>04629   <span class="comment">//   blas ddot</span>
<a name="l04630"></a>04630   <span class="comment">//   fortran sqrt</span>
<a name="l04631"></a>04631   <span class="comment">//</span>
<a name="l04632"></a>04632   <span class="comment">//   internal variables</span>
<a name="l04633"></a>04633   <span class="comment">//  </span>
<a name="l04634"></a>04634     <span class="comment">//function</span>
<a name="l04635"></a>04635   <span class="keywordtype">void</span> dpofa(<span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; a, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; lda, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keywordtype">int</span>&amp; info,
<a name="l04636"></a>04636              <span class="keywordtype">bool</span> smallerMatrix=<span class="keyword">false</span>)
<a name="l04637"></a>04637   {
<a name="l04638"></a>04638     <span class="keywordtype">double</span> t;
<a name="l04639"></a>04639     <span class="keywordtype">double</span> s;
<a name="l04640"></a>04640     <span class="comment">//int j,k</span>
<a name="l04641"></a>04641     <span class="keywordtype">int</span> jm1;
<a name="l04642"></a>04642     <span class="keywordtype">int</span> idx;
<a name="l04643"></a>04643     <span class="comment">//begin block with ...exits to 40</span>
<a name="l04644"></a>04644 
<a name="l04645"></a>04645     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= n; j++)
<a name="l04646"></a>04646     {
<a name="l04647"></a>04647       info = j;
<a name="l04648"></a>04648       s = 0.0;
<a name="l04649"></a>04649       jm1 = j - 1;
<a name="l04650"></a>04650       <span class="keywordflow">if</span> (jm1 &lt; 1) <span class="keywordflow">goto</span> goto20;
<a name="l04651"></a>04651       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 1; k &lt;= jm1; k++)
<a name="l04652"></a>04652       {
<a name="l04653"></a>04653         idx = getIdx(k,j,lda);
<a name="l04654"></a>04654         t = a[idx] - ddot(k-1,&amp;(a[getIdx(1,k,lda)-1]),1,
<a name="l04655"></a>04655                               &amp;(a[getIdx(1,j,lda)-1]),1);
<a name="l04656"></a>04656         t = t/a[getIdx(k,k,lda)];
<a name="l04657"></a>04657         a[idx] = t;
<a name="l04658"></a>04658         s += t*t;
<a name="l04659"></a>04659       }
<a name="l04660"></a>04660 
<a name="l04661"></a>04661     goto20:
<a name="l04662"></a>04662       idx = getIdx(j,j,lda);
<a name="l04663"></a>04663       s = a[idx] - s;
<a name="l04664"></a>04664 
<a name="l04665"></a>04665       <span class="comment">//......exit</span>
<a name="l04666"></a>04666       <span class="keywordflow">if</span> (s &lt;= 0.0) <span class="keywordflow">goto</span> goto40;
<a name="l04667"></a>04667       a[idx] = sqrt(s);
<a name="l04668"></a>04668     }
<a name="l04669"></a>04669     info = 0;
<a name="l04670"></a>04670   goto40:
<a name="l04671"></a>04671     t = 0;
<a name="l04672"></a>04672   }<span class="comment">//dpofa()</span>
<a name="l04673"></a>04673 
<a name="l04674"></a>04674 
<a name="l04675"></a>04675   <span class="comment">//scales a vector by a constant.</span>
<a name="l04676"></a>04676   <span class="comment">//uses unrolled loops for increment equal to one.</span>
<a name="l04677"></a>04677   <span class="comment">//jack dongarra, linpack, 3/11/78.</span>
<a name="l04678"></a>04678   <span class="comment">//modified 3/93 to return if incx &lt;= 0.</span>
<a name="l04679"></a>04679     <span class="comment">//function    </span>
<a name="l04680"></a>04680   <span class="keywordtype">void</span> dscal(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; da, <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; dx, 
<a name="l04681"></a>04681              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; incx)
<a name="l04682"></a>04682   {
<a name="l04683"></a>04683     <span class="comment">//int i;</span>
<a name="l04684"></a>04684     <span class="keywordtype">int</span> m,mp1,nincx;
<a name="l04685"></a>04685 
<a name="l04686"></a>04686     <span class="keywordflow">if</span> (n &lt;= 0 || incx &lt;= 0) <span class="keywordflow">return</span>;
<a name="l04687"></a>04687     <span class="keywordflow">if</span> (incx == 1) <span class="keywordflow">goto</span> goto20;
<a name="l04688"></a>04688 
<a name="l04689"></a>04689     <span class="comment">//code for increment not equal to 1</span>
<a name="l04690"></a>04690 
<a name="l04691"></a>04691     nincx = n*incx;
<a name="l04692"></a>04692 
<a name="l04693"></a>04693     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= nincx; i+=incx)
<a name="l04694"></a>04694       dx[i] = da*dx[i];
<a name="l04695"></a>04695     <span class="keywordflow">return</span>;
<a name="l04696"></a>04696 
<a name="l04697"></a>04697     <span class="comment">//code for increment equal to 1</span>
<a name="l04698"></a>04698 
<a name="l04699"></a>04699     <span class="comment">//clean-up loop</span>
<a name="l04700"></a>04700 
<a name="l04701"></a>04701   goto20:
<a name="l04702"></a>04702     m = n%5;
<a name="l04703"></a>04703     <span class="keywordflow">if</span> (m == 0) <span class="keywordflow">goto</span> goto40;
<a name="l04704"></a>04704 
<a name="l04705"></a>04705     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= m; i++)
<a name="l04706"></a>04706       dx[i] = da*dx[i];
<a name="l04707"></a>04707 
<a name="l04708"></a>04708     <span class="keywordflow">if</span> (n &lt; 5) <span class="keywordflow">return</span>;
<a name="l04709"></a>04709 
<a name="l04710"></a>04710   goto40:
<a name="l04711"></a>04711     mp1 = m + 1;
<a name="l04712"></a>04712     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = mp1; i &lt;= n; i+=5)
<a name="l04713"></a>04713     {
<a name="l04714"></a>04714       dx[i] = da*dx[i];
<a name="l04715"></a>04715       dx[i + 1] = da*dx[i + 1];
<a name="l04716"></a>04716       dx[i + 2] = da*dx[i + 2];
<a name="l04717"></a>04717       dx[i + 3] = da*dx[i + 3];
<a name="l04718"></a>04718       dx[i + 4] = da*dx[i + 4];
<a name="l04719"></a>04719     }
<a name="l04720"></a>04720   }<span class="comment">//dscal()</span>
<a name="l04721"></a>04721 
<a name="l04722"></a>04722   <span class="comment">//</span>
<a name="l04723"></a>04723   <span class="comment">//</span>
<a name="l04724"></a>04724   <span class="comment">//   dtrsl solves systems of the form</span>
<a name="l04725"></a>04725   <span class="comment">//</span>
<a name="l04726"></a>04726   <span class="comment">//                 t * x = b</span>
<a name="l04727"></a>04727   <span class="comment">//   or</span>
<a name="l04728"></a>04728   <span class="comment">//                 trans(t) * x = b</span>
<a name="l04729"></a>04729   <span class="comment">//</span>
<a name="l04730"></a>04730   <span class="comment">//   where t is a triangular matrix of order n. here trans(t)</span>
<a name="l04731"></a>04731   <span class="comment">//   denotes the transpose of the matrix t.</span>
<a name="l04732"></a>04732   <span class="comment">//</span>
<a name="l04733"></a>04733   <span class="comment">//   on entry</span>
<a name="l04734"></a>04734   <span class="comment">//</span>
<a name="l04735"></a>04735   <span class="comment">//       t         double precision(ldt,n)</span>
<a name="l04736"></a>04736   <span class="comment">//                 t contains the matrix of the system. the zero</span>
<a name="l04737"></a>04737   <span class="comment">//                 elements of the matrix are not referenced, and</span>
<a name="l04738"></a>04738   <span class="comment">//                 the corresponding elements of the array can be</span>
<a name="l04739"></a>04739   <span class="comment">//                 used to store other information.</span>
<a name="l04740"></a>04740   <span class="comment">//</span>
<a name="l04741"></a>04741   <span class="comment">//       ldt       integer</span>
<a name="l04742"></a>04742   <span class="comment">//                 ldt is the leading dimension of the array t.</span>
<a name="l04743"></a>04743   <span class="comment">//</span>
<a name="l04744"></a>04744   <span class="comment">//       n         integer</span>
<a name="l04745"></a>04745   <span class="comment">//                 n is the order of the system.</span>
<a name="l04746"></a>04746   <span class="comment">//</span>
<a name="l04747"></a>04747   <span class="comment">//       b         double precision(n).</span>
<a name="l04748"></a>04748   <span class="comment">//                 b contains the right hand side of the system.</span>
<a name="l04749"></a>04749   <span class="comment">//</span>
<a name="l04750"></a>04750   <span class="comment">//       job       integer</span>
<a name="l04751"></a>04751   <span class="comment">//                 job specifies what kind of system is to be solved.</span>
<a name="l04752"></a>04752   <span class="comment">//                 if job is</span>
<a name="l04753"></a>04753   <span class="comment">//</span>
<a name="l04754"></a>04754   <span class="comment">//                      00   solve t*x=b, t lower triangular,</span>
<a name="l04755"></a>04755   <span class="comment">//                      01   solve t*x=b, t upper triangular,</span>
<a name="l04756"></a>04756   <span class="comment">//                      10   solve trans(t)*x=b, t lower triangular,</span>
<a name="l04757"></a>04757   <span class="comment">//                      11   solve trans(t)*x=b, t upper triangular.</span>
<a name="l04758"></a>04758   <span class="comment">//</span>
<a name="l04759"></a>04759   <span class="comment">//   on return</span>
<a name="l04760"></a>04760   <span class="comment">//</span>
<a name="l04761"></a>04761   <span class="comment">//       b         b contains the solution, if info == 0.</span>
<a name="l04762"></a>04762   <span class="comment">//                 otherwise b is unaltered.</span>
<a name="l04763"></a>04763   <span class="comment">//</span>
<a name="l04764"></a>04764   <span class="comment">//       info      integer</span>
<a name="l04765"></a>04765   <span class="comment">//                 info contains zero if the system is nonsingular.</span>
<a name="l04766"></a>04766   <span class="comment">//                 otherwise info contains the index of</span>
<a name="l04767"></a>04767   <span class="comment">//                 the first zero diagonal element of t.</span>
<a name="l04768"></a>04768   <span class="comment">//</span>
<a name="l04769"></a>04769   <span class="comment">//   linpack. this version dated 08/14/78 .</span>
<a name="l04770"></a>04770   <span class="comment">//   g. w. stewart, university of maryland, argonne national lab.</span>
<a name="l04771"></a>04771   <span class="comment">//</span>
<a name="l04772"></a>04772   <span class="comment">//   subroutines and functions</span>
<a name="l04773"></a>04773   <span class="comment">//</span>
<a name="l04774"></a>04774   <span class="comment">//   blas daxpy,ddot</span>
<a name="l04775"></a>04775   <span class="comment">//   fortran mod</span>
<a name="l04776"></a>04776     <span class="comment">//function</span>
<a name="l04777"></a>04777   <span class="keywordtype">void</span> dtrsl(<span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; t, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; ldt, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; n, 
<a name="l04778"></a>04778              <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp;b, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; job, <span class="keywordtype">int</span>&amp; info)
<a name="l04779"></a>04779   {
<a name="l04780"></a>04780     <span class="keywordtype">double</span> temp;
<a name="l04781"></a>04781     <span class="keywordtype">int</span> ccase,j;
<a name="l04782"></a>04782     <span class="comment">//int jj;</span>
<a name="l04783"></a>04783 
<a name="l04784"></a>04784     <span class="comment">//begin block permitting ...exits to 150</span>
<a name="l04785"></a>04785     
<a name="l04786"></a>04786     <span class="comment">//check for zero diagonal elements.</span>
<a name="l04787"></a>04787     
<a name="l04788"></a>04788     <span class="keywordflow">for</span> (info = 1; info &lt;= n; info++)
<a name="l04789"></a>04789     {
<a name="l04790"></a>04790       <span class="comment">//......exit</span>
<a name="l04791"></a>04791       <span class="keywordflow">if</span> (t[getIdx(info,info,ldt)] == 0.0) <span class="keywordflow">goto</span> goto150;
<a name="l04792"></a>04792     }
<a name="l04793"></a>04793     info = 0;
<a name="l04794"></a>04794 
<a name="l04795"></a>04795     <span class="comment">//determine the task and go to it.</span>
<a name="l04796"></a>04796 
<a name="l04797"></a>04797     ccase = 1;
<a name="l04798"></a>04798     <span class="keywordflow">if</span> (job%10 != 0) ccase = 2;
<a name="l04799"></a>04799     <span class="keywordflow">if</span> ((job%100)/10 != 0) ccase += 2;
<a name="l04800"></a>04800     <span class="keywordflow">if</span> (ccase==1) <span class="keywordflow">goto</span> goto20;
<a name="l04801"></a>04801     <span class="keywordflow">if</span> (ccase==2) <span class="keywordflow">goto</span> goto50;
<a name="l04802"></a>04802     <span class="keywordflow">if</span> (ccase==3) <span class="keywordflow">goto</span> goto80;
<a name="l04803"></a>04803     <span class="keywordflow">if</span> (ccase==4) <span class="keywordflow">goto</span> goto110;
<a name="l04804"></a>04804 
<a name="l04805"></a>04805     <span class="comment">//solve t*x=b for t lower triangular</span>
<a name="l04806"></a>04806 
<a name="l04807"></a>04807   goto20:
<a name="l04808"></a>04808     b[1] /= t[getIdx(1,1,ldt)];
<a name="l04809"></a>04809     <span class="keywordflow">if</span> (n &lt; 2) <span class="keywordflow">goto</span> goto40;
<a name="l04810"></a>04810     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 2; j &lt;= n; j++)
<a name="l04811"></a>04811     {
<a name="l04812"></a>04812       temp = -b[j-1];
<a name="l04813"></a>04813       daxpy(n-j+1,temp,&amp;(t[getIdx(j,j-1,ldt)-1]),1,&amp;(b[j-1]),1);
<a name="l04814"></a>04814       b[j] /= t[getIdx(j,j,ldt)];
<a name="l04815"></a>04815     }
<a name="l04816"></a>04816   goto40:
<a name="l04817"></a>04817     <span class="keywordflow">goto</span> goto140;
<a name="l04818"></a>04818 
<a name="l04819"></a>04819     <span class="comment">//solve t*x=b for t upper triangular.</span>
<a name="l04820"></a>04820 
<a name="l04821"></a>04821   goto50:    
<a name="l04822"></a>04822     b[n] /= t[getIdx(n,n,ldt)];
<a name="l04823"></a>04823     <span class="keywordflow">if</span> (n &lt; 2) <span class="keywordflow">goto</span> goto70;
<a name="l04824"></a>04824     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj = 2; jj &lt;= n; jj++)
<a name="l04825"></a>04825     {
<a name="l04826"></a>04826       j = n - jj + 1;
<a name="l04827"></a>04827       temp = -b[j+1];
<a name="l04828"></a>04828       daxpy(j,temp,&amp;(t[getIdx(1,j+1,ldt)-1]),1,&amp;(b[1-1]),1);
<a name="l04829"></a>04829       b[j] /= t[getIdx(j,j,ldt)];
<a name="l04830"></a>04830     }
<a name="l04831"></a>04831 
<a name="l04832"></a>04832   goto70:
<a name="l04833"></a>04833     <span class="keywordflow">goto</span> goto140;
<a name="l04834"></a>04834 
<a name="l04835"></a>04835     <span class="comment">//solve trans(t)*x=b for t lower triangular.</span>
<a name="l04836"></a>04836 
<a name="l04837"></a>04837   goto80:
<a name="l04838"></a>04838     b[n] /= t[getIdx(n,n,ldt)];
<a name="l04839"></a>04839     <span class="keywordflow">if</span> (n &lt; 2) <span class="keywordflow">goto</span> goto100;
<a name="l04840"></a>04840     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj = 2; jj &lt;= n; jj++)
<a name="l04841"></a>04841     {
<a name="l04842"></a>04842       j = n - jj + 1;
<a name="l04843"></a>04843       b[j] = b[j] - ddot(jj-1,&amp;(t[getIdx(j+1,j,ldt)-1]),1,&amp;(b[j+1-1]),1);
<a name="l04844"></a>04844       b[j] /= t[getIdx(j,j,ldt)];
<a name="l04845"></a>04845     }
<a name="l04846"></a>04846   goto100:
<a name="l04847"></a>04847     <span class="keywordflow">goto</span> goto140;
<a name="l04848"></a>04848 
<a name="l04849"></a>04849     <span class="comment">//solve trans(t)*x=b for t upper triangular.</span>
<a name="l04850"></a>04850 
<a name="l04851"></a>04851   goto110:
<a name="l04852"></a>04852     b[1] /= t[getIdx(1,1,ldt)];
<a name="l04853"></a>04853     <span class="keywordflow">if</span> (n &lt; 2) <span class="keywordflow">goto</span> goto130;
<a name="l04854"></a>04854     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 2; j &lt;= n; j++)
<a name="l04855"></a>04855     {
<a name="l04856"></a>04856       b[j] = b[j] - ddot(j-1,&amp;(t[getIdx(1,j,ldt)-1]),1,&amp;(b[1-1]),1);
<a name="l04857"></a>04857       b[j] /= t[getIdx(j,j,ldt)];
<a name="l04858"></a>04858     }
<a name="l04859"></a>04859 
<a name="l04860"></a>04860   goto130:
<a name="l04861"></a>04861     
<a name="l04862"></a>04862     <span class="keywordflow">if</span> (<span class="keyword">false</span>);
<a name="l04863"></a>04863 
<a name="l04864"></a>04864   goto140:
<a name="l04865"></a>04865 
<a name="l04866"></a>04866     <span class="keywordflow">if</span> (<span class="keyword">false</span>);
<a name="l04867"></a>04867 
<a name="l04868"></a>04868   goto150:
<a name="l04869"></a>04869 
<a name="l04870"></a>04870     <span class="keywordflow">if</span> (<span class="keyword">false</span>);
<a name="l04871"></a>04871     
<a name="l04872"></a>04872   }<span class="comment">//dtrsl()</span>
<a name="l04873"></a>04873 
<a name="l04874"></a>04874  <span class="keyword">private</span>:
<a name="l04875"></a>04875   <a class="code" href="classTimer.html">Timer</a> timer_;
<a name="l04876"></a>04876 
<a name="l04877"></a>04877 };
<a name="l04878"></a>04878 
<a name="l04879"></a>04879 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 14 15:15:20 2007 for Alchemy by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
