<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Alchemy: src/logic/mln.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_bad0962745a374caf6e9fb10c9087375.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_5fa6dff3c95823d97bd37bbb86c0a4ab.html">logic</a></div>
<h1>mln.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * All of the documentation and software included in the</span>
<a name="l00003"></a>00003 <span class="comment"> * Alchemy Software is copyrighted by Stanley Kok, Parag</span>
<a name="l00004"></a>00004 <span class="comment"> * Singla, Matthew Richardson, Pedro Domingos, Marc</span>
<a name="l00005"></a>00005 <span class="comment"> * Sumner and Hoifung Poon.</span>
<a name="l00006"></a>00006 <span class="comment"> * </span>
<a name="l00007"></a>00007 <span class="comment"> * Copyright [2004-07] Stanley Kok, Parag Singla, Matthew</span>
<a name="l00008"></a>00008 <span class="comment"> * Richardson, Pedro Domingos, Marc Sumner and Hoifung</span>
<a name="l00009"></a>00009 <span class="comment"> * Poon. All rights reserved.</span>
<a name="l00010"></a>00010 <span class="comment"> * </span>
<a name="l00011"></a>00011 <span class="comment"> * Contact: Pedro Domingos, University of Washington</span>
<a name="l00012"></a>00012 <span class="comment"> * (pedrod@cs.washington.edu).</span>
<a name="l00013"></a>00013 <span class="comment"> * </span>
<a name="l00014"></a>00014 <span class="comment"> * Redistribution and use in source and binary forms, with</span>
<a name="l00015"></a>00015 <span class="comment"> * or without modification, are permitted provided that</span>
<a name="l00016"></a>00016 <span class="comment"> * the following conditions are met:</span>
<a name="l00017"></a>00017 <span class="comment"> * </span>
<a name="l00018"></a>00018 <span class="comment"> * 1. Redistributions of source code must retain the above</span>
<a name="l00019"></a>00019 <span class="comment"> * copyright notice, this list of conditions and the</span>
<a name="l00020"></a>00020 <span class="comment"> * following disclaimer.</span>
<a name="l00021"></a>00021 <span class="comment"> * </span>
<a name="l00022"></a>00022 <span class="comment"> * 2. Redistributions in binary form must reproduce the</span>
<a name="l00023"></a>00023 <span class="comment"> * above copyright notice, this list of conditions and the</span>
<a name="l00024"></a>00024 <span class="comment"> * following disclaimer in the documentation and/or other</span>
<a name="l00025"></a>00025 <span class="comment"> * materials provided with the distribution.</span>
<a name="l00026"></a>00026 <span class="comment"> * </span>
<a name="l00027"></a>00027 <span class="comment"> * 3. All advertising materials mentioning features or use</span>
<a name="l00028"></a>00028 <span class="comment"> * of this software must display the following</span>
<a name="l00029"></a>00029 <span class="comment"> * acknowledgment: "This product includes software</span>
<a name="l00030"></a>00030 <span class="comment"> * developed by Stanley Kok, Parag Singla, Matthew</span>
<a name="l00031"></a>00031 <span class="comment"> * Richardson, Pedro Domingos, Marc Sumner and Hoifung</span>
<a name="l00032"></a>00032 <span class="comment"> * Poon in the Department of Computer Science and</span>
<a name="l00033"></a>00033 <span class="comment"> * Engineering at the University of Washington".</span>
<a name="l00034"></a>00034 <span class="comment"> * </span>
<a name="l00035"></a>00035 <span class="comment"> * 4. Your publications acknowledge the use or</span>
<a name="l00036"></a>00036 <span class="comment"> * contribution made by the Software to your research</span>
<a name="l00037"></a>00037 <span class="comment"> * using the following citation(s): </span>
<a name="l00038"></a>00038 <span class="comment"> * Stanley Kok, Parag Singla, Matthew Richardson and</span>
<a name="l00039"></a>00039 <span class="comment"> * Pedro Domingos (2005). "The Alchemy System for</span>
<a name="l00040"></a>00040 <span class="comment"> * Statistical Relational AI", Technical Report,</span>
<a name="l00041"></a>00041 <span class="comment"> * Department of Computer Science and Engineering,</span>
<a name="l00042"></a>00042 <span class="comment"> * University of Washington, Seattle, WA.</span>
<a name="l00043"></a>00043 <span class="comment"> * http://www.cs.washington.edu/ai/alchemy.</span>
<a name="l00044"></a>00044 <span class="comment"> * </span>
<a name="l00045"></a>00045 <span class="comment"> * 5. Neither the name of the University of Washington nor</span>
<a name="l00046"></a>00046 <span class="comment"> * the names of its contributors may be used to endorse or</span>
<a name="l00047"></a>00047 <span class="comment"> * promote products derived from this software without</span>
<a name="l00048"></a>00048 <span class="comment"> * specific prior written permission.</span>
<a name="l00049"></a>00049 <span class="comment"> * </span>
<a name="l00050"></a>00050 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF WASHINGTON</span>
<a name="l00051"></a>00051 <span class="comment"> * AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED</span>
<a name="l00052"></a>00052 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a name="l00053"></a>00053 <span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<a name="l00054"></a>00054 <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY</span>
<a name="l00055"></a>00055 <span class="comment"> * OF WASHINGTON OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,</span>
<a name="l00056"></a>00056 <span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a name="l00057"></a>00057 <span class="comment"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a name="l00058"></a>00058 <span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00059"></a>00059 <span class="comment"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span>
<a name="l00060"></a>00060 <span class="comment"> * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<a name="l00061"></a>00061 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a name="l00062"></a>00062 <span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN</span>
<a name="l00063"></a>00063 <span class="comment"> * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00064"></a>00064 <span class="comment"> * </span>
<a name="l00065"></a>00065 <span class="comment"> */</span>
<a name="l00066"></a>00066 <span class="preprocessor">#ifndef MLN_H_JUN_26_2005</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define MLN_H_JUN_26_2005</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;cfloat&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;ext/hash_map&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;ext/hash_set&gt;</span>
<a name="l00072"></a>00072 <span class="keyword">using namespace </span>__gnu_cxx;
<a name="l00073"></a>00073 <span class="preprocessor">#include "clause.h"</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include "equalstr.h"</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include "mlnhelper.h"</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 
<a name="l00078"></a><a class="code" href="classMLN.html">00078</a> <span class="keyword">class </span><a class="code" href="classMLN.html">MLN</a>
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080  <span class="keyword">public</span>: 
<a name="l00081"></a><a class="code" href="classMLN.html#e2a0ef8f257f5c532f56eca521c20d9a">00081</a>   <a class="code" href="classMLN.html#e2a0ef8f257f5c532f56eca521c20d9a">MLN</a>() : clauses_(new <a class="code" href="classHashArray.html">ClauseHashArray</a>),clauseInfos_(new <a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="structMLNClauseInfo.html">MLNClauseInfo</a>*&gt;),
<a name="l00082"></a>00082           formAndClausesArray_(new <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>), 
<a name="l00083"></a>00083           predIdToClausesMap_(new <a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="classArray.html">Array</a>&lt;<a class="code" href="structIndexClause.html">IndexClause</a>*&gt;*&gt;) {}
<a name="l00084"></a>00084 
<a name="l00085"></a><a class="code" href="classMLN.html#e08b12ee6dc6f6df0cce456175c465a5">00085</a>   <a class="code" href="classMLN.html#e08b12ee6dc6f6df0cce456175c465a5">~MLN</a>()
<a name="l00086"></a>00086   {
<a name="l00087"></a>00087     clauses_-&gt;<a class="code" href="classHashArray.html#f98170f652a937097e189498bd641085">deleteItemsAndClear</a>(); <span class="keyword">delete</span> clauses_;
<a name="l00088"></a>00088     clauseInfos_-&gt;<a class="code" href="classArray.html#4dc59692a1b565c53ef845d67268bb24">deleteItemsAndClear</a>(); <span class="keyword">delete</span> clauseInfos_;
<a name="l00089"></a>00089     formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#f98170f652a937097e189498bd641085">deleteItemsAndClear</a>(); <span class="keyword">delete</span> formAndClausesArray_;
<a name="l00090"></a>00090     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predIdToClausesMap_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00091"></a>00091       <span class="keywordflow">if</span> ((*predIdToClausesMap_)[i]) 
<a name="l00092"></a>00092       {
<a name="l00093"></a>00093         (*predIdToClausesMap_)[i]-&gt;<a class="code" href="classHashArray.html#f98170f652a937097e189498bd641085">deleteItemsAndClear</a>();
<a name="l00094"></a>00094         <span class="keyword">delete</span> (*predIdToClausesMap_)[i];
<a name="l00095"></a>00095       }
<a name="l00096"></a>00096     <span class="keyword">delete</span> predIdToClausesMap_;
<a name="l00097"></a>00097   }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 
<a name="l00100"></a><a class="code" href="classMLN.html#9af698a87c5b518e9ce18755bc414231">00100</a>   <span class="keywordtype">int</span> <a class="code" href="classMLN.html#9af698a87c5b518e9ce18755bc414231">getNumClauses</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); }
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="classMLN.html#1a160d7fcadae971292b984695ef79e3">00102</a>   <span class="keywordtype">int</span> <a class="code" href="classMLN.html#1a160d7fcadae971292b984695ef79e3">getNumHardClauses</a>()<span class="keyword"> const</span>
<a name="l00103"></a>00103 <span class="keyword">  </span>{
<a name="l00104"></a>00104         <span class="keywordtype">int</span> numHardClauses = 0;
<a name="l00105"></a>00105         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00106"></a>00106         {
<a name="l00107"></a>00107           <span class="keywordflow">if</span> ((*clauses_)[i]-&gt;isHardClause()) numHardClauses++;
<a name="l00108"></a>00108         }
<a name="l00109"></a>00109         <span class="keywordflow">return</span> numHardClauses;
<a name="l00110"></a>00110   }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00113"></a><a class="code" href="classMLN.html#3d05c2901cbe3b08fa268de41b24e279">00113</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#3d05c2901cbe3b08fa268de41b24e279">containsClause</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const</span>
<a name="l00114"></a>00114 <span class="keyword">  </span>{ <span class="keywordflow">return</span> clauses_-&gt;<a class="code" href="classHashArray.html#7ef36132544b3d97362a9216a0e04c87">contains</a>((<a class="code" href="classClause.html">Clause</a>*)c); }
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     <span class="comment">//MLN owns clause c and is responsible for its deletion.</span>
<a name="l00118"></a>00118     <span class="comment">//hasExist is true if formulaString contains an existential quantifier</span>
<a name="l00119"></a>00119     <span class="comment">//during the CNF conversion process.</span>
<a name="l00120"></a>00120     <span class="comment">//Call setHardClausesWts() after this function to set the weights of hard</span>
<a name="l00121"></a>00121     <span class="comment">//clauses to twice the maximum of soft clause wts.</span>
<a name="l00122"></a>00122     <span class="comment">//Returns true of the clause is appended; otherwise returns false.</span>
<a name="l00123"></a>00123     <span class="comment">//retIdx is the index of the clause in MLN's array of clauses</span>
<a name="l00124"></a><a class="code" href="classMLN.html#ff4e76688d4270ecbb3030d37b9a9650">00124</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#ff4e76688d4270ecbb3030d37b9a9650">appendClause</a>(<span class="keyword">const</span> string&amp; formulaString, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; hasExist, 
<a name="l00125"></a>00125                     <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span>&amp; c, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; wt,
<a name="l00126"></a>00126                     <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; isHardClause, <span class="keywordtype">int</span>&amp; retClauseIdx) 
<a name="l00127"></a>00127   {
<a name="l00128"></a>00128     assert(c);
<a name="l00129"></a>00129     c-&gt;<a class="code" href="classClause.html#edb8a1d73f76a00136e94a852213b3da">canonicalize</a>();
<a name="l00130"></a>00130     <span class="keywordtype">bool</span> isAppended;
<a name="l00131"></a>00131     <a class="code" href="classClause.html">Clause</a>* clause;
<a name="l00132"></a>00132     <span class="keywordflow">if</span> ((retClauseIdx = clauses_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(c)) &gt;= 0) <span class="comment">// if clauses_ contains c</span>
<a name="l00133"></a>00133     {
<a name="l00134"></a>00134       clause = (*clauses_)[retClauseIdx];
<a name="l00135"></a>00135       <span class="keyword">delete</span> c;
<a name="l00136"></a>00136       isAppended = <span class="keyword">false</span>;
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138     <span class="keywordflow">else</span>
<a name="l00139"></a>00139     {
<a name="l00140"></a>00140         <span class="comment">// clause does not exist in MLN, so add it</span>
<a name="l00141"></a>00141       retClauseIdx = clauses_-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(c);
<a name="l00142"></a>00142       clause = c;
<a name="l00143"></a>00143       isAppended = <span class="keyword">true</span>;
<a name="l00144"></a>00144       clause-&gt;<a class="code" href="classClause.html#f80c37e7dfbe0805aad5026ae91cadb4">setWt</a>(0); <span class="comment">//start accumulating weight from 0</span>
<a name="l00145"></a>00145     }
<a name="l00146"></a>00146     clause-&gt;<a class="code" href="classClause.html#f41d7e407308135c34de2a58338d57e0">addWt</a>(wt);
<a name="l00147"></a>00147     <span class="keywordflow">if</span> (isHardClause) clause-&gt;<a class="code" href="classClause.html#8ad74c2a57b735d49c1cd323a0500d9c">setIsHardClause</a>(isHardClause);
<a name="l00148"></a>00148 
<a name="l00149"></a>00149  
<a name="l00150"></a>00150     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fac = <span class="keyword">new</span> <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>(formulaString, 
<a name="l00151"></a>00151                                                    formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(),
<a name="l00152"></a>00152                                                    hasExist);
<a name="l00153"></a>00153     <span class="keywordtype">int</span> fidx;
<a name="l00154"></a>00154       <span class="comment">// if this is the first time we see the formulaString</span>
<a name="l00155"></a>00155     <span class="keywordflow">if</span> ( (fidx = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(fac)) &lt; 0 )
<a name="l00156"></a>00156     {
<a name="l00157"></a>00157       fidx = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(fac);
<a name="l00158"></a>00158       assert(fac-&gt;<a class="code" href="structFormulaAndClauses.html#33cf12277d8d33c32d7970cc34e49cae">index</a> == fidx);
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160     <span class="keywordflow">else</span>
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162       <span class="keyword">delete</span> fac;
<a name="l00163"></a>00163       fac = (*formAndClausesArray_)[fidx];
<a name="l00164"></a>00164       assert(fac-&gt;<a class="code" href="structFormulaAndClauses.html#33cf12277d8d33c32d7970cc34e49cae">index</a> == fidx);
<a name="l00165"></a>00165     }
<a name="l00166"></a>00166     <a class="code" href="structIndexClause.html">IndexClause</a>* ic = <span class="keyword">new</span> <a class="code" href="structIndexClause.html">IndexClause</a>(fac-&gt;<a class="code" href="structFormulaAndClauses.html#396d9482b3198729436c257f5b9602a2">indexClauses</a>-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(), clause);
<a name="l00167"></a>00167     <span class="keywordtype">int</span> cidx = fac-&gt;<a class="code" href="structFormulaAndClauses.html#396d9482b3198729436c257f5b9602a2">indexClauses</a>-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(ic);
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (cidx &lt; 0) { <span class="keyword">delete</span> ic; ic = NULL; }
<a name="l00169"></a>00169     <span class="keywordflow">else</span>          assert(ic-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a> == cidx);
<a name="l00170"></a>00170 
<a name="l00171"></a>00171     <span class="keywordflow">if</span> (isAppended) 
<a name="l00172"></a>00172     {
<a name="l00173"></a>00173         <span class="comment">// add to predIdToClausesMap_, and append to clauseInfos_</span>
<a name="l00174"></a>00174       appendClauseInfo(clause, retClauseIdx, &amp;(fac-&gt;<a class="code" href="structFormulaAndClauses.html#33cf12277d8d33c32d7970cc34e49cae">index</a>), &amp;(ic-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a>));
<a name="l00175"></a>00175     }
<a name="l00176"></a>00176     <span class="keywordflow">else</span> 
<a name="l00177"></a>00177     <span class="keywordflow">if</span> (cidx &gt;= 0) 
<a name="l00178"></a>00178     {   
<a name="l00179"></a>00179         <span class="comment">//a clause was appended to an entry in formAndClausesArray_, so update </span>
<a name="l00180"></a>00180         <span class="comment">//the formulaClauseIndexes of the MLNClauseInfo corresponding to clause</span>
<a name="l00181"></a>00181       updateClauseInfo(retClauseIdx, &amp;(fac-&gt;<a class="code" href="structFormulaAndClauses.html#33cf12277d8d33c32d7970cc34e49cae">index</a>), &amp;(ic-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a>));
<a name="l00182"></a>00182     }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     assert(clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() == clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00185"></a>00185     <span class="keywordflow">return</span> isAppended;
<a name="l00186"></a>00186   } <span class="comment">//appendClause()</span>
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     <span class="comment">// idx is the index into the clauses_ array</span>
<a name="l00190"></a><a class="code" href="classMLN.html#77218b7b5387b2c397cba1efcde5081a">00190</a>   <a class="code" href="classClause.html">Clause</a>* <a class="code" href="classMLN.html#77218b7b5387b2c397cba1efcde5081a">removeClause</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; remIdx)
<a name="l00191"></a>00191   {
<a name="l00192"></a>00192       <span class="comment">//remove the clause and its corresponding MLNClauseInfo</span>
<a name="l00193"></a>00193     <a class="code" href="classClause.html">Clause</a>* r = clauses_-&gt;<a class="code" href="classHashArray.html#e5e111447c99c8bec8dcb007e9b7816b">removeItemFastDisorder</a>(remIdx);
<a name="l00194"></a>00194     <a class="code" href="structMLNClauseInfo.html">MLNClauseInfo</a>* ci = clauseInfos_-&gt;<a class="code" href="classArray.html#f3a485906b00ac44e39f0d402bd09512">removeItemFastDisorder</a>(remIdx);
<a name="l00195"></a>00195     assert(ci-&gt;<a class="code" href="structMLNClauseInfo.html#59147abbc521b84952aa42ef414f8237">index</a> == remIdx);
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="keywordflow">if</span> (clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() != remIdx) <span class="comment">//if we didn't just remove the last item</span>
<a name="l00198"></a>00198     {
<a name="l00199"></a>00199         <span class="comment">//(*clauseInfos_)[remIdx] is the last item moved to the position of the</span>
<a name="l00200"></a>00200         <span class="comment">//removed IndexClause</span>
<a name="l00201"></a>00201       (*clauseInfos_)[remIdx]-&gt;index = remIdx;
<a name="l00202"></a>00202     }
<a name="l00203"></a>00203 
<a name="l00204"></a>00204       <span class="comment">//update MLNClauseInfo's predIdsClauseIndexes</span>
<a name="l00205"></a>00205     <a class="code" href="classArray.html">Array&lt;PredIdClauseIndex*&gt;</a>&amp; piciArr = ci-&gt;<a class="code" href="structMLNClauseInfo.html#2849d4b22ced1f5b7241cd0f1f1ca58d">predIdsClauseIndexes</a>;
<a name="l00206"></a>00206     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; piciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00207"></a>00207     {
<a name="l00208"></a>00208       <span class="keywordtype">int</span> predId = piciArr[i]-&gt;predId;
<a name="l00209"></a>00209       <span class="keywordtype">int</span> remIdx = *(piciArr[i]-&gt;clauseIndex);
<a name="l00210"></a>00210 
<a name="l00211"></a>00211       <a class="code" href="classArray.html">Array&lt;IndexClause*&gt;</a>* indexesClauses = (*predIdToClausesMap_)[predId];
<a name="l00212"></a>00212       <a class="code" href="structIndexClause.html">IndexClause</a>* ic = indexesClauses-&gt;<a class="code" href="classArray.html#f3a485906b00ac44e39f0d402bd09512">removeItemFastDisorder</a>(remIdx);
<a name="l00213"></a>00213       assert(ic-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a> == remIdx &amp;&amp; ic-&gt;<a class="code" href="structIndexClause.html#9b3d18a3ea676804b463c7f416dcb1de">clause</a> == r);
<a name="l00214"></a>00214       <span class="keyword">delete</span> ic;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <span class="comment">//if pred's clause array isn't empty &amp; we didn't just removed last item</span>
<a name="l00217"></a>00217       <span class="keywordflow">if</span> (indexesClauses-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() != remIdx)
<a name="l00218"></a>00218       {
<a name="l00219"></a>00219           <span class="comment">//(*predClauses)[remIdx] is the last item moved to the position of </span>
<a name="l00220"></a>00220           <span class="comment">//removed clause, so update its position to remIdx</span>
<a name="l00221"></a>00221         (*indexesClauses)[remIdx]-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a> = remIdx;        
<a name="l00222"></a>00222       }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224       <span class="keywordflow">if</span> (indexesClauses-&gt;<a class="code" href="classArray.html#7049e1f4482b7a8589dec0cd73a7cd4b">empty</a>())
<a name="l00225"></a>00225       {
<a name="l00226"></a>00226         <span class="keyword">delete</span> indexesClauses;
<a name="l00227"></a>00227         (*predIdToClausesMap_)[predId] = NULL;
<a name="l00228"></a>00228       }
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231       <span class="comment">//update MLNClauseInfo's formulaClauseIndexes</span>
<a name="l00232"></a>00232     <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr = ci-&gt;<a class="code" href="structMLNClauseInfo.html#598c05d1d8b2c211f63582a6358c3c92">formulaClauseIndexes</a>;
<a name="l00233"></a>00233     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00234"></a>00234     {
<a name="l00235"></a>00235       <span class="keywordtype">int</span> fidx = *(fciArr[i]-&gt;formulaIndex);
<a name="l00236"></a>00236       <span class="keywordtype">int</span> remIdx = *(fciArr[i]-&gt;clauseIndex);
<a name="l00237"></a>00237       <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fac = (*formAndClausesArray_)[fidx];
<a name="l00238"></a>00238       <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* indexClauses = fac-&gt;<a class="code" href="structFormulaAndClauses.html#396d9482b3198729436c257f5b9602a2">indexClauses</a>;
<a name="l00239"></a>00239       <a class="code" href="structIndexClause.html">IndexClause</a>* ic = indexClauses-&gt;<a class="code" href="classHashArray.html#e5e111447c99c8bec8dcb007e9b7816b">removeItemFastDisorder</a>(remIdx);
<a name="l00240"></a>00240       assert(ic-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a> == remIdx);
<a name="l00241"></a>00241       <span class="keyword">delete</span> ic;
<a name="l00242"></a>00242       <span class="keywordflow">if</span> (indexClauses-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() != remIdx)
<a name="l00243"></a>00243         (*indexClauses)[remIdx]-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a> = remIdx;
<a name="l00244"></a>00244       
<a name="l00245"></a>00245       <span class="keywordflow">if</span> (indexClauses-&gt;<a class="code" href="classHashArray.html#d1046d22b480e5aad812d20344b1bf6c">empty</a>())
<a name="l00246"></a>00246       {
<a name="l00247"></a>00247         fac = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#e5e111447c99c8bec8dcb007e9b7816b">removeItemFastDisorder</a>(fidx);
<a name="l00248"></a>00248         assert(fac-&gt;<a class="code" href="structFormulaAndClauses.html#33cf12277d8d33c32d7970cc34e49cae">index</a> == fidx);
<a name="l00249"></a>00249         <span class="keyword">delete</span> fac;
<a name="l00250"></a>00250         <span class="keywordflow">if</span> (formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() != fidx)
<a name="l00251"></a>00251           (*formAndClausesArray_)[fidx]-&gt;<a class="code" href="structFormulaAndClauses.html#33cf12277d8d33c32d7970cc34e49cae">index</a> = fidx;
<a name="l00252"></a>00252       }
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <span class="keyword">delete</span> ci;
<a name="l00256"></a>00256     assert(clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() == clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00257"></a>00257     <span class="keywordflow">return</span> r;
<a name="l00258"></a>00258   }<span class="comment">//removeClause()</span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="comment">// returns the removed clause or NULL if c is not in the MLN</span>
<a name="l00262"></a><a class="code" href="classMLN.html#0f3ec72ff078f8481ce60aafc781c21a">00262</a>   <a class="code" href="classClause.html">Clause</a>* <a class="code" href="classMLN.html#77218b7b5387b2c397cba1efcde5081a">removeClause</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)
<a name="l00263"></a>00263   {
<a name="l00264"></a>00264     <span class="keywordtype">int</span> idx = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00265"></a>00265     <span class="keywordflow">if</span> (idx &lt; 0) <span class="keywordflow">return</span> NULL;
<a name="l00266"></a>00266     <span class="keywordflow">return</span> <a class="code" href="classMLN.html#77218b7b5387b2c397cba1efcde5081a">removeClause</a>(idx);
<a name="l00267"></a>00267   }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 
<a name="l00270"></a><a class="code" href="classMLN.html#e49099d35fe9feb0e2994a6514477fd0">00270</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#e49099d35fe9feb0e2994a6514477fd0">removeAllClauses</a>(<a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>* <span class="keyword">const</span> &amp; clauses)
<a name="l00271"></a>00271   {
<a name="l00272"></a>00272     <span class="keywordflow">while</span> (!clauses_-&gt;<a class="code" href="classHashArray.html#d1046d22b480e5aad812d20344b1bf6c">empty</a>()) 
<a name="l00273"></a>00273     {
<a name="l00274"></a>00274       <a class="code" href="classClause.html">Clause</a>* c = <a class="code" href="classMLN.html#77218b7b5387b2c397cba1efcde5081a">removeClause</a>(0);
<a name="l00275"></a>00275       <span class="keywordflow">if</span> (clauses) clauses-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(c);
<a name="l00276"></a>00276       <span class="keywordflow">else</span> <span class="keyword">delete</span> c;
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278   }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     <span class="comment">// Clauses  are reinserted into clauses_, and the indexClauses arrays of </span>
<a name="l00282"></a>00282     <span class="comment">// each FormulaAndClauses in formAndClausesArrays_. Call this when the </span>
<a name="l00283"></a>00283     <span class="comment">// clauses' hash codes change, e.g., when constants are reordered. You have</span>
<a name="l00284"></a>00284     <span class="comment">// to do this because hash_map does not register the hash values of its</span>
<a name="l00285"></a>00285     <span class="comment">// contents if the values change after the contents are inserted.</span>
<a name="l00286"></a><a class="code" href="classMLN.html#dc93282ee202d739a323d698dec66569">00286</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#dc93282ee202d739a323d698dec66569">rehashClauses</a>()
<a name="l00287"></a>00287   {
<a name="l00288"></a>00288     <a class="code" href="classHashArray.html">ClauseHashArray</a>* newha =  <span class="keyword">new</span> <a class="code" href="classHashArray.html">ClauseHashArray</a>;
<a name="l00289"></a>00289     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++) 
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291       <span class="keywordtype">int</span> a = newha-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>((*clauses_)[i]);
<a name="l00292"></a>00292       assert(a &gt;= 0); a = 0; <span class="comment">//avoid compilation warning</span>
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294     <span class="keyword">delete</span> clauses_;
<a name="l00295"></a>00295     clauses_ = newha;
<a name="l00296"></a>00296  
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00299"></a>00299     {
<a name="l00300"></a>00300       <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fac = (*formAndClausesArray_)[i];
<a name="l00301"></a>00301       <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* newArr = <span class="keyword">new</span> <a class="code" href="classHashArray.html">IndexClauseHashArray</a>;
<a name="l00302"></a>00302       <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* curArr = fac-&gt;indexClauses;
<a name="l00303"></a>00303       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; curArr-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00304"></a>00304       {
<a name="l00305"></a>00305         <span class="keywordtype">int</span> a = newArr-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>((*curArr)[j]);
<a name="l00306"></a>00306         assert((*curArr)[j]-&gt;index == a); a = 0; <span class="comment">//avoid compilation warning</span>
<a name="l00307"></a>00307       }
<a name="l00308"></a>00308       curArr-&gt;<a class="code" href="classHashArray.html#2de280c5e9183a2ba9188f66b1eb026d">clear</a>();
<a name="l00309"></a>00309       <span class="keyword">delete</span> curArr;
<a name="l00310"></a>00310       fac-&gt;indexClauses = newArr;
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312   }
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 
<a name="l00315"></a>00315     <span class="comment">//returns the maximum absolute value of soft weights (weights of clauses</span>
<a name="l00316"></a>00316     <span class="comment">//that are not hard and not belonging to existentially and uniquely quant.</span>
<a name="l00317"></a>00317     <span class="comment">//formulas).</span>
<a name="l00318"></a><a class="code" href="classMLN.html#fe89d9f628625802ccdc1f853f087496">00318</a>   <span class="keywordtype">double</span> <a class="code" href="classMLN.html#fe89d9f628625802ccdc1f853f087496">getMaxAbsSoftWt</a>()
<a name="l00319"></a>00319   {
<a name="l00320"></a>00320       <span class="comment">//find the max of the (absolute) soft clause wts</span>
<a name="l00321"></a>00321     <span class="keywordtype">double</span> maxSoftWt = 0;
<a name="l00322"></a>00322     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00323"></a>00323     {
<a name="l00324"></a>00324       <a class="code" href="classClause.html">Clause</a>* c = (*clauses_)[i];
<a name="l00325"></a>00325       <span class="keywordflow">if</span> (!c-&gt;isHardClause() &amp;&amp; !<a class="code" href="classMLN.html#1662f165830a5d4afaab25c1f39f530d">isExistUniqueClause</a>(c))
<a name="l00326"></a>00326       {
<a name="l00327"></a>00327         <span class="keywordtype">double</span> abWt = fabs(c-&gt;getWt());
<a name="l00328"></a>00328         <span class="keywordflow">if</span> (abWt &gt; maxSoftWt) maxSoftWt = abWt;
<a name="l00329"></a>00329       }
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="keywordflow">return</span> maxSoftWt;
<a name="l00332"></a>00332   }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="comment">// Returns the index into clauses_ where c is found</span>
<a name="l00336"></a><a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">00336</a>   <span class="keywordtype">int</span> <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const </span>
<a name="l00337"></a>00337 <span class="keyword">  </span>{ <span class="keywordflow">return</span> clauses_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>((<a class="code" href="classClause.html">Clause</a>*)c); }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 
<a name="l00340"></a><a class="code" href="classMLN.html#6a4e0195013eb381bff01694a0ceb4ae">00340</a>   <span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <a class="code" href="classMLN.html#6a4e0195013eb381bff01694a0ceb4ae">findClause</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const </span>
<a name="l00341"></a>00341 <span class="keyword">  </span>{ 
<a name="l00342"></a>00342     <span class="keywordtype">int</span> i = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00343"></a>00343     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> NULL;
<a name="l00344"></a>00344     <span class="keywordflow">return</span> (*clauses_)[i];
<a name="l00345"></a>00345   }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="comment">//returns clause at position of clauses_ </span>
<a name="l00349"></a>00349     <span class="comment">//or NULL if i is not a valid index of clauses_     </span>
<a name="l00350"></a><a class="code" href="classMLN.html#497ce3f0fc49d215ab278a4a285e161e">00350</a>   <span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <a class="code" href="classMLN.html#497ce3f0fc49d215ab278a4a285e161e">getClause</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)<span class="keyword"> const</span>
<a name="l00351"></a>00351 <span class="keyword">  </span>{
<a name="l00352"></a>00352     <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>()) <span class="keywordflow">return</span> NULL;
<a name="l00353"></a>00353     <span class="keywordflow">return</span> (*clauses_)[i];
<a name="l00354"></a>00354   }
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 
<a name="l00357"></a>00357     <span class="comment">// returns true if the ith clause is in the CNF of an existentially</span>
<a name="l00358"></a>00358     <span class="comment">// quantified formula</span>
<a name="l00359"></a><a class="code" href="classMLN.html#2d3524856c6c63c5c208d4257b800e1f">00359</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#2d3524856c6c63c5c208d4257b800e1f">isExistClause</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)<span class="keyword"> const</span>
<a name="l00360"></a>00360 <span class="keyword">  </span>{
<a name="l00361"></a>00361     assert(0 &lt;= i &amp;&amp; i &lt; clauses_-&gt;size());
<a name="l00362"></a>00362     <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr 
<a name="l00363"></a>00363       = (*clauseInfos_)[i]-&gt;formulaClauseIndexes;
<a name="l00364"></a>00364     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00365"></a>00365       <span class="keywordflow">if</span> ((*formAndClausesArray_)[*(fciArr[i]-&gt;formulaIndex)]-&gt;hasExist) 
<a name="l00366"></a>00366         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00367"></a>00367     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00368"></a>00368   }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370 
<a name="l00371"></a>00371     <span class="comment">// returns true if clause c is in the CNF of an existentially</span>
<a name="l00372"></a>00372     <span class="comment">// quantified formula</span>
<a name="l00373"></a><a class="code" href="classMLN.html#35d775579d441049d984ad89005ba10f">00373</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#2d3524856c6c63c5c208d4257b800e1f">isExistClause</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const</span>
<a name="l00374"></a>00374 <span class="keyword">  </span>{
<a name="l00375"></a>00375     <span class="keywordtype">int</span> i = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00376"></a>00376     assert(i &gt;= 0);
<a name="l00377"></a>00377     <span class="keywordflow">return</span> <a class="code" href="classMLN.html#2d3524856c6c63c5c208d4257b800e1f">isExistClause</a>(i);
<a name="l00378"></a>00378   }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     <span class="comment">// returns true if the ith clause is in the CNF of an existentially and</span>
<a name="l00382"></a>00382     <span class="comment">// uniquely quantified formula</span>
<a name="l00383"></a><a class="code" href="classMLN.html#1662f165830a5d4afaab25c1f39f530d">00383</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#1662f165830a5d4afaab25c1f39f530d">isExistUniqueClause</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)<span class="keyword"> const</span>
<a name="l00384"></a>00384 <span class="keyword">  </span>{
<a name="l00385"></a>00385     assert(0 &lt;= i &amp;&amp; i &lt; clauses_-&gt;size());
<a name="l00386"></a>00386     <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr 
<a name="l00387"></a>00387       = (*clauseInfos_)[i]-&gt;formulaClauseIndexes;
<a name="l00388"></a>00388     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00389"></a>00389       <span class="keywordflow">if</span> ((*formAndClausesArray_)[*(fciArr[i]-&gt;formulaIndex)]-&gt;isExistUnique) 
<a name="l00390"></a>00390         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00391"></a>00391     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="comment">// returns true if clause c is in the CNF of an existentially and</span>
<a name="l00396"></a>00396     <span class="comment">// uniquely quantified formula</span>
<a name="l00397"></a><a class="code" href="classMLN.html#b827c401bc371193239aa443ceb2884e">00397</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#1662f165830a5d4afaab25c1f39f530d">isExistUniqueClause</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const</span>
<a name="l00398"></a>00398 <span class="keyword">  </span>{
<a name="l00399"></a>00399     <span class="keywordtype">int</span> i = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00400"></a>00400     assert(i &gt;= 0);
<a name="l00401"></a>00401     <span class="keywordflow">return</span> <a class="code" href="classMLN.html#1662f165830a5d4afaab25c1f39f530d">isExistUniqueClause</a>(i);
<a name="l00402"></a>00402   }
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 
<a name="l00405"></a>00405     <span class="comment">// returns true if the ith clause is in the CNF of a non-existentially</span>
<a name="l00406"></a>00406     <span class="comment">// quantified formula</span>
<a name="l00407"></a><a class="code" href="classMLN.html#e6ac28af43cb3957bdb41e5cfaa14929">00407</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#e6ac28af43cb3957bdb41e5cfaa14929">clauseInNonExistAndNonExistUniqueFormulaCNF</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)<span class="keyword"> const</span>
<a name="l00408"></a>00408 <span class="keyword">  </span>{
<a name="l00409"></a>00409     assert(0 &lt;= i &amp;&amp; i &lt; clauses_-&gt;size());
<a name="l00410"></a>00410     <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr 
<a name="l00411"></a>00411       = (*clauseInfos_)[i]-&gt;formulaClauseIndexes;
<a name="l00412"></a>00412     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00413"></a>00413     {
<a name="l00414"></a>00414       <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>*fnc=(*formAndClausesArray_)[*(fciArr[i]-&gt;formulaIndex)];
<a name="l00415"></a>00415       <span class="keywordflow">if</span> (!fnc-&gt;hasExist &amp;&amp; !fnc-&gt;isExistUnique) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00416"></a>00416     }
<a name="l00417"></a>00417     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00418"></a>00418   }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 
<a name="l00421"></a>00421     <span class="comment">// returns true if the ith clause is in the CNF of a non-existentially</span>
<a name="l00422"></a>00422     <span class="comment">// quantified formula</span>
<a name="l00423"></a><a class="code" href="classMLN.html#76b8b65f596b6f9daf893d33ca40e28e">00423</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#e6ac28af43cb3957bdb41e5cfaa14929">clauseInNonExistAndNonExistUniqueFormulaCNF</a>(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"></span>
<a name="l00424"></a>00424 <span class="keyword">  const</span>
<a name="l00425"></a>00425 <span class="keyword">  </span>{
<a name="l00426"></a>00426     <span class="keywordtype">int</span> i = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00427"></a>00427     assert(i &gt;= 0);
<a name="l00428"></a>00428     <span class="keywordflow">return</span> <a class="code" href="classMLN.html#e6ac28af43cb3957bdb41e5cfaa14929">clauseInNonExistAndNonExistUniqueFormulaCNF</a>(i);
<a name="l00429"></a>00429   }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     <span class="comment">// The list and its contents should not be modified.</span>
<a name="l00433"></a><a class="code" href="classMLN.html#b2e79bb2d2eadd547a2bae4ae03a4540">00433</a>   <span class="keyword">const</span> <a class="code" href="classHashArray.html">ClauseHashArray</a>* <a class="code" href="classMLN.html#b2e79bb2d2eadd547a2bae4ae03a4540">getClauses</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> clauses_; }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 
<a name="l00436"></a><a class="code" href="classMLN.html#8eea48393a9f9316decdbf7bc01725a0">00436</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#b2e79bb2d2eadd547a2bae4ae03a4540">getClauses</a>(<a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>* <span class="keyword">const</span> &amp; clauses)<span class="keyword"> const</span>
<a name="l00437"></a>00437 <span class="keyword">  </span>{ <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();i++) clauses-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*clauses_)[i]); }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 
<a name="l00440"></a><a class="code" href="classMLN.html#f4f91ea726841a108275268c250730a2">00440</a>   <span class="keyword">const</span> <a class="code" href="structMLNClauseInfo.html">MLNClauseInfo</a>* <a class="code" href="classMLN.html#f4f91ea726841a108275268c250730a2">getMLNClauseInfo</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)<span class="keyword"> const</span>
<a name="l00441"></a>00441 <span class="keyword">  </span>{
<a name="l00442"></a>00442     <span class="keywordflow">if</span> (i &lt; 0 || i &gt;= clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>()) <span class="keywordflow">return</span> NULL;
<a name="l00443"></a>00443     <span class="keywordflow">return</span> (*clauseInfos_)[i];
<a name="l00444"></a>00444   }
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 
<a name="l00447"></a><a class="code" href="classMLN.html#d7bf9bde7d29efd06babf0fdc4acdad3">00447</a>   <span class="keywordtype">int</span>* <a class="code" href="classMLN.html#d7bf9bde7d29efd06babf0fdc4acdad3">getMLNClauseInfoIndexPtr</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)<span class="keyword"> const</span>
<a name="l00448"></a>00448 <span class="keyword">  </span>{
<a name="l00449"></a>00449     assert(0 &lt;= i &amp;&amp; i &lt; clauseInfos_-&gt;size());
<a name="l00450"></a>00450     <span class="keywordflow">return</span> &amp;((*clauseInfos_)[i]-&gt;index);
<a name="l00451"></a>00451   }
<a name="l00452"></a>00452 
<a name="l00453"></a><a class="code" href="classMLN.html#88354ec82acf7611f5313e4aded418e8">00453</a>   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;MLNClauseInfo*&gt;</a>* <a class="code" href="classMLN.html#88354ec82acf7611f5313e4aded418e8">getMLNClauseInfos</a>()<span class="keyword"> const</span>
<a name="l00454"></a>00454 <span class="keyword">  </span>{ <span class="keywordflow">return</span> clauseInfos_; }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 
<a name="l00457"></a><a class="code" href="classMLN.html#9d46d953f87b69a6951b143bfc814e26">00457</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#9d46d953f87b69a6951b143bfc814e26">setClauseInfoPriorMeansToClauseWts</a>()
<a name="l00458"></a>00458   {
<a name="l00459"></a>00459     assert(clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() == clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00460"></a>00460     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00461"></a>00461       (*clauseInfos_)[i]-&gt;priorMean = (*clauses_)[i]-&gt;getWt();
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 
<a name="l00465"></a><a class="code" href="classMLN.html#d968ea39aa792b367d1ec5e1dff68389">00465</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#d968ea39aa792b367d1ec5e1dff68389">getClauseWts</a>(<a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; wts)<span class="keyword"> const</span>
<a name="l00466"></a>00466 <span class="keyword">  </span>{
<a name="l00467"></a>00467     wts.<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l00468"></a>00468     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++) 
<a name="l00469"></a>00469       wts.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*clauses_)[i]-&gt;getWt());
<a name="l00470"></a>00470   }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 
<a name="l00473"></a><a class="code" href="classMLN.html#681614a9e147dd2221d2623f0ad0441e">00473</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#681614a9e147dd2221d2623f0ad0441e">setClauseWts</a>(<a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; wts) 
<a name="l00474"></a>00474   {
<a name="l00475"></a>00475     assert (wts.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>());
<a name="l00476"></a>00476     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++) 
<a name="l00477"></a>00477       (*clauses_)[i]-&gt;setWt(wts[i]);
<a name="l00478"></a>00478   }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   
<a name="l00481"></a>00481   <span class="keyword">const</span> <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* 
<a name="l00482"></a><a class="code" href="classMLN.html#326f28254c08dee870f9629ad623da8f">00482</a>   <a class="code" href="classMLN.html#326f28254c08dee870f9629ad623da8f">getClausesOfFormula</a>(<span class="keyword">const</span> string&amp; formulaStr)<span class="keyword"> const</span>
<a name="l00483"></a>00483 <span class="keyword">  </span>{
<a name="l00484"></a>00484     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp(formulaStr, 0, <span class="keyword">false</span>);    
<a name="l00485"></a>00485     <span class="keywordtype">int</span> i = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00486"></a>00486     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> NULL;
<a name="l00487"></a>00487     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00488"></a>00488     <span class="keywordflow">return</span> fnc-&gt;<a class="code" href="structFormulaAndClauses.html#396d9482b3198729436c257f5b9602a2">indexClauses</a>;
<a name="l00489"></a>00489   }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 
<a name="l00492"></a>00492     <span class="comment">//Returns true if formulaStr is in mln and its numPred is set; otherwise,</span>
<a name="l00493"></a>00493     <span class="comment">//returns false.</span>
<a name="l00494"></a><a class="code" href="classMLN.html#f8bd355d267c3b24049faed19a457194">00494</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#f8bd355d267c3b24049faed19a457194">setFormulaNumPreds</a>(<span class="keyword">const</span> string&amp; formulaStr, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numPreds)
<a name="l00495"></a>00495   {
<a name="l00496"></a>00496     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp(formulaStr, 0, <span class="keyword">false</span>);    
<a name="l00497"></a>00497     <span class="keywordtype">int</span> i = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00498"></a>00498     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00499"></a>00499     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00500"></a>00500     fnc-&gt;<a class="code" href="structFormulaAndClauses.html#3aa0a9f1bfba8bbdaffba4222b5903f9">numPreds</a> = numPreds;
<a name="l00501"></a>00501     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00502"></a>00502   }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 
<a name="l00505"></a>00505     <span class="comment">//Returns true if formulaStr is in mln and its isHard is set; otherwise,</span>
<a name="l00506"></a>00506     <span class="comment">//returns false.</span>
<a name="l00507"></a><a class="code" href="classMLN.html#e3e63e684ac98f3b323eb872a0fbb5ea">00507</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#e3e63e684ac98f3b323eb872a0fbb5ea">setFormulaIsHard</a>(<span class="keyword">const</span> string&amp; formulaStr, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; isHard)
<a name="l00508"></a>00508   {
<a name="l00509"></a>00509     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp(formulaStr, 0, <span class="keyword">false</span>);    
<a name="l00510"></a>00510     <span class="keywordtype">int</span> i = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00511"></a>00511     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00512"></a>00512     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00513"></a>00513     fnc-&gt;<a class="code" href="structFormulaAndClauses.html#c849a89b678c203eee8bb674c252f47f">isHard</a> = isHard;
<a name="l00514"></a>00514     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00515"></a>00515   }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 
<a name="l00518"></a>00518     <span class="comment">//Returns true if formulaStr is in mln and its priorMean is set; otherwise,</span>
<a name="l00519"></a>00519     <span class="comment">//returns false.</span>
<a name="l00520"></a><a class="code" href="classMLN.html#faa7ca4e42c14b81c3d7b849d9bbc396">00520</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#faa7ca4e42c14b81c3d7b849d9bbc396">setFormulaPriorMean</a>(<span class="keyword">const</span> string&amp; formulaStr, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; priorMean)
<a name="l00521"></a>00521   {
<a name="l00522"></a>00522     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp(formulaStr, 0, <span class="keyword">false</span>);    
<a name="l00523"></a>00523     <span class="keywordtype">int</span> i = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00524"></a>00524     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00525"></a>00525     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00526"></a>00526     fnc-&gt;<a class="code" href="structFormulaAndClauses.html#cd689808987c3e4aefbe3ec4aaba3ee5">priorMean</a> = priorMean;
<a name="l00527"></a>00527     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00528"></a>00528   }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530     <span class="comment">//Returns true if formulaStr is in mln and its wt is set; otherwise,</span>
<a name="l00531"></a>00531     <span class="comment">//returns false.</span>
<a name="l00532"></a><a class="code" href="classMLN.html#841eb30a292a5d1e8d0790e83ec71fb3">00532</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#841eb30a292a5d1e8d0790e83ec71fb3">setFormulaWt</a>(<span class="keyword">const</span> string&amp; formulaStr, <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; wt)
<a name="l00533"></a>00533   {
<a name="l00534"></a>00534     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp(formulaStr, 0, <span class="keyword">false</span>);    
<a name="l00535"></a>00535     <span class="keywordtype">int</span> i = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00536"></a>00536     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00537"></a>00537     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00538"></a>00538     fnc-&gt;<a class="code" href="structFormulaAndClauses.html#048cd9fa26a308f8eea3c4e1d503418f">wt</a> = wt;
<a name="l00539"></a>00539     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="comment">//Returns true if formulaStr is in mln and its isExistUnique is set; </span>
<a name="l00544"></a>00544     <span class="comment">//otherwise returns false.</span>
<a name="l00545"></a><a class="code" href="classMLN.html#a5b3f815942f022fe3942c55a292f127">00545</a>   <span class="keywordtype">bool</span> <a class="code" href="classMLN.html#a5b3f815942f022fe3942c55a292f127">setFormulaIsExistUnique</a>(<span class="keyword">const</span> string&amp; formulaStr, 
<a name="l00546"></a>00546                                <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; isExistUnique)
<a name="l00547"></a>00547   {
<a name="l00548"></a>00548     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp(formulaStr, 0, <span class="keyword">false</span>);    
<a name="l00549"></a>00549     <span class="keywordtype">int</span> i = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00550"></a>00550     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00551"></a>00551     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00552"></a>00552     fnc-&gt;<a class="code" href="structFormulaAndClauses.html#481844e89fc193e74e1ad86076232860">isExistUnique</a> = isExistUnique;
<a name="l00553"></a>00553     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00554"></a>00554   }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 
<a name="l00557"></a>00557     <span class="comment">//formulaStr must be in MLN</span>
<a name="l00558"></a><a class="code" href="classMLN.html#a066c72b80e0014392d67566d7287b73">00558</a>   <span class="keywordtype">double</span> <a class="code" href="classMLN.html#a066c72b80e0014392d67566d7287b73">getFormulaWt</a>(<span class="keyword">const</span> string&amp; formulaStr)
<a name="l00559"></a>00559   {
<a name="l00560"></a>00560     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp(formulaStr, 0, <span class="keyword">false</span>);    
<a name="l00561"></a>00561     <span class="keywordtype">int</span> i = formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00562"></a>00562     <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00563"></a>00563     <span class="keywordflow">return</span> fnc-&gt;<a class="code" href="structFormulaAndClauses.html#048cd9fa26a308f8eea3c4e1d503418f">wt</a>;
<a name="l00564"></a>00564   }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 
<a name="l00567"></a><a class="code" href="classMLN.html#06360908288ca50c33483c17b1e3c45c">00567</a>   <span class="keyword">const</span> <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* <a class="code" href="classMLN.html#06360908288ca50c33483c17b1e3c45c">getFormulaAndClausesArray</a>()<span class="keyword"> const</span>
<a name="l00568"></a>00568 <span class="keyword">  </span>{ <span class="keywordflow">return</span> formAndClausesArray_; }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570   
<a name="l00571"></a>00571     <span class="comment">// Caller should not modify the returned array or its contents</span>
<a name="l00572"></a><a class="code" href="classMLN.html#7f01314f93c22c02200c6a5e91c95c0c">00572</a>   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Array&lt;IndexClause*&gt;</a>*&gt;* <a class="code" href="classMLN.html#7f01314f93c22c02200c6a5e91c95c0c">getPredIdToClausesMap</a>()<span class="keyword"> const</span>
<a name="l00573"></a>00573 <span class="keyword">  </span>{ <span class="keywordflow">return</span> predIdToClausesMap_; }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 
<a name="l00576"></a><a class="code" href="classMLN.html#fe5ab9aa70237fbbfa70541d90619eeb">00576</a>   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;IndexClause*&gt;</a>* <a class="code" href="classMLN.html#fe5ab9aa70237fbbfa70541d90619eeb">getClausesContainingPred</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; predId)<span class="keyword"> const</span>
<a name="l00577"></a>00577 <span class="keyword">  </span>{ 
<a name="l00578"></a>00578     <span class="keywordflow">if</span> (predId &lt; predIdToClausesMap_-&gt;size())
<a name="l00579"></a>00579       <span class="keywordflow">return</span> (*predIdToClausesMap_)[predId];
<a name="l00580"></a>00580     <span class="keywordflow">return</span> NULL;
<a name="l00581"></a>00581   }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583 
<a name="l00584"></a><a class="code" href="classMLN.html#b6209baa35bd3ac9c5962c00cdaa6cac">00584</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#b6209baa35bd3ac9c5962c00cdaa6cac">compress</a>()
<a name="l00585"></a>00585   {
<a name="l00586"></a>00586     clauses_-&gt;<a class="code" href="classHashArray.html#e113aa6f71b16def86aa32bbc2fee334">compress</a>();
<a name="l00587"></a>00587     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) 
<a name="l00588"></a>00588       (*clauseInfos_)[i]-&gt;compress();
<a name="l00589"></a>00589     clauseInfos_-&gt;<a class="code" href="classArray.html#d076eab62161d62c67aadebcc71e5cb2">compress</a>();
<a name="l00590"></a>00590     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00591"></a>00591       (*formAndClausesArray_)[i]-&gt;indexClauses-&gt;compress();
<a name="l00592"></a>00592     formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#e113aa6f71b16def86aa32bbc2fee334">compress</a>();
<a name="l00593"></a>00593     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; predIdToClausesMap_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00594"></a>00594       <span class="keywordflow">if</span> ((*predIdToClausesMap_)[i]) (*predIdToClausesMap_)[i]-&gt;compress();
<a name="l00595"></a>00595     predIdToClausesMap_-&gt;compress();
<a name="l00596"></a>00596   }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 
<a name="l00599"></a>00599     <span class="comment">//print formulas (commented out) followed by the clauses in its CNF</span>
<a name="l00600"></a><a class="code" href="classMLN.html#0a67efdbdda399ba380108a74e28445a">00600</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#0a67efdbdda399ba380108a74e28445a">printMLN</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)
<a name="l00601"></a>00601   {
<a name="l00602"></a>00602     <span class="keywordtype">int</span> outprec = 6;
<a name="l00603"></a>00603     out.precision(outprec);
<a name="l00604"></a>00604     out.setf(ios_base::left, ios_base::adjustfield);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     <span class="keyword">const</span> <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* fncArr = formAndClausesArray_;
<a name="l00607"></a>00607     
<a name="l00608"></a>00608     <a class="code" href="classArray.html">Array&lt;int&gt;</a> fncArrIdxs;
<a name="l00609"></a>00609     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fncArr-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00610"></a>00610       <span class="keywordflow">if</span> (!(*fncArr)[i]-&gt;hasExist &amp;&amp; !(*fncArr)[i]-&gt;isExistUnique) 
<a name="l00611"></a>00611         fncArrIdxs.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(i);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fncArr-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00614"></a>00614       <span class="keywordflow">if</span> ((*fncArr)[i]-&gt;isExistUnique) 
<a name="l00615"></a>00615         fncArrIdxs.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(i);
<a name="l00616"></a>00616     
<a name="l00617"></a>00617     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fncArr-&gt;size(); i++)
<a name="l00618"></a>00618       <span class="keywordflow">if</span> ((*fncArr)[i]-&gt;hasExist) 
<a name="l00619"></a>00619         fncArrIdxs.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(i);
<a name="l00620"></a>00620 
<a name="l00621"></a>00621       <span class="comment">// for each user-specified formula</span>
<a name="l00622"></a>00622     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; fncArrIdxs.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); ii++)  
<a name="l00623"></a>00623     {
<a name="l00624"></a>00624       <span class="keywordtype">int</span> i = fncArrIdxs[ii];
<a name="l00625"></a>00625       <span class="keywordtype">double</span> totalWt = 0;
<a name="l00626"></a>00626       <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* indexClauses = (*fncArr)[i]-&gt;indexClauses;
<a name="l00627"></a>00627       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; indexClauses-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00628"></a>00628       {
<a name="l00629"></a>00629         <a class="code" href="classClause.html">Clause</a>* c = (*indexClauses)[j]-&gt;clause;
<a name="l00630"></a>00630         totalWt += c-&gt;getWt()/getNumParentFormulas(c);
<a name="l00631"></a>00631       }
<a name="l00632"></a>00632         <span class="comment">// output the original formula and its weight</span>
<a name="l00633"></a>00633       out.width(0); out &lt;&lt; <span class="stringliteral">"// "</span>; out.width(outprec); 
<a name="l00634"></a>00634       out &lt;&lt; totalWt &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*fncArr)[i]-&gt;formula &lt;&lt; endl;
<a name="l00635"></a>00635       
<a name="l00636"></a>00636       <span class="keywordflow">if</span> ((*fncArr)[i]-&gt;hasExist || (*fncArr)[i]-&gt;isExistUnique)
<a name="l00637"></a>00637         out &lt;&lt; totalWt &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*fncArr)[i]-&gt;formula &lt;&lt;endl;
<a name="l00638"></a>00638       <span class="keywordflow">else</span>
<a name="l00639"></a>00639       {
<a name="l00640"></a>00640           <span class="comment">//output clauses derived from the original formula and their weights</span>
<a name="l00641"></a>00641         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; indexClauses-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00642"></a>00642         {
<a name="l00643"></a>00643           <a class="code" href="classClause.html">Clause</a>* c = (*indexClauses)[j]-&gt;clause;    
<a name="l00644"></a>00644           out.width(outprec); 
<a name="l00645"></a>00645           out &lt;&lt; c-&gt;getWt()/getNumParentFormulas(c) &lt;&lt; <span class="stringliteral">"  "</span>; 
<a name="l00646"></a>00646           c-&gt;printWithoutWtWithStrVar(out, domain);
<a name="l00647"></a>00647           out &lt;&lt; endl;
<a name="l00648"></a>00648         }
<a name="l00649"></a>00649       }
<a name="l00650"></a>00650       out &lt;&lt; endl;
<a name="l00651"></a>00651     }
<a name="l00652"></a>00652   }
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   
<a name="l00655"></a>00655     <span class="comment">//Print non-existential formulas (commented out) followed by the clauses in </span>
<a name="l00656"></a>00656     <span class="comment">//its CNF. Clause weights are divided among non-existential formulas.</span>
<a name="l00657"></a><a class="code" href="classMLN.html#335d42b4a7be52aadf6cfdc61f021f05">00657</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#335d42b4a7be52aadf6cfdc61f021f05">printMLNNonExistFormulas</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)
<a name="l00658"></a>00658   {
<a name="l00659"></a>00659     <span class="keywordtype">int</span> outprec = 6;
<a name="l00660"></a>00660     out.precision(outprec);
<a name="l00661"></a>00661     out.setf(ios_base::left, ios_base::adjustfield);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663       <span class="comment">// for each user-specified formula</span>
<a name="l00664"></a>00664     <span class="keyword">const</span> <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* fncArr = formAndClausesArray_;
<a name="l00665"></a>00665     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fncArr-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00666"></a>00666     {
<a name="l00667"></a>00667       <span class="keywordflow">if</span> ((*fncArr)[i]-&gt;hasExist || (*fncArr)[i]-&gt;isExistUnique) <span class="keywordflow">continue</span>;
<a name="l00668"></a>00668     
<a name="l00669"></a>00669       <span class="keywordtype">double</span> totalWt = 0;
<a name="l00670"></a>00670       <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* indexClauses = (*fncArr)[i]-&gt;indexClauses;
<a name="l00671"></a>00671       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; indexClauses-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00672"></a>00672       {
<a name="l00673"></a>00673         <a class="code" href="classClause.html">Clause</a>* c = (*indexClauses)[j]-&gt;clause;
<a name="l00674"></a>00674         <span class="comment">//assert(clauseOrdering-&gt;find(c) &gt;= 0);</span>
<a name="l00675"></a>00675         totalWt 
<a name="l00676"></a>00676           += c-&gt;getWt()/getNumNonExistNonExistUniqueParentFormulas(c);
<a name="l00677"></a>00677       }
<a name="l00678"></a>00678         <span class="comment">// output the original formula and its weight</span>
<a name="l00679"></a>00679       out.width(0); out &lt;&lt; <span class="stringliteral">"// "</span>; out.width(outprec); 
<a name="l00680"></a>00680       out &lt;&lt; totalWt &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; (*fncArr)[i]-&gt;formula &lt;&lt; endl;
<a name="l00681"></a>00681       
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         <span class="comment">//output the clauses derived from the original formula and their weights</span>
<a name="l00684"></a>00684       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; indexClauses-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00685"></a>00685       {
<a name="l00686"></a>00686         <a class="code" href="classClause.html">Clause</a>* c = (*indexClauses)[j]-&gt;clause;    
<a name="l00687"></a>00687         out.width(outprec); 
<a name="l00688"></a>00688         out &lt;&lt; c-&gt;getWt()/getNumNonExistNonExistUniqueParentFormulas(c)
<a name="l00689"></a>00689             &lt;&lt; <span class="stringliteral">"  "</span>; 
<a name="l00690"></a>00690         c-&gt;printWithoutWtWithStrVar(out, domain);
<a name="l00691"></a>00691         out &lt;&lt; endl;
<a name="l00692"></a>00692       }
<a name="l00693"></a>00693       out &lt;&lt; endl;
<a name="l00694"></a>00694     } 
<a name="l00695"></a>00695   }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     <span class="comment">//Print each non-existential clause as a single formula, followed by</span>
<a name="l00699"></a>00699     <span class="comment">//existential formulas</span>
<a name="l00700"></a><a class="code" href="classMLN.html#d1a0e021c18afb566a37b4025f451106">00700</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#d1a0e021c18afb566a37b4025f451106">printMLNClausesFormulas</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00701"></a>00701                                <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; includeIdx)
<a name="l00702"></a>00702   {
<a name="l00703"></a>00703     <span class="keywordtype">int</span> idx = 0;
<a name="l00704"></a>00704     <span class="keywordtype">int</span>* startIdx = (includeIdx) ? &amp;idx : NULL;
<a name="l00705"></a>00705     <span class="keywordtype">bool</span> includeExistClauses = <span class="keyword">false</span>;
<a name="l00706"></a>00706     <span class="keywordtype">bool</span> divideWtAmongExistFormulas = <span class="keyword">true</span>;
<a name="l00707"></a>00707     <span class="keywordtype">bool</span> sortByLen = <span class="keyword">true</span>;
<a name="l00708"></a>00708     <a class="code" href="classMLN.html#f8eb9ab1b9e01e5a76d41e62a262786b">printClausesWithWeights</a>(out, domain, startIdx, includeExistClauses,
<a name="l00709"></a>00709                             sortByLen, divideWtAmongExistFormulas);
<a name="l00710"></a>00710     printExistOrExistUniqueFormulasWithWeights(out, startIdx);
<a name="l00711"></a>00711   }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 
<a name="l00714"></a>00714     <span class="comment">//If includeExistClauses is false, we exclude clauses that ONLY appear</span>
<a name="l00715"></a>00715     <span class="comment">//in the CNFs of existential formulas.</span>
<a name="l00716"></a><a class="code" href="classMLN.html#f8eb9ab1b9e01e5a76d41e62a262786b">00716</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#f8eb9ab1b9e01e5a76d41e62a262786b">printClausesWithWeights</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00717"></a>00717                                <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; startIdx = NULL,
<a name="l00718"></a>00718                                <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; includeExistClauses=<span class="keyword">true</span>,
<a name="l00719"></a>00719                                <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; sortByLen=<span class="keyword">false</span>,
<a name="l00720"></a>00720                                <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; divWtAmongExistFormulas=<span class="keyword">false</span>)<span class="keyword"> const</span>
<a name="l00721"></a>00721 <span class="keyword">  </span>{
<a name="l00722"></a>00722     <a class="code" href="classArray.html">Array&lt;Clause*&gt;</a> ca;
<a name="l00723"></a>00723     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++) 
<a name="l00724"></a>00724     {
<a name="l00725"></a>00725       <span class="keywordflow">if</span> ( !includeExistClauses &amp;&amp; 
<a name="l00726"></a>00726            !<a class="code" href="classMLN.html#e6ac28af43cb3957bdb41e5cfaa14929">clauseInNonExistAndNonExistUniqueFormulaCNF</a>(i) ) <span class="keywordflow">continue</span>;
<a name="l00727"></a>00727       ca.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*clauses_)[i]);
<a name="l00728"></a>00728     }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730     <span class="keywordflow">if</span> (sortByLen) <a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">Clause::sortByLen</a>(ca);
<a name="l00731"></a>00731     <a class="code" href="classHashArray.html">ClauseHashArray</a> cha;
<a name="l00732"></a>00732     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ca.size(); i++) cha.<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(ca[i]);
<a name="l00733"></a>00733 
<a name="l00734"></a>00734     <a class="code" href="classMLN.html#f8eb9ab1b9e01e5a76d41e62a262786b">printClausesWithWeights</a>(out, domain, &amp;cha,startIdx,divWtAmongExistFormulas);
<a name="l00735"></a>00735   }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   
<a name="l00738"></a><a class="code" href="classMLN.html#2edf99f4c4be92551d001ba9503eeeec">00738</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#2edf99f4c4be92551d001ba9503eeeec">printClausePriorMeans</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain)
<a name="l00739"></a>00739   {
<a name="l00740"></a>00740     out.setf(ios_base::left, ios_base::adjustfield);    
<a name="l00741"></a>00741     out.precision(6);
<a name="l00742"></a>00742     assert(clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>());
<a name="l00743"></a>00743     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauses_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00744"></a>00744     {
<a name="l00745"></a>00745       out &lt;&lt; i &lt;&lt; <span class="stringliteral">":  "</span>; out.width(14); 
<a name="l00746"></a>00746       out &lt;&lt; (*clauseInfos_)[i]-&gt;priorMean; out.width(0); out &lt;&lt; <span class="stringliteral">" "</span>; 
<a name="l00747"></a>00747       (*clauses_)[i]-&gt;printWithoutWtWithStrVar(out, domain); 
<a name="l00748"></a>00748       out &lt;&lt; endl; 
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750     out.width(0);
<a name="l00751"></a>00751   }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753   
<a name="l00754"></a><a class="code" href="classMLN.html#1259457500f61aac7b293e6cc53a4bea">00754</a>   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#1259457500f61aac7b293e6cc53a4bea">printFormulaPriorMeans</a>(ostream&amp; out)
<a name="l00755"></a>00755   {
<a name="l00756"></a>00756     out.setf(ios_base::left, ios_base::adjustfield);
<a name="l00757"></a>00757     out.precision(6);
<a name="l00758"></a>00758     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00759"></a>00759     {
<a name="l00760"></a>00760       <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[i];
<a name="l00761"></a>00761       out &lt;&lt; i &lt;&lt; <span class="stringliteral">":  "</span>; out.width(14); 
<a name="l00762"></a>00762       out &lt;&lt; fnc-&gt;priorMean; out.width(0); 
<a name="l00763"></a>00763       out &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; fnc-&gt;formula &lt;&lt; endl;       
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765     out.width(0);
<a name="l00766"></a>00766   }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 
<a name="l00769"></a>00769  <span class="keyword">private</span>:
<a name="l00770"></a>00770   <span class="keywordtype">void</span> appendClauseInfo(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; clause, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; clauseIdx, 
<a name="l00771"></a>00771                         <span class="keywordtype">int</span>* <span class="keyword">const</span>&amp; formulaIdx, <span class="keywordtype">int</span>* <span class="keyword">const</span>&amp; clauseIdxForFormula)
<a name="l00772"></a>00772   {
<a name="l00773"></a>00773     assert(clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == clauseIdx);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     <a class="code" href="structMLNClauseInfo.html">MLNClauseInfo</a>* ci = <span class="keyword">new</span> <a class="code" href="structMLNClauseInfo.html">MLNClauseInfo</a>(clauseInfos_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00776"></a>00776     clauseInfos_-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(ci);
<a name="l00777"></a>00777 
<a name="l00778"></a>00778       <span class="comment">// keep track of appended clause's positions in predIdToClausesMap_</span>
<a name="l00779"></a>00779     <a class="code" href="classArray.html">Array&lt;PredIdClauseIndex*&gt;</a>&amp; piciArr = ci-&gt;predIdsClauseIndexes;
<a name="l00780"></a>00780     hash_set&lt;int&gt; seenPredIds;
<a name="l00781"></a>00781     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Predicate*&gt;</a>* preds = clause-&gt;<a class="code" href="classClause.html#cc256d935b1e07283188f03b5ac8cd57">getPredicates</a>();
<a name="l00782"></a>00782     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; preds-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00783"></a>00783     {
<a name="l00784"></a>00784       <span class="keywordtype">int</span> predId = (*preds)[i]-&gt;getId();
<a name="l00785"></a>00785         <span class="comment">//if we have already noted that clause contains pred</span>
<a name="l00786"></a>00786       <span class="keywordflow">if</span> (seenPredIds.find(predId) != seenPredIds.end()) <span class="keywordflow">continue</span>;
<a name="l00787"></a>00787       seenPredIds.insert(predId);
<a name="l00788"></a>00788       
<a name="l00789"></a>00789       <span class="keywordflow">if</span> (predId &gt;= predIdToClausesMap_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>())
<a name="l00790"></a>00790         predIdToClausesMap_-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(predId+1, NULL);
<a name="l00791"></a>00791       <a class="code" href="classArray.html">Array&lt;IndexClause*&gt;</a>*&amp; icArr = (*predIdToClausesMap_)[predId];
<a name="l00792"></a>00792       <span class="keywordflow">if</span> (icArr == NULL) icArr = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;IndexClause*&gt;</a>;
<a name="l00793"></a>00793       <a class="code" href="structIndexClause.html">IndexClause</a>* ic = <span class="keyword">new</span> <a class="code" href="structIndexClause.html">IndexClause</a>(icArr-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(), (<a class="code" href="classClause.html">Clause</a>*)clause);
<a name="l00794"></a>00794       icArr-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(ic);
<a name="l00795"></a>00795       
<a name="l00796"></a>00796       piciArr.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(<span class="keyword">new</span> <a class="code" href="structPredIdClauseIndex.html">PredIdClauseIndex</a>(predId, &amp;(ic-&gt;<a class="code" href="structIndexClause.html#dfd329b4c0babcab27f6be5afe8efa5d">index</a>)));
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     updateClauseInfo(clauseIdx, formulaIdx, clauseIdxForFormula);
<a name="l00800"></a>00800   }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802   
<a name="l00803"></a>00803   <span class="keywordtype">void</span> updateClauseInfo(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; clauseIdx, <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; formulaIdx, 
<a name="l00804"></a>00804                         <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; clauseIdxForFormula)
<a name="l00805"></a>00805   {
<a name="l00806"></a>00806     <a class="code" href="structMLNClauseInfo.html">MLNClauseInfo</a>* clauseInfo = (*clauseInfos_)[clauseIdx];
<a name="l00807"></a>00807       <span class="comment">// keep track of appendedClause's position in formAndClauseArray_    </span>
<a name="l00808"></a>00808     assert(*clauseIdxForFormula &gt;= 0);
<a name="l00809"></a>00809     <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr = clauseInfo-&gt;<a class="code" href="structMLNClauseInfo.html#598c05d1d8b2c211f63582a6358c3c92">formulaClauseIndexes</a>;
<a name="l00810"></a>00810 
<a name="l00811"></a>00811     fciArr.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(<span class="keyword">new</span> <a class="code" href="structFormulaClauseIndexes.html">FormulaClauseIndexes</a>(formulaIdx, clauseIdxForFormula));
<a name="l00812"></a>00812   }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 
<a name="l00815"></a>00815     <span class="comment">//Returns -1 if c is not found in MLN</span>
<a name="l00816"></a>00816   <span class="keywordtype">int</span> getNumParentFormulas(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const </span>
<a name="l00817"></a>00817 <span class="keyword">  </span>{
<a name="l00818"></a>00818     <span class="keywordtype">int</span> i = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00819"></a>00819     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> -1;
<a name="l00820"></a>00820     <span class="keywordflow">return</span> (*clauseInfos_)[i]-&gt;formulaClauseIndexes.size();
<a name="l00821"></a>00821   }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="keywordtype">int</span> getNumNonExistNonExistUniqueParentFormulas(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const </span>
<a name="l00825"></a>00825 <span class="keyword">  </span>{
<a name="l00826"></a>00826     <span class="keywordtype">int</span> i = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00827"></a>00827     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> -1;
<a name="l00828"></a>00828     <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr 
<a name="l00829"></a>00829       = (*clauseInfos_)[i]-&gt;formulaClauseIndexes;
<a name="l00830"></a>00830     <span class="keywordtype">int</span> n = 0;
<a name="l00831"></a>00831     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00832"></a>00832     {
<a name="l00833"></a>00833       <span class="keywordtype">int</span> fidx = *(fciArr[i]-&gt;formulaIndex);
<a name="l00834"></a>00834       <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[fidx];
<a name="l00835"></a>00835       <span class="keywordflow">if</span> (!fnc-&gt;<a class="code" href="structFormulaAndClauses.html#a93d5581ab3d824e3a77517e779869b1">hasExist</a> &amp;&amp; !fnc-&gt;<a class="code" href="structFormulaAndClauses.html#481844e89fc193e74e1ad86076232860">isExistUnique</a>) n++;
<a name="l00836"></a>00836     }
<a name="l00837"></a>00837     <span class="keywordflow">return</span> n;
<a name="l00838"></a>00838   }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 
<a name="l00841"></a>00841   <span class="keywordtype">int</span> getNumExistOrExistUniqueParentFormulas(<span class="keyword">const</span> <a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c)<span class="keyword"> const </span>
<a name="l00842"></a>00842 <span class="keyword">  </span>{
<a name="l00843"></a>00843     <span class="keywordtype">int</span> i = <a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);
<a name="l00844"></a>00844     <span class="keywordflow">if</span> (i &lt; 0) <span class="keywordflow">return</span> -1;
<a name="l00845"></a>00845     <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr 
<a name="l00846"></a>00846       = (*clauseInfos_)[i]-&gt;formulaClauseIndexes;
<a name="l00847"></a>00847     <span class="keywordtype">int</span> n = 0;
<a name="l00848"></a>00848     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00849"></a>00849     {
<a name="l00850"></a>00850       <span class="keywordtype">int</span> fidx = *(fciArr[i]-&gt;formulaIndex);
<a name="l00851"></a>00851       <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* fnc = (*formAndClausesArray_)[fidx];
<a name="l00852"></a>00852       <span class="keywordflow">if</span> (fnc-&gt;<a class="code" href="structFormulaAndClauses.html#a93d5581ab3d824e3a77517e779869b1">hasExist</a> || fnc-&gt;<a class="code" href="structFormulaAndClauses.html#481844e89fc193e74e1ad86076232860">isExistUnique</a>) n++;
<a name="l00853"></a>00853     }
<a name="l00854"></a>00854     <span class="keywordflow">return</span> n;
<a name="l00855"></a>00855   }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   <span class="keywordtype">void</span> <a class="code" href="classMLN.html#f8eb9ab1b9e01e5a76d41e62a262786b">printClausesWithWeights</a>(ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain,
<a name="l00859"></a>00859                                <span class="keyword">const</span> <a class="code" href="classHashArray.html">ClauseHashArray</a>* <span class="keyword">const</span> &amp; clauses,
<a name="l00860"></a>00860                                <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; startIdx,
<a name="l00861"></a>00861                                <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; divideWithAmongExistFormulas)<span class="keyword"> const</span>
<a name="l00862"></a>00862 <span class="keyword">  </span>{
<a name="l00863"></a>00863     out.setf(ios_base::left, ios_base::adjustfield);
<a name="l00864"></a>00864     <span class="keywordtype">int</span> i;
<a name="l00865"></a>00865     <span class="keywordflow">for</span> (i = 0; i &lt; clauses-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00866"></a>00866     {      
<a name="l00867"></a>00867       <span class="keywordflow">if</span> (startIdx) { out &lt;&lt; (*(startIdx))++ &lt;&lt; <span class="stringliteral">":  "</span>; out.width(14); }
<a name="l00868"></a>00868       <span class="keywordflow">else</span>          { out.width(10); }
<a name="l00869"></a>00869       
<a name="l00870"></a>00870       <span class="keywordtype">double</span> wt = (*clauses)[i]-&gt;getWt();
<a name="l00871"></a>00871       <span class="keywordflow">if</span> (divideWithAmongExistFormulas) 
<a name="l00872"></a>00872         wt /= 1+getNumExistOrExistUniqueParentFormulas((*clauses)[i]);
<a name="l00873"></a>00873 
<a name="l00874"></a>00874       out &lt;&lt; wt; out.width(0); out &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l00875"></a>00875       (*clauses)[i]-&gt;printWithoutWtWithStrVar(out, domain); 
<a name="l00876"></a>00876       out &lt;&lt; endl; 
<a name="l00877"></a>00877     }
<a name="l00878"></a>00878     out.width(0);
<a name="l00879"></a>00879   }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <span class="keywordtype">void</span> printExistOrExistUniqueFormulasWithWeights(ostream&amp; out, 
<a name="l00883"></a>00883                                                   <span class="keywordtype">int</span>* <span class="keyword">const</span> &amp; startIdx=NULL)
<a name="l00884"></a>00884   {
<a name="l00885"></a>00885     <span class="keywordtype">int</span> i;
<a name="l00886"></a>00886     <span class="keywordflow">for</span> (i = 0; i &lt; formAndClausesArray_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00887"></a>00887     {
<a name="l00888"></a>00888       <span class="keywordflow">if</span> (!(*formAndClausesArray_)[i]-&gt;hasExist &amp;&amp; 
<a name="l00889"></a>00889           !(*formAndClausesArray_)[i]-&gt;isExistUnique) <span class="keywordflow">continue</span>;
<a name="l00890"></a>00890       <span class="keywordtype">double</span> totalWt = 0;
<a name="l00891"></a>00891       <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* indexClauses 
<a name="l00892"></a>00892         = (*formAndClausesArray_)[i]-&gt;indexClauses;
<a name="l00893"></a>00893       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; indexClauses-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00894"></a>00894       {
<a name="l00895"></a>00895         <a class="code" href="classClause.html">Clause</a>* c = (*indexClauses)[j]-&gt;clause;
<a name="l00896"></a>00896         totalWt += c-&gt;<a class="code" href="classClause.html#e234aafdd6eb6df9db924e254d13f12e">getWt</a>()/getNumParentFormulas(c);
<a name="l00897"></a>00897       }
<a name="l00898"></a>00898       
<a name="l00899"></a>00899       <span class="keywordflow">if</span> (startIdx) { out &lt;&lt; (*(startIdx))++ &lt;&lt; <span class="stringliteral">":  "</span>; out.width(14); }
<a name="l00900"></a>00900       <span class="keywordflow">else</span>            { out.width(10); }
<a name="l00901"></a>00901       out &lt;&lt; totalWt; out.width(0); out &lt;&lt; <span class="stringliteral">" "</span> 
<a name="l00902"></a>00902           &lt;&lt; (*formAndClausesArray_)[i]-&gt;formula &lt;&lt;endl;
<a name="l00903"></a>00903     }
<a name="l00904"></a>00904   }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 
<a name="l00907"></a>00907  <span class="keyword">private</span>:
<a name="l00908"></a>00908   <a class="code" href="classHashArray.html">ClauseHashArray</a>* clauses_;
<a name="l00909"></a>00909   <a class="code" href="classArray.html">Array&lt;MLNClauseInfo*&gt;</a>* clauseInfos_;
<a name="l00910"></a>00910   <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* formAndClausesArray_;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912     <span class="comment">//predIdToClausesMap_[p] maps pred id p to an array of IndexClause.</span>
<a name="l00913"></a>00913     <span class="comment">//The clause in each IndexClause contains a pred with id p, and the </span>
<a name="l00914"></a>00914     <span class="comment">//index is the index of the IndexClause in predIdToClausesMap_[p].</span>
<a name="l00915"></a>00915     <span class="comment">//predIdToClausesMap_[p] may be NULL.</span>
<a name="l00916"></a>00916   <a class="code" href="classArray.html">Array&lt;Array&lt;IndexClause*&gt;</a>*&gt;* predIdToClausesMap_;
<a name="l00917"></a>00917 
<a name="l00918"></a>00918 };
<a name="l00919"></a>00919 
<a name="l00920"></a>00920 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 14 15:15:19 2007 for Alchemy by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
