<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Alchemy: src/learnwts/indextranslator.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_bad0962745a374caf6e9fb10c9087375.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_95afe10acce5cfd792f3274cc07b28c3.html">learnwts</a></div>
<h1>indextranslator.h</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * All of the documentation and software included in the</span>
<a name="l00003"></a>00003 <span class="comment"> * Alchemy Software is copyrighted by Stanley Kok, Parag</span>
<a name="l00004"></a>00004 <span class="comment"> * Singla, Matthew Richardson, Pedro Domingos, Marc</span>
<a name="l00005"></a>00005 <span class="comment"> * Sumner and Hoifung Poon.</span>
<a name="l00006"></a>00006 <span class="comment"> * </span>
<a name="l00007"></a>00007 <span class="comment"> * Copyright [2004-07] Stanley Kok, Parag Singla, Matthew</span>
<a name="l00008"></a>00008 <span class="comment"> * Richardson, Pedro Domingos, Marc Sumner and Hoifung</span>
<a name="l00009"></a>00009 <span class="comment"> * Poon. All rights reserved.</span>
<a name="l00010"></a>00010 <span class="comment"> * </span>
<a name="l00011"></a>00011 <span class="comment"> * Contact: Pedro Domingos, University of Washington</span>
<a name="l00012"></a>00012 <span class="comment"> * (pedrod@cs.washington.edu).</span>
<a name="l00013"></a>00013 <span class="comment"> * </span>
<a name="l00014"></a>00014 <span class="comment"> * Redistribution and use in source and binary forms, with</span>
<a name="l00015"></a>00015 <span class="comment"> * or without modification, are permitted provided that</span>
<a name="l00016"></a>00016 <span class="comment"> * the following conditions are met:</span>
<a name="l00017"></a>00017 <span class="comment"> * </span>
<a name="l00018"></a>00018 <span class="comment"> * 1. Redistributions of source code must retain the above</span>
<a name="l00019"></a>00019 <span class="comment"> * copyright notice, this list of conditions and the</span>
<a name="l00020"></a>00020 <span class="comment"> * following disclaimer.</span>
<a name="l00021"></a>00021 <span class="comment"> * </span>
<a name="l00022"></a>00022 <span class="comment"> * 2. Redistributions in binary form must reproduce the</span>
<a name="l00023"></a>00023 <span class="comment"> * above copyright notice, this list of conditions and the</span>
<a name="l00024"></a>00024 <span class="comment"> * following disclaimer in the documentation and/or other</span>
<a name="l00025"></a>00025 <span class="comment"> * materials provided with the distribution.</span>
<a name="l00026"></a>00026 <span class="comment"> * </span>
<a name="l00027"></a>00027 <span class="comment"> * 3. All advertising materials mentioning features or use</span>
<a name="l00028"></a>00028 <span class="comment"> * of this software must display the following</span>
<a name="l00029"></a>00029 <span class="comment"> * acknowledgment: "This product includes software</span>
<a name="l00030"></a>00030 <span class="comment"> * developed by Stanley Kok, Parag Singla, Matthew</span>
<a name="l00031"></a>00031 <span class="comment"> * Richardson, Pedro Domingos, Marc Sumner and Hoifung</span>
<a name="l00032"></a>00032 <span class="comment"> * Poon in the Department of Computer Science and</span>
<a name="l00033"></a>00033 <span class="comment"> * Engineering at the University of Washington".</span>
<a name="l00034"></a>00034 <span class="comment"> * </span>
<a name="l00035"></a>00035 <span class="comment"> * 4. Your publications acknowledge the use or</span>
<a name="l00036"></a>00036 <span class="comment"> * contribution made by the Software to your research</span>
<a name="l00037"></a>00037 <span class="comment"> * using the following citation(s): </span>
<a name="l00038"></a>00038 <span class="comment"> * Stanley Kok, Parag Singla, Matthew Richardson and</span>
<a name="l00039"></a>00039 <span class="comment"> * Pedro Domingos (2005). "The Alchemy System for</span>
<a name="l00040"></a>00040 <span class="comment"> * Statistical Relational AI", Technical Report,</span>
<a name="l00041"></a>00041 <span class="comment"> * Department of Computer Science and Engineering,</span>
<a name="l00042"></a>00042 <span class="comment"> * University of Washington, Seattle, WA.</span>
<a name="l00043"></a>00043 <span class="comment"> * http://www.cs.washington.edu/ai/alchemy.</span>
<a name="l00044"></a>00044 <span class="comment"> * </span>
<a name="l00045"></a>00045 <span class="comment"> * 5. Neither the name of the University of Washington nor</span>
<a name="l00046"></a>00046 <span class="comment"> * the names of its contributors may be used to endorse or</span>
<a name="l00047"></a>00047 <span class="comment"> * promote products derived from this software without</span>
<a name="l00048"></a>00048 <span class="comment"> * specific prior written permission.</span>
<a name="l00049"></a>00049 <span class="comment"> * </span>
<a name="l00050"></a>00050 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF WASHINGTON</span>
<a name="l00051"></a>00051 <span class="comment"> * AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED</span>
<a name="l00052"></a>00052 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</span>
<a name="l00053"></a>00053 <span class="comment"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<a name="l00054"></a>00054 <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY</span>
<a name="l00055"></a>00055 <span class="comment"> * OF WASHINGTON OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,</span>
<a name="l00056"></a>00056 <span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<a name="l00057"></a>00057 <span class="comment"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<a name="l00058"></a>00058 <span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<a name="l00059"></a>00059 <span class="comment"> * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON</span>
<a name="l00060"></a>00060 <span class="comment"> * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<a name="l00061"></a>00061 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<a name="l00062"></a>00062 <span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN</span>
<a name="l00063"></a>00063 <span class="comment"> * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00064"></a>00064 <span class="comment"> * </span>
<a name="l00065"></a>00065 <span class="comment"> */</span>
<a name="l00066"></a>00066 <span class="preprocessor">#ifndef INDEXTRANSLATOR_H_NOV_29_2005</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define INDEXTRANSLATOR_H_NOV_29_2005</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="preprocessor">#include "mln.h"</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="comment">//NOTE: "domain index" and "database index" are used interchangeably</span>
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="structIdxDiv.html#9504adbff81cb196a2a30048b522b320">00074</a> <span class="keyword">struct </span><a class="code" href="structIdxDiv.html">IdxDiv</a> { <span class="keywordtype">int</span> <a class="code" href="structIdxDiv.html#9504adbff81cb196a2a30048b522b320">idx</a>; <span class="keywordtype">double</span> <a class="code" href="structIdxDiv.html#b648e62f3aca6121ca171f74f2c1132c">div</a>; };
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 
<a name="l00077"></a><a class="code" href="classIndexTranslator.html">00077</a> <span class="keyword">class </span><a class="code" href="classIndexTranslator.html">IndexTranslator</a>
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079  <span class="keyword">public</span>:
<a name="l00080"></a><a class="code" href="classIndexTranslator.html#01d4ce85c295480dbeeb3363be02857b">00080</a>   <a class="code" href="classIndexTranslator.html#01d4ce85c295480dbeeb3363be02857b">IndexTranslator</a>(<span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;MLN*&gt;</a>* <span class="keyword">const</span> &amp; mlns, 
<a name="l00081"></a>00081                   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Domain*&gt;</a>* <span class="keyword">const</span> &amp; domains) 
<a name="l00082"></a>00082     : mlns_(mlns), domains_(domains), cIdxToCFIdxsPerDomain_(NULL), 
<a name="l00083"></a>00083       wtsPerDomain_(NULL), gradsPerDomain_(NULL),
<a name="l00084"></a>00084       clauseOrdering_(NULL), existFormulaOrdering_(NULL) 
<a name="l00085"></a>00085   { <a class="code" href="classIndexTranslator.html#86ee7e77520cea51f784076aae88ef58">createClauseIdxToClauseFormulaIdxsMap</a>(); }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 
<a name="l00088"></a><a class="code" href="classIndexTranslator.html#09f035da73d84b79be1b97dd3156e133">00088</a>   <a class="code" href="classIndexTranslator.html#09f035da73d84b79be1b97dd3156e133">~IndexTranslator</a>() 
<a name="l00089"></a>00089   {
<a name="l00090"></a>00090     <span class="keywordflow">if</span> (cIdxToCFIdxsPerDomain_) 
<a name="l00091"></a>00091     {
<a name="l00092"></a>00092       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cIdxToCFIdxsPerDomain_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00093"></a>00093         (*cIdxToCFIdxsPerDomain_)[i].deleteItemsAndClear();
<a name="l00094"></a>00094       <span class="keyword">delete</span> cIdxToCFIdxsPerDomain_;
<a name="l00095"></a>00095     }
<a name="l00096"></a>00096     <span class="keywordflow">if</span> (wtsPerDomain_) <span class="keyword">delete</span> wtsPerDomain_;
<a name="l00097"></a>00097     <span class="keywordflow">if</span> (gradsPerDomain_) <span class="keyword">delete</span> gradsPerDomain_;
<a name="l00098"></a>00098     <span class="keywordflow">if</span> (clauseOrdering_) 
<a name="l00099"></a>00099     { clauseOrdering_-&gt;<a class="code" href="classHashArray.html#f98170f652a937097e189498bd641085">deleteItemsAndClear</a>(); <span class="keyword">delete</span> clauseOrdering_; }
<a name="l00100"></a>00100     <span class="keywordflow">if</span> (existFormulaOrdering_) <span class="keyword">delete</span> existFormulaOrdering_;
<a name="l00101"></a>00101   }    
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     <span class="comment">//Returns true if there are multiple databases, and there are formulas</span>
<a name="l00105"></a>00105     <span class="comment">//whose CNF contains a different number of clauses for each database;</span>
<a name="l00106"></a>00106     <span class="comment">//otherwise returns false. </span>
<a name="l00107"></a>00107     <span class="comment">//ASSUMPTION: the MLNs were formed from parsing the same .mln file</span>
<a name="l00108"></a><a class="code" href="classIndexTranslator.html#64337d12d5dbe4e7aa5f13c0ded6e31c">00108</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classIndexTranslator.html#64337d12d5dbe4e7aa5f13c0ded6e31c">needIndexTranslator</a>(<span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;MLN*&gt;</a>&amp; mlns,
<a name="l00109"></a>00109                                   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Domain*&gt;</a>&amp; domains)
<a name="l00110"></a>00110   {
<a name="l00111"></a>00111     <span class="keywordflow">if</span> (mlns.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &lt;= 1) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; mlns.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00114"></a>00114       <span class="keywordflow">if</span> (mlns[0]-&gt;getNumClauses() != mlns[i]-&gt;getNumClauses()) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <span class="comment">//there are more than one MLN and all MLNs have the same number of clauses</span>
<a name="l00117"></a>00117     <span class="comment">//now check whether all tie-able formulas have one clause in their CNF</span>
<a name="l00118"></a>00118 
<a name="l00119"></a>00119     <span class="keywordtype">bool</span> allTiedFormulasHaveOneClause = <span class="keyword">true</span>;
<a name="l00120"></a>00120     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mlns.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00121"></a>00121     {
<a name="l00122"></a>00122       <span class="keyword">const</span> <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* fnca = mlns[i]-&gt;getFormulaAndClausesArray();
<a name="l00123"></a>00123       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; fnca-&gt;size(); j++)
<a name="l00124"></a>00124       {
<a name="l00125"></a>00125         <span class="keywordflow">if</span> (formulaWtTiedToClauseWts((*fnca)[j]) &amp;&amp; 
<a name="l00126"></a>00126             (*fnca)[j]-&gt;indexClauses-&gt;size() &gt; 1)
<a name="l00127"></a>00127         { 
<a name="l00128"></a>00128           allTiedFormulasHaveOneClause = <span class="keyword">false</span>;
<a name="l00129"></a>00129           <span class="keywordflow">break</span>;
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131       }
<a name="l00132"></a>00132       <span class="keywordflow">if</span> (!allTiedFormulasHaveOneClause) <span class="keywordflow">break</span>;
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">if</span> (allTiedFormulasHaveOneClause) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     <span class="comment">//all MLNs have the same number of clauses, and a tie-able formula</span>
<a name="l00138"></a>00138     <span class="comment">//has more than one clause</span>
<a name="l00139"></a>00139     
<a name="l00140"></a>00140     <span class="comment">//now check that the tie-able clauses are exactly the same across databases</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mlns[0]-&gt;getNumClauses(); i++)
<a name="l00143"></a>00143     {
<a name="l00144"></a>00144         <span class="comment">//if this is a clause whose wt can be tied to the formula wt</span>
<a name="l00145"></a>00145       <span class="keywordflow">if</span> (tieClauseWtToFormulaWt(mlns[0], i))
<a name="l00146"></a>00146       {
<a name="l00147"></a>00147         ostringstream oss0;
<a name="l00148"></a>00148         mlns[0]-&gt;getClause(i)-&gt;printWithoutWtWithStrVar(oss0, domains[0]);
<a name="l00149"></a>00149         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; mlns.size(); j++)
<a name="l00150"></a>00150         {
<a name="l00151"></a>00151           ostringstream ossj;
<a name="l00152"></a>00152           mlns[j]-&gt;getClause(i)-&gt;printWithoutWtWithStrVar(ossj, domains[j]);
<a name="l00153"></a>00153           <span class="keywordflow">if</span> (oss0.str().compare(ossj.str()) != 0) <span class="keywordflow">return</span> <span class="keyword">true</span>;          
<a name="l00154"></a>00154         }
<a name="l00155"></a>00155       }
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157     
<a name="l00158"></a>00158     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00159"></a>00159   }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Array&lt;Array&lt;IdxDiv&gt;</a>*&gt; &gt;* 
<a name="l00163"></a><a class="code" href="classIndexTranslator.html#f93f73d244ade1610e0f50b208a6a388">00163</a>   <a class="code" href="classIndexTranslator.html#f93f73d244ade1610e0f50b208a6a388">getClauseIdxToClauseFormulaIdxsPerDomain</a>()<span class="keyword"> const </span>
<a name="l00164"></a>00164 <span class="keyword">  </span>{ <span class="keywordflow">return</span> cIdxToCFIdxsPerDomain_; }
<a name="l00165"></a>00165 
<a name="l00166"></a><a class="code" href="classIndexTranslator.html#c9d4944f0158d9b747cab42085a5c158">00166</a>   <a class="code" href="classArray.html">Array&lt;Array&lt;double&gt;</a> &gt;* <a class="code" href="classIndexTranslator.html#c9d4944f0158d9b747cab42085a5c158">getWtsPerDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> wtsPerDomain_; }
<a name="l00167"></a>00167 
<a name="l00168"></a><a class="code" href="classIndexTranslator.html#86306a11f1276c33c12221d4d783d4d8">00168</a>   <a class="code" href="classArray.html">Array&lt;Array&lt;double&gt;</a> &gt;* <a class="code" href="classIndexTranslator.html#86306a11f1276c33c12221d4d783d4d8">getGradsPerDomain</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> gradsPerDomain_; }
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="classIndexTranslator.html#19d26a58e644c3517e6012e34eb737c3">00170</a>   <span class="keyword">const</span> <a class="code" href="classHashArray.html">ClauseHashArray</a>* <a class="code" href="classIndexTranslator.html#19d26a58e644c3517e6012e34eb737c3">getClauseOrdering</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> clauseOrdering_; }
<a name="l00171"></a>00171 
<a name="l00172"></a><a class="code" href="classIndexTranslator.html#bcb05e971268f80b753e39425958a651">00172</a>   <span class="keyword">const</span> <a class="code" href="classHashArray.html">StringHashArray</a>* <a class="code" href="classIndexTranslator.html#bcb05e971268f80b753e39425958a651">getExistFormulaOrdering</a>()<span class="keyword"> const </span>
<a name="l00173"></a>00173 <span class="keyword">  </span>{ <span class="keywordflow">return</span> existFormulaOrdering_; }
<a name="l00174"></a>00174 
<a name="l00175"></a><a class="code" href="classIndexTranslator.html#29f2569ee801d867d9fa5c80fd2d3710">00175</a>   <span class="keywordtype">int</span> <a class="code" href="classIndexTranslator.html#29f2569ee801d867d9fa5c80fd2d3710">getNumClausesAndExistFormulas</a>()<span class="keyword"> const </span>
<a name="l00176"></a>00176 <span class="keyword">  </span>{ <span class="keywordflow">return</span> clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() + existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178   
<a name="l00179"></a>00179     <span class="comment">//check that the sizes of cIdxToCFIdxsPerDomain_[d], wtsPerDomain_[d], and</span>
<a name="l00180"></a>00180     <span class="comment">//gradsPerDomain_[d] is equal to the num of clauses in mln_[d] + numAdded</span>
<a name="l00181"></a><a class="code" href="classIndexTranslator.html#920dbf0ae6a34721ec302e8365fa6bf4">00181</a>   <span class="keywordtype">bool</span> <a class="code" href="classIndexTranslator.html#920dbf0ae6a34721ec302e8365fa6bf4">checkCIdxWtsGradsSize</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numAdded)
<a name="l00182"></a>00182   {
<a name="l00183"></a>00183     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) <span class="comment">// for each domain</span>
<a name="l00184"></a>00184     {
<a name="l00185"></a>00185       <span class="keywordtype">int</span> sz = (*mlns_)[i]-&gt;getNumClauses() + numAdded;
<a name="l00186"></a>00186       <span class="keywordflow">if</span> ((*cIdxToCFIdxsPerDomain_)[i].size() != sz) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00187"></a>00187       <span class="keywordflow">if</span> ((*wtsPerDomain_)[i].size() != sz) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00188"></a>00188       <span class="keywordflow">if</span> ((*gradsPerDomain_)[i].size() != sz) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00189"></a>00189     }
<a name="l00190"></a>00190     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 
<a name="l00194"></a>00194     <span class="comment">//Size of wts must be sum of the sizes of clauseOrdering_, </span>
<a name="l00195"></a>00195     <span class="comment">//existFormulaOrdering_, appendedClauses, and appendedFormulas.</span>
<a name="l00196"></a><a class="code" href="classIndexTranslator.html#f60c17c1c674b65c7e7998c38638f324">00196</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#f60c17c1c674b65c7e7998c38638f324">updateClauseFormulaWtsInMLNs</a>(<span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; wts,
<a name="l00197"></a>00197                                     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Clause*&gt;</a>*<span class="keyword">const</span>&amp; appendedClauses,
<a name="l00198"></a>00198                                     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;string&gt;</a>*<span class="keyword">const</span>&amp; appendedFormulas)
<a name="l00199"></a>00199   {
<a name="l00200"></a>00200     assert(appendedClauses == NULL || appendedFormulas == NULL);
<a name="l00201"></a>00201     <a class="code" href="classDomain.html">Domain</a>* dom0 = (*domains_)[0];
<a name="l00202"></a>00202     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) <span class="comment">// for each domain</span>
<a name="l00203"></a>00203     {
<a name="l00204"></a>00204       <a class="code" href="classMLN.html">MLN</a>* mln = (*mlns_)[i];
<a name="l00205"></a>00205       <a class="code" href="classDomain.html">Domain</a>* dom = (*domains_)[i];
<a name="l00206"></a>00206 
<a name="l00207"></a>00207       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00208"></a>00208       {
<a name="l00209"></a>00209         <a class="code" href="classClause.html">Clause</a>* c = (*clauseOrdering_)[j];
<a name="l00210"></a>00210         <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; c-&gt;containsConstants()) c-&gt;translateConstants(dom0, dom);
<a name="l00211"></a>00211         <a class="code" href="classClause.html">Clause</a>* cc = (<a class="code" href="classClause.html">Clause</a>*) mln-&gt;findClause(c);
<a name="l00212"></a>00212         <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; c-&gt;containsConstants()) c-&gt;translateConstants(dom, dom0);
<a name="l00213"></a>00213         cc-&gt;<a class="code" href="classClause.html#f80c37e7dfbe0805aad5026ae91cadb4">setWt</a>(wts[j]);
<a name="l00214"></a>00214       }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216       <span class="keywordtype">int</span> offset = clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00217"></a>00217 
<a name="l00218"></a>00218       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00219"></a>00219         mln-&gt;setFormulaWt((*existFormulaOrdering_)[j], wts[offset+j]);
<a name="l00220"></a>00220 
<a name="l00221"></a>00221       offset += existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00222"></a>00222 
<a name="l00223"></a>00223       <span class="keywordflow">if</span> (appendedClauses)
<a name="l00224"></a>00224       {
<a name="l00225"></a>00225         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; appendedClauses-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l00226"></a>00226         {
<a name="l00227"></a>00227           <a class="code" href="classClause.html">Clause</a>* c = (*appendedClauses)[j];
<a name="l00228"></a>00228           <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; c-&gt;containsConstants()) c-&gt;translateConstants(dom0, dom);
<a name="l00229"></a>00229           <a class="code" href="classClause.html">Clause</a>* cc = (<a class="code" href="classClause.html">Clause</a>*) mln-&gt;findClause(c);
<a name="l00230"></a>00230           <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; c-&gt;containsConstants()) c-&gt;translateConstants(dom, dom0);
<a name="l00231"></a>00231           cc-&gt;<a class="code" href="classClause.html#f80c37e7dfbe0805aad5026ae91cadb4">setWt</a>(wts[offset+j]);
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233       }
<a name="l00234"></a>00234       <span class="keywordflow">else</span>
<a name="l00235"></a>00235       <span class="keywordflow">if</span> (appendedFormulas)
<a name="l00236"></a>00236       {
<a name="l00237"></a>00237         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; appendedFormulas-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l00238"></a>00238           mln-&gt;setFormulaWt((*appendedFormulas)[j], wts[offset+j]);
<a name="l00239"></a>00239       }       
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241   }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00244"></a><a class="code" href="classIndexTranslator.html#6196e701024038283a640027c78e9775">00244</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#6196e701024038283a640027c78e9775">getClauseFormulaWts</a>(<a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; wts)<span class="keyword"> const</span>
<a name="l00245"></a>00245 <span class="keyword">  </span>{
<a name="l00246"></a>00246     wts.<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l00247"></a>00247     wts.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() + existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>());
<a name="l00248"></a>00248     <span class="keywordtype">int</span> a = 0;
<a name="l00249"></a>00249     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00250"></a>00250       wts[a++] = (*mlns_)[0]-&gt;findClause((*clauseOrdering_)[j])-&gt;getWt();
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); j++)
<a name="l00253"></a>00253       wts[a++] = (*mlns_)[0]-&gt;getFormulaWt((*existFormulaOrdering_)[j]);    
<a name="l00254"></a>00254   }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00257"></a>00257     <span class="comment">//There must be more than one MLN in mlns. The size of mlns_ must be the </span>
<a name="l00258"></a>00258     <span class="comment">//same as the size of domains_.</span>
<a name="l00259"></a><a class="code" href="classIndexTranslator.html#86ee7e77520cea51f784076aae88ef58">00259</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#86ee7e77520cea51f784076aae88ef58">createClauseIdxToClauseFormulaIdxsMap</a>()
<a name="l00260"></a>00260   {
<a name="l00261"></a>00261     assert(mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == domains_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00262"></a>00262     <span class="keywordflow">if</span> (mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &lt;= 1) <span class="keywordflow">return</span>;
<a name="l00263"></a>00263     <span class="keywordflow">if</span> (cIdxToCFIdxsPerDomain_) 
<a name="l00264"></a>00264     {
<a name="l00265"></a>00265       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cIdxToCFIdxsPerDomain_-&gt;size(); i++)
<a name="l00266"></a>00266         (*cIdxToCFIdxsPerDomain_)[i].deleteItemsAndClear();
<a name="l00267"></a>00267       <span class="keyword">delete</span> cIdxToCFIdxsPerDomain_;
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269     <span class="keywordflow">if</span> (wtsPerDomain_) <span class="keyword">delete</span> wtsPerDomain_;
<a name="l00270"></a>00270     <span class="keywordflow">if</span> (gradsPerDomain_) <span class="keyword">delete</span> gradsPerDomain_;
<a name="l00271"></a>00271     <span class="keywordflow">if</span> (clauseOrdering_)     
<a name="l00272"></a>00272     { clauseOrdering_-&gt;<a class="code" href="classHashArray.html#f98170f652a937097e189498bd641085">deleteItemsAndClear</a>(); <span class="keyword">delete</span> clauseOrdering_; }
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (existFormulaOrdering_) <span class="keyword">delete</span> existFormulaOrdering_;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     trackClauseConstants();
<a name="l00276"></a>00276     clauseOrdering_ = <span class="keyword">new</span> <a class="code" href="classHashArray.html">ClauseHashArray</a>;
<a name="l00277"></a>00277     existFormulaOrdering_ = <span class="keyword">new</span> <a class="code" href="classHashArray.html">StringHashArray</a>;
<a name="l00278"></a>00278     createClausesFormulasOrdering((*mlns_)[0], clauseOrdering_, 
<a name="l00279"></a>00279                                   existFormulaOrdering_);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     cIdxToCFIdxsPerDomain_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;Array&lt;IdxDiv&gt;</a>*&gt; &gt;;
<a name="l00282"></a>00282     wtsPerDomain_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;double&gt;</a> &gt;;
<a name="l00283"></a>00283     gradsPerDomain_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;Array&lt;double&gt;</a> &gt;;
<a name="l00284"></a>00284     cIdxToCFIdxsPerDomain_-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00285"></a>00285     wtsPerDomain_-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00286"></a>00286     gradsPerDomain_-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     <a class="code" href="classDomain.html">Domain</a>* dom0 = (*domains_)[0];
<a name="l00289"></a>00289     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++) <span class="comment">// for each domain</span>
<a name="l00290"></a>00290     {
<a name="l00291"></a>00291       <a class="code" href="classMLN.html">MLN</a>* mln = (*mlns_)[i];
<a name="l00292"></a>00292       <a class="code" href="classDomain.html">Domain</a>* dom = (*domains_)[i];
<a name="l00293"></a>00293       <span class="keyword">const</span> <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* fnca = mln-&gt;getFormulaAndClausesArray();
<a name="l00294"></a>00294       <a class="code" href="classArray.html">Array&lt;Array&lt;IdxDiv&gt;</a>*&gt;&amp; cIdxToCFIdxsMap = (*cIdxToCFIdxsPerDomain_)[i];
<a name="l00295"></a>00295       cIdxToCFIdxsMap.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(mln-&gt;getNumClauses());
<a name="l00296"></a>00296       (*wtsPerDomain_)[i].growToSize(mln-&gt;getNumClauses());
<a name="l00297"></a>00297       (*gradsPerDomain_)[i].growToSize(mln-&gt;getNumClauses());
<a name="l00298"></a>00298 
<a name="l00299"></a>00299       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; mln-&gt;getNumClauses(); j++) <span class="comment">// for each clause in MLN</span>
<a name="l00300"></a>00300       {
<a name="l00301"></a>00301         <a class="code" href="classArray.html">Array&lt;IdxDiv&gt;</a>* cfIdxs = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;IdxDiv&gt;</a>;
<a name="l00302"></a>00302         cIdxToCFIdxsMap[j] = cfIdxs;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304           <span class="comment">//if we don't need to tie the clause weight to formula weight as when</span>
<a name="l00305"></a>00305           <span class="comment">//this clause is in the CNF of a non-existentially quant. and</span>
<a name="l00306"></a>00306           <span class="comment">//non-existentially and uniquely quant. formula.</span>
<a name="l00307"></a>00307         <span class="keywordflow">if</span> (noTieClauseWtToFormulaWt(mln,j))
<a name="l00308"></a>00308         {
<a name="l00309"></a>00309           <a class="code" href="classClause.html">Clause</a>* c = (<a class="code" href="classClause.html">Clause</a>*) mln-&gt;getClause(j);
<a name="l00310"></a>00310           <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; c-&gt;<a class="code" href="classClause.html#a77a39136edd846f6581b1973ddb9577">containsConstants</a>()) c-&gt;<a class="code" href="classClause.html#fdbd3f430d505104dfb2681a31f6c905">translateConstants</a>(dom, dom0);
<a name="l00311"></a>00311           <span class="keywordtype">int</span> idx = clauseOrdering_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(c);
<a name="l00312"></a>00312           cfIdxs-&gt;append(<a class="code" href="structIdxDiv.html">IdxDiv</a>());
<a name="l00313"></a>00313           cfIdxs-&gt;lastItem().idx = idx;
<a name="l00314"></a>00314           cfIdxs-&gt;lastItem().div = 1;
<a name="l00315"></a>00315           <span class="keywordflow">if</span> (i &gt; 0 &amp;&amp; c-&gt;<a class="code" href="classClause.html#a77a39136edd846f6581b1973ddb9577">containsConstants</a>()) c-&gt;<a class="code" href="classClause.html#fdbd3f430d505104dfb2681a31f6c905">translateConstants</a>(dom0, dom);
<a name="l00316"></a>00316           <span class="keywordflow">if</span> (idx &lt; 0) 
<a name="l00317"></a>00317           { 
<a name="l00318"></a>00318             cout &lt;&lt;<span class="stringliteral">"ERROR: in IndexTranslator::"</span>
<a name="l00319"></a>00319                  &lt;&lt; <span class="stringliteral">"createClauseIdxToClauseFormulaIdxsMap(): clause "</span>;
<a name="l00320"></a>00320             c-&gt;<a class="code" href="classClause.html#fabbb591aeffad815add408b4cf3ae9a">printWithoutWtWithStrVar</a>(cout, dom); cout &lt;&lt; <span class="stringliteral">"not found!"</span>&lt;&lt;endl;
<a name="l00321"></a>00321             exit(-1);
<a name="l00322"></a>00322           }
<a name="l00323"></a>00323         }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325           <span class="comment">//if we must tie the clause weight to formula weight as when</span>
<a name="l00326"></a>00326           <span class="comment">//the clause is in the CNF of an existentially quantified formula,</span>
<a name="l00327"></a>00327           <span class="comment">//or an existentially and uniquely quantified formula,</span>
<a name="l00328"></a>00328         <span class="keywordflow">if</span> (tieClauseWtToFormulaWt(mln, j))
<a name="l00329"></a>00329         {
<a name="l00330"></a>00330           <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;FormulaClauseIndexes*&gt;</a>&amp; fciArr 
<a name="l00331"></a>00331             = mln-&gt;getMLNClauseInfo(j)-&gt;formulaClauseIndexes;
<a name="l00332"></a>00332 
<a name="l00333"></a>00333           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; fciArr.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); k++)
<a name="l00334"></a>00334           {
<a name="l00335"></a>00335             <span class="keywordtype">int</span> fidx = *(fciArr[k]-&gt;formulaIndex);
<a name="l00336"></a>00336             <span class="keywordflow">if</span> (!formulaWtTiedToClauseWts((*fnca)[fidx])) <span class="keywordflow">continue</span>;
<a name="l00337"></a>00337             string formula = (*fnca)[fidx]-&gt;formula;
<a name="l00338"></a>00338             <span class="keywordtype">int</span> numClauses = (*fnca)[fidx]-&gt;indexClauses-&gt;size();
<a name="l00339"></a>00339             <span class="keywordtype">int</span> idx = existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(formula);
<a name="l00340"></a>00340             cfIdxs-&gt;append(<a class="code" href="structIdxDiv.html">IdxDiv</a>());
<a name="l00341"></a>00341                 <span class="comment">//exist. quant. formulas comes after 'normal' clauses</span>
<a name="l00342"></a>00342             cfIdxs-&gt;lastItem().idx = idx + clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00343"></a>00343 
<a name="l00344"></a>00344             <span class="keywordflow">if</span> (mln-&gt;isExistClause(j))
<a name="l00345"></a>00345               cfIdxs-&gt;lastItem().div = numClauses;
<a name="l00346"></a>00346             <span class="keywordflow">else</span>
<a name="l00347"></a>00347             <span class="keywordflow">if</span> (mln-&gt;isExistUniqueClause(j))
<a name="l00348"></a>00348             {
<a name="l00349"></a>00349                 <span class="comment">//this clause states that there is at least one true value</span>
<a name="l00350"></a>00350               <a class="code" href="classClause.html">Clause</a>* firstClause 
<a name="l00351"></a>00351                 = (*((*fnca)[fidx]-&gt;indexClauses))[0]-&gt;clause;
<a name="l00352"></a>00352               <span class="keywordtype">int</span> numPreds = firstClause-&gt;getNumPredicates();
<a name="l00353"></a>00353               <a class="code" href="classClause.html">Clause</a>* c = (<a class="code" href="classClause.html">Clause</a>*) mln-&gt;getClause(j);
<a name="l00354"></a>00354               <span class="keywordflow">if</span> (c-&gt;<a class="code" href="classClause.html#5f7d8cb2b2d054adaffb564c221ed559">same</a>(firstClause))
<a name="l00355"></a>00355                 cfIdxs-&gt;lastItem().div = (numPreds &gt; 1) ? numPreds+1 : 1;
<a name="l00356"></a>00356               <span class="keywordflow">else</span>
<a name="l00357"></a>00357                 cfIdxs-&gt;lastItem().div = (numPreds*numPreds-1)*0.5;
<a name="l00358"></a>00358             }
<a name="l00359"></a>00359             <span class="keywordflow">else</span>
<a name="l00360"></a>00360               assert(<span class="keyword">false</span>);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 
<a name="l00363"></a>00363             <span class="keywordflow">if</span> (idx &lt; 0)
<a name="l00364"></a>00364             { 
<a name="l00365"></a>00365               cout &lt;&lt; <span class="stringliteral">"ERROR: in createClauseIdxToClauseFormulaIdxsMap(): "</span>
<a name="l00366"></a>00366                    &lt;&lt; <span class="stringliteral">"formula "</span> &lt;&lt; formula &lt;&lt; <span class="stringliteral">"not found!"</span> &lt;&lt; endl;
<a name="l00367"></a>00367               exit(-1);
<a name="l00368"></a>00368             }
<a name="l00369"></a>00369           }
<a name="l00370"></a>00370         }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372         cfIdxs-&gt;compress();
<a name="l00373"></a>00373 
<a name="l00374"></a>00374       } <span class="comment">// for each clause in MLN</span>
<a name="l00375"></a>00375     } <span class="comment">// for each DB</span>
<a name="l00376"></a>00376   }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 
<a name="l00379"></a><a class="code" href="classIndexTranslator.html#49e7096c40655975f8f1217a44d09873">00379</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#49e7096c40655975f8f1217a44d09873">appendClauseIdxToClauseFormulaIdxs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCFIdxs,
<a name="l00380"></a>00380                                           <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCIdxsPerCFIdx,
<a name="l00381"></a>00381                                           <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; domainIdx)
<a name="l00382"></a>00382   {
<a name="l00383"></a>00383     <span class="keywordflow">if</span> (numCFIdxs == 0) <span class="keywordflow">return</span>;
<a name="l00384"></a>00384     <a class="code" href="classArray.html">Array&lt;Array&lt;IdxDiv&gt;</a>*&gt;&amp; cidxs = (*cIdxToCFIdxsPerDomain_)[domainIdx];
<a name="l00385"></a>00385     <a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; wts = (*wtsPerDomain_)[domainIdx];
<a name="l00386"></a>00386     <a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; grads = (*gradsPerDomain_)[domainIdx];
<a name="l00387"></a>00387     <span class="keywordtype">int</span> numClausesFormulas = <a class="code" href="classIndexTranslator.html#29f2569ee801d867d9fa5c80fd2d3710">getNumClausesAndExistFormulas</a>();
<a name="l00388"></a>00388     
<a name="l00389"></a>00389     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numCFIdxs; j++)
<a name="l00390"></a>00390     {
<a name="l00391"></a>00391       <span class="keywordtype">int</span> cfidx = numClausesFormulas + j;
<a name="l00392"></a>00392       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; numCIdxsPerCFIdx; k++)
<a name="l00393"></a>00393       {
<a name="l00394"></a>00394         <a class="code" href="structIdxDiv.html">IdxDiv</a> idiv;
<a name="l00395"></a>00395         idiv.idx = cfidx;
<a name="l00396"></a>00396         idiv.div = 1;
<a name="l00397"></a>00397         <a class="code" href="classArray.html">Array&lt;IdxDiv&gt;</a>* arr = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;IdxDiv&gt;</a>(1);
<a name="l00398"></a>00398         arr-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(idiv);
<a name="l00399"></a>00399         cidxs.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(arr);
<a name="l00400"></a>00400         
<a name="l00401"></a>00401         wts.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(0.0);
<a name="l00402"></a>00402         grads.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(0.0);          
<a name="l00403"></a>00403       }
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405   }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407   
<a name="l00408"></a><a class="code" href="classIndexTranslator.html#b23ba2a3e624d8a77a0540fb716adf4c">00408</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#49e7096c40655975f8f1217a44d09873">appendClauseIdxToClauseFormulaIdxs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCFIdxs,
<a name="l00409"></a>00409                                           <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCIdxsPerCFIdx)
<a name="l00410"></a>00410   {
<a name="l00411"></a>00411     <span class="keywordflow">if</span> (numCFIdxs == 0) <span class="keywordflow">return</span>;
<a name="l00412"></a>00412     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cIdxToCFIdxsPerDomain_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00413"></a>00413       <a class="code" href="classIndexTranslator.html#49e7096c40655975f8f1217a44d09873">appendClauseIdxToClauseFormulaIdxs</a>(numCFIdxs, numCIdxsPerCFIdx, i);
<a name="l00414"></a>00414   }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 
<a name="l00417"></a><a class="code" href="classIndexTranslator.html#501d6e1378fe2a740c8222048337750d">00417</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#501d6e1378fe2a740c8222048337750d">removeClauseIdxToClauseFormulaIdxs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCFIdxs,
<a name="l00418"></a>00418                                           <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCIdxsPerCFIdx,
<a name="l00419"></a>00419                                           <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; domainIdx)
<a name="l00420"></a>00420   {
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (numCFIdxs == 0) <span class="keywordflow">return</span>;
<a name="l00422"></a>00422     <a class="code" href="classArray.html">Array&lt;Array&lt;IdxDiv&gt;</a>*&gt;&amp; cidxs = (*cIdxToCFIdxsPerDomain_)[domainIdx];
<a name="l00423"></a>00423     <a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; wts = (*wtsPerDomain_)[domainIdx];
<a name="l00424"></a>00424     <a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; grads = (*gradsPerDomain_)[domainIdx];
<a name="l00425"></a>00425     
<a name="l00426"></a>00426     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numCFIdxs; j++)
<a name="l00427"></a>00427       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; numCIdxsPerCFIdx; k++)
<a name="l00428"></a>00428       {
<a name="l00429"></a>00429         <span class="keyword">delete</span> cidxs.<a class="code" href="classArray.html#217ac5fcd77509d9e3efbc77bc95e11d">removeLastItem</a>();
<a name="l00430"></a>00430         wts.<a class="code" href="classArray.html#217ac5fcd77509d9e3efbc77bc95e11d">removeLastItem</a>();
<a name="l00431"></a>00431         grads.<a class="code" href="classArray.html#217ac5fcd77509d9e3efbc77bc95e11d">removeLastItem</a>();          
<a name="l00432"></a>00432       }    
<a name="l00433"></a>00433   }
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 
<a name="l00436"></a><a class="code" href="classIndexTranslator.html#39ce41c7e8bfe62aa2f6cd43c2a79c0b">00436</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#501d6e1378fe2a740c8222048337750d">removeClauseIdxToClauseFormulaIdxs</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCFIdxs,
<a name="l00437"></a>00437                                           <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; numCIdxsPerCFIdx)
<a name="l00438"></a>00438   {
<a name="l00439"></a>00439     <span class="keywordflow">if</span> (numCFIdxs == 0) <span class="keywordflow">return</span>;
<a name="l00440"></a>00440     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; cIdxToCFIdxsPerDomain_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00441"></a>00441       <a class="code" href="classIndexTranslator.html#501d6e1378fe2a740c8222048337750d">removeClauseIdxToClauseFormulaIdxs</a>(numCFIdxs, numCIdxsPerCFIdx, i);
<a name="l00442"></a>00442   }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444 
<a name="l00445"></a><a class="code" href="classIndexTranslator.html#38c0160e9d5c2b5a71e45a47d030fdcf">00445</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#38c0160e9d5c2b5a71e45a47d030fdcf">setPriorMeans</a>(<a class="code" href="classArray.html">Array&lt;double&gt;</a>&amp; priorMeans)
<a name="l00446"></a>00446   {
<a name="l00447"></a>00447     priorMeans.<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l00448"></a>00448     priorMeans.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>() + 
<a name="l00449"></a>00449                           existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>());
<a name="l00450"></a>00450     <span class="keywordtype">int</span> m = 0;
<a name="l00451"></a>00451     <a class="code" href="classMLN.html">MLN</a>* mln0 = (*mlns_)[0];
<a name="l00452"></a>00452 
<a name="l00453"></a>00453     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00454"></a>00454     {
<a name="l00455"></a>00455       <a class="code" href="classClause.html">Clause</a>* c = (*clauseOrdering_)[i]; 
<a name="l00456"></a>00456       <span class="keywordtype">int</span> cidx = mln0-&gt;<a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(c);      
<a name="l00457"></a>00457       priorMeans[m++] = mln0-&gt;<a class="code" href="classMLN.html#f4f91ea726841a108275268c250730a2">getMLNClauseInfo</a>(cidx)-&gt;<a class="code" href="structMLNClauseInfo.html#3d4226fb16efa36cdb9c907d895196f9">priorMean</a>;
<a name="l00458"></a>00458     }
<a name="l00459"></a>00459     
<a name="l00460"></a>00460     <span class="keyword">const</span> <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* fnca = mln0-&gt;<a class="code" href="classMLN.html#06360908288ca50c33483c17b1e3c45c">getFormulaAndClausesArray</a>();
<a name="l00461"></a>00461     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00462"></a>00462     {
<a name="l00463"></a>00463       <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a> tmp((*existFormulaOrdering_)[i], 0, <span class="keyword">false</span>);
<a name="l00464"></a>00464       <span class="keywordtype">int</span> a = fnca-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(&amp;tmp);
<a name="l00465"></a>00465       assert(a &gt;= 0);
<a name="l00466"></a>00466       priorMeans[m++] = (*fnca)[a]-&gt;priorMean;
<a name="l00467"></a>00467     }
<a name="l00468"></a>00468   }
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     <span class="comment">//Maps each clause index in the array to the clause/formula index, and</span>
<a name="l00472"></a>00472     <span class="comment">//replaces the former with the latter.</span>
<a name="l00473"></a><a class="code" href="classIndexTranslator.html#34072d52fb7bd8daf967e09793d4b8cc">00473</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#34072d52fb7bd8daf967e09793d4b8cc">getClauseFormulaIndexes</a>(<a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; clauseIndexes, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; domainIdx)
<a name="l00474"></a>00474   {
<a name="l00475"></a>00475     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00476"></a>00476     {
<a name="l00477"></a>00477       <span class="keywordtype">int</span> cidx = clauseIndexes[i];
<a name="l00478"></a>00478       <a class="code" href="classArray.html">Array&lt;IdxDiv&gt;</a>* idxDivs = (*cIdxToCFIdxsPerDomain_)[domainIdx][cidx];
<a name="l00479"></a>00479       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; idxDivs-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); j++)
<a name="l00480"></a>00480         <span class="keywordflow">if</span> ((*idxDivs)[j].idx &lt; clauseOrdering_-&gt;size())
<a name="l00481"></a>00481         {
<a name="l00482"></a>00482             <span class="comment">//only get the index of clauses (and not those of exist.</span>
<a name="l00483"></a>00483             <span class="comment">//quant. formulas)</span>
<a name="l00484"></a>00484           assert((*idxDivs)[j].div == 1);
<a name="l00485"></a>00485           clauseIndexes[i] = (*idxDivs)[j].idx;
<a name="l00486"></a>00486         }
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488   }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     <span class="comment">//assign the weights belonging to clauses (and none of those belonging to</span>
<a name="l00492"></a>00492     <span class="comment">//existentially/exitentially and uniquely  quantified formulas) to the MLNs</span>
<a name="l00493"></a><a class="code" href="classIndexTranslator.html#8ca15b921b6a29fe426e4bf4ee4bf6e0">00493</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#8ca15b921b6a29fe426e4bf4ee4bf6e0">assignNonTiedClauseWtsToMLNs</a>(<span class="keyword">const</span> <span class="keywordtype">double</span>* <span class="keyword">const</span> &amp; wts)
<a name="l00494"></a>00494   {
<a name="l00495"></a>00495     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00496"></a>00496     {
<a name="l00497"></a>00497       <a class="code" href="classMLN.html">MLN</a>* mln = (*mlns_)[i];
<a name="l00498"></a>00498       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; mln-&gt;getNumClauses(); j++)
<a name="l00499"></a>00499       {
<a name="l00500"></a>00500         <span class="keywordflow">if</span> (!noTieClauseWtToFormulaWt(mln,j)) <span class="keywordflow">continue</span>;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502         <a class="code" href="classClause.html">Clause</a>* c = ((<a class="code" href="classClause.html">Clause</a>*) mln-&gt;getClause(j));
<a name="l00503"></a>00503         assert(inClauseOrdering(c, i));
<a name="l00504"></a>00504         <a class="code" href="classArray.html">Array&lt;IdxDiv&gt;</a>* idxDivs =(*cIdxToCFIdxsPerDomain_)[i][j];
<a name="l00505"></a>00505         <span class="keywordtype">double</span> wt = 0;
<a name="l00506"></a>00506         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; idxDivs-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); k++)
<a name="l00507"></a>00507         {
<a name="l00508"></a>00508             <span class="comment">//don't assign the weights of existential formulas to clauses</span>
<a name="l00509"></a>00509           <span class="keywordflow">if</span> ((*idxDivs)[k].idx &lt; clauseOrdering_-&gt;size())
<a name="l00510"></a>00510             wt += wts[ (*idxDivs)[k].idx ] / (*idxDivs)[k].div;
<a name="l00511"></a>00511         }
<a name="l00512"></a>00512         c-&gt;setWt(wt);
<a name="l00513"></a>00513       }
<a name="l00514"></a>00514     }
<a name="l00515"></a>00515   }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517   
<a name="l00518"></a><a class="code" href="classIndexTranslator.html#b73c99ea9cb4bc977d6136178e8c5bf1">00518</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#b73c99ea9cb4bc977d6136178e8c5bf1">printClauseFormulaWts</a>(ostream&amp; out, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; includeIdx)
<a name="l00519"></a>00519   {
<a name="l00520"></a>00520     <a class="code" href="classArray.html">Array&lt;double&gt;</a> wts;
<a name="l00521"></a>00521     <a class="code" href="classIndexTranslator.html#6196e701024038283a640027c78e9775">getClauseFormulaWts</a>(wts);
<a name="l00522"></a>00522       <span class="comment">//print those clauses that appear in a non-exist. quant. formula</span>
<a name="l00523"></a>00523     <a class="code" href="classArray.html">Array&lt;Clause*&gt;</a> tmp;
<a name="l00524"></a>00524     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++) 
<a name="l00525"></a>00525     {
<a name="l00526"></a>00526       (*clauseOrdering_)[i]-&gt;setWt(wts[i]);
<a name="l00527"></a>00527       tmp.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>((*clauseOrdering_)[i]);
<a name="l00528"></a>00528     }
<a name="l00529"></a>00529     <a class="code" href="classClause.html#37341ce12c688588637e69ad57d8d634">Clause::sortByLen</a>(tmp);
<a name="l00530"></a>00530       
<a name="l00531"></a>00531     out.setf(ios_base::left, ios_base::adjustfield);
<a name="l00532"></a>00532     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; tmp.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00533"></a>00533     {
<a name="l00534"></a>00534       <span class="keywordflow">if</span> (includeIdx) { out &lt;&lt; i &lt;&lt; <span class="stringliteral">":  "</span>; out.width(14); }
<a name="l00535"></a>00535       <span class="keywordflow">else</span>            { out.width(10); }
<a name="l00536"></a>00536       out &lt;&lt; tmp[i]-&gt;getWt(); out.width(0); out &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l00537"></a>00537       tmp[i]-&gt;printWithoutWtWithStrVar(out, (*domains_)[0]); out &lt;&lt; endl; 
<a name="l00538"></a>00538     }
<a name="l00539"></a>00539     out.width(0);
<a name="l00540"></a>00540 
<a name="l00541"></a>00541     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00542"></a>00542     {
<a name="l00543"></a>00543       <span class="keywordtype">int</span> idx = i+clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00544"></a>00544       <span class="keywordflow">if</span> (includeIdx) { out &lt;&lt; idx &lt;&lt;<span class="stringliteral">":  "</span>;out.width(14);}
<a name="l00545"></a>00545       <span class="keywordflow">else</span>            { out.width(10); }
<a name="l00546"></a>00546       out &lt;&lt; wts[idx]; out.width(0); 
<a name="l00547"></a>00547       out &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; (*existFormulaOrdering_)[i] &lt;&lt; endl;      
<a name="l00548"></a>00548     }
<a name="l00549"></a>00549     out.width(0);
<a name="l00550"></a>00550   }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552 
<a name="l00553"></a>00553     <span class="comment">//used by VotedPerceptron</span>
<a name="l00554"></a><a class="code" href="classIndexTranslator.html#44a2b85e757a32d1942967277d263d7c">00554</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#44a2b85e757a32d1942967277d263d7c">setRelevantClausesFormulas</a>(<a class="code" href="classArray.html">Array&lt;bool&gt;</a>&amp; relevantClausesFormulas,
<a name="l00555"></a>00555                                   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;bool&gt;</a>&amp; relevantClausesInMLN0)
<a name="l00556"></a>00556   {
<a name="l00557"></a>00557     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;bool&gt;</a>&amp; relevantClauses = relevantClausesInMLN0;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     <span class="keywordflow">if</span> (relevantClausesFormulas.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &lt; relevantClauses.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>())
<a name="l00560"></a>00560       relevantClausesFormulas.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(relevantClauses.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00561"></a>00561     <span class="keywordflow">else</span>
<a name="l00562"></a>00562     <span class="keywordflow">if</span> (relevantClausesFormulas.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &gt; relevantClauses.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>())
<a name="l00563"></a>00563       relevantClausesFormulas.<a class="code" href="classArray.html#8296ec16f72b0975daa2029772af29ca">shrinkToSize</a>(relevantClauses.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>());
<a name="l00564"></a>00564       
<a name="l00565"></a>00565     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; relevantClausesFormulas.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00566"></a>00566       relevantClausesFormulas[i] = <span class="keyword">false</span>;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568      
<a name="l00569"></a>00569     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00570"></a>00570     {
<a name="l00571"></a>00571       <span class="keywordtype">int</span> cidx = (*mlns_)[0]-&gt;findClauseIdx((*clauseOrdering_)[i]);
<a name="l00572"></a>00572       relevantClausesFormulas[i] = relevantClauses[cidx];
<a name="l00573"></a>00573     }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575     <span class="keywordtype">int</span> offset = clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();      
<a name="l00576"></a>00576       
<a name="l00577"></a>00577     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00578"></a>00578     {
<a name="l00579"></a>00579       <span class="keyword">const</span> <a class="code" href="classHashArray.html">IndexClauseHashArray</a>* icha 
<a name="l00580"></a>00580         = (*mlns_)[0]-&gt;getClausesOfFormula((*existFormulaOrdering_)[i]);
<a name="l00581"></a>00581       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; icha-&gt;size(); j++)
<a name="l00582"></a>00582       {
<a name="l00583"></a>00583         <span class="keywordtype">int</span> cidx = (*mlns_)[0]-&gt;findClauseIdx((*icha)[j]-&gt;clause);
<a name="l00584"></a>00584         relevantClausesFormulas[offset+i] = relevantClauses[cidx];
<a name="l00585"></a>00585         <span class="keywordflow">if</span> (relevantClausesFormulas[offset+i]) <span class="keywordflow">break</span>;
<a name="l00586"></a>00586       }
<a name="l00587"></a>00587     }
<a name="l00588"></a>00588   }
<a name="l00589"></a>00589 
<a name="l00590"></a>00590 
<a name="l00591"></a><a class="code" href="classIndexTranslator.html#0dca38531067d4002447507e9b1b80b4">00591</a>   <span class="keywordtype">void</span> <a class="code" href="classIndexTranslator.html#0dca38531067d4002447507e9b1b80b4">printRelevantClausesFormulas</a>(ostream&amp; out,
<a name="l00592"></a>00592                                     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;bool&gt;</a>&amp; relevantClausesFormulas)
<a name="l00593"></a>00593   {
<a name="l00594"></a>00594     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00595"></a>00595     {
<a name="l00596"></a>00596       <span class="keywordflow">if</span> (relevantClausesFormulas[i])
<a name="l00597"></a>00597       {
<a name="l00598"></a>00598         out &lt;&lt; i &lt;&lt; <span class="stringliteral">": "</span>;
<a name="l00599"></a>00599         (*clauseOrdering_)[i]-&gt;printWithoutWtWithStrVar(out, (*domains_)[0]);
<a name="l00600"></a>00600         out &lt;&lt; endl;
<a name="l00601"></a>00601       }
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603     
<a name="l00604"></a>00604     <span class="keywordtype">int</span> offset = clauseOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; existFormulaOrdering_-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00607"></a>00607     {
<a name="l00608"></a>00608       <span class="keywordflow">if</span> (relevantClausesFormulas[offset+i])
<a name="l00609"></a>00609         out &lt;&lt; offset+i &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; (*existFormulaOrdering_)[i] &lt;&lt; endl;
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611   }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 
<a name="l00614"></a>00614  <span class="keyword">private</span>:
<a name="l00615"></a>00615   <span class="keywordtype">void</span> trackClauseConstants()
<a name="l00616"></a>00616   {
<a name="l00617"></a>00617     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mlns_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00618"></a>00618       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; (*mlns_)[i]-&gt;getNumClauses(); j++)
<a name="l00619"></a>00619         <span class="keywordflow">if</span> (noTieClauseWtToFormulaWt((*mlns_)[i], j))
<a name="l00620"></a>00620         {
<a name="l00621"></a>00621           <a class="code" href="classClause.html">Clause</a>* c = (<a class="code" href="classClause.html">Clause</a>*) (*mlns_)[i]-&gt;getClause(j);
<a name="l00622"></a>00622           <span class="keywordflow">if</span> (c-&gt;<a class="code" href="classClause.html#cd89f78c621311b5f07210583eb8f608">getAuxClauseData</a>() == NULL) c-&gt;<a class="code" href="classClause.html#f42e759f9c39dcb7d8a8014a603ef480">newAuxClauseData</a>();
<a name="l00623"></a>00623           c-&gt;<a class="code" href="classClause.html#f83c212adf37455f3d5d95c09fb9c402">trackConstants</a>();
<a name="l00624"></a>00624         }
<a name="l00625"></a>00625   }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627 
<a name="l00628"></a>00628   <span class="keywordtype">void</span> createClausesFormulasOrdering(<a class="code" href="classMLN.html">MLN</a>* <span class="keyword">const</span> &amp; mln, 
<a name="l00629"></a>00629                                      <a class="code" href="classHashArray.html">ClauseHashArray</a>* <span class="keyword">const</span> &amp; clauses,
<a name="l00630"></a>00630                                      <a class="code" href="classHashArray.html">StringHashArray</a>* <span class="keyword">const</span> &amp; existFormulas)
<a name="l00631"></a>00631   {
<a name="l00632"></a>00632     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; mln-&gt;<a class="code" href="classMLN.html#9af698a87c5b518e9ce18755bc414231">getNumClauses</a>(); i++)
<a name="l00633"></a>00633       <span class="keywordflow">if</span> (noTieClauseWtToFormulaWt(mln,i))
<a name="l00634"></a>00634       { 
<a name="l00635"></a>00635         <a class="code" href="classClause.html">Clause</a>* c = <span class="keyword">new</span> <a class="code" href="classClause.html">Clause</a>( *((<a class="code" href="classClause.html">Clause</a>*)mln-&gt;getClause(i)) );
<a name="l00636"></a>00636         clauses-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(c);
<a name="l00637"></a>00637       }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639     <span class="keyword">const</span> <a class="code" href="classHashArray.html">FormulaAndClausesArray</a>* fnca = mln-&gt;getFormulaAndClausesArray();
<a name="l00640"></a>00640     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; fnca-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00641"></a>00641       <span class="keywordflow">if</span> (formulaWtTiedToClauseWts((*fnca)[i])) 
<a name="l00642"></a>00642         existFormulas-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>((*fnca)[i]-&gt;formula);
<a name="l00643"></a>00643   }
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 
<a name="l00646"></a>00646   <span class="keywordtype">bool</span> inClauseOrdering(<a class="code" href="classClause.html">Clause</a>* <span class="keyword">const</span> &amp; c, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; domainIdx)
<a name="l00647"></a>00647   {
<a name="l00648"></a>00648     assert(c-&gt;<a class="code" href="classClause.html#cd89f78c621311b5f07210583eb8f608">getAuxClauseData</a>());
<a name="l00649"></a>00649     <span class="keywordflow">if</span> (domainIdx &gt; 0 &amp;&amp; c-&gt;<a class="code" href="classClause.html#a77a39136edd846f6581b1973ddb9577">containsConstants</a>()) 
<a name="l00650"></a>00650       c-&gt;<a class="code" href="classClause.html#fdbd3f430d505104dfb2681a31f6c905">translateConstants</a>((*domains_)[domainIdx], (*domains_)[0]);
<a name="l00651"></a>00651     <span class="keywordtype">bool</span> in = (clauseOrdering_-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(c) &gt;= 0);
<a name="l00652"></a>00652     <span class="keywordflow">if</span> (domainIdx &gt; 0 &amp;&amp; c-&gt;<a class="code" href="classClause.html#a77a39136edd846f6581b1973ddb9577">containsConstants</a>()) 
<a name="l00653"></a>00653       c-&gt;<a class="code" href="classClause.html#fdbd3f430d505104dfb2681a31f6c905">translateConstants</a>((*domains_)[0], (*domains_)[domainIdx]);
<a name="l00654"></a>00654     <span class="keywordflow">return</span> in;
<a name="l00655"></a>00655   }
<a name="l00656"></a>00656   
<a name="l00657"></a>00657 
<a name="l00658"></a>00658     <span class="comment">//Returns true if the clause weights must be tied to the formulas (as when</span>
<a name="l00659"></a>00659     <span class="comment">//the clause belongs to the CNF of an existentially quantified or </span>
<a name="l00660"></a>00660     <span class="comment">//existentially and uniquely quantified formula</span>
<a name="l00661"></a>00661     <span class="comment">//i is the clause's index in mln</span>
<a name="l00662"></a>00662   <span class="keyword">static</span> <span class="keywordtype">bool</span> tieClauseWtToFormulaWt(<span class="keyword">const</span> <a class="code" href="classMLN.html">MLN</a>* <span class="keyword">const</span> &amp; mln, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)
<a name="l00663"></a>00663   { <span class="keywordflow">return</span> (mln-&gt;<a class="code" href="classMLN.html#2d3524856c6c63c5c208d4257b800e1f">isExistClause</a>(i) || mln-&gt;<a class="code" href="classMLN.html#1662f165830a5d4afaab25c1f39f530d">isExistUniqueClause</a>(i)); }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   <span class="keyword">static</span> <span class="keywordtype">bool</span> formulaWtTiedToClauseWts(<span class="keyword">const</span> <a class="code" href="structFormulaAndClauses.html">FormulaAndClauses</a>* <span class="keyword">const</span> &amp; fnc)
<a name="l00667"></a>00667   { <span class="keywordflow">return</span> (fnc-&gt;hasExist || fnc-&gt;isExistUnique); }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     <span class="comment">//Returns true if the clause weights need not be tied to the formulas </span>
<a name="l00671"></a>00671     <span class="comment">//(as when the clause belongs to the CNF of a non-existentially quantified </span>
<a name="l00672"></a>00672     <span class="comment">//and non-existentially and uniquely quantified formula</span>
<a name="l00673"></a>00673     <span class="comment">//i is the clause's index in mln</span>
<a name="l00674"></a>00674   <span class="keywordtype">bool</span> noTieClauseWtToFormulaWt(<span class="keyword">const</span> <a class="code" href="classMLN.html">MLN</a>* <span class="keyword">const</span> &amp; mln, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; i)
<a name="l00675"></a>00675   { <span class="keywordflow">return</span> mln-&gt;<a class="code" href="classMLN.html#e6ac28af43cb3957bdb41e5cfaa14929">clauseInNonExistAndNonExistUniqueFormulaCNF</a>(i); }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677  <span class="keyword">private</span>:
<a name="l00678"></a>00678   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;MLN*&gt;</a>* mlns_; <span class="comment">// not owned by this object; do not delete;</span>
<a name="l00679"></a>00679   <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;Domain*&gt;</a>* domains_; <span class="comment">// not owned by this object; do not delete;</span>
<a name="l00680"></a>00680 
<a name="l00681"></a>00681     <span class="comment">//cIdxToCFIdxsPerDomain_[d] maps clause indexes (cIdx) in an MLN to </span>
<a name="l00682"></a>00682     <span class="comment">//clause/formula indexes (CFIdxs) for domain d.</span>
<a name="l00683"></a>00683     <span class="comment">//Used when the clauses across multiple domains do not line up perfectly</span>
<a name="l00684"></a>00684     <span class="comment">//as when an existential formula has a different number of CNF clauses for</span>
<a name="l00685"></a>00685     <span class="comment">//different domains. Used in PseudoLogLikelihood.</span>
<a name="l00686"></a>00686   <a class="code" href="classArray.html">Array&lt;Array&lt;Array&lt;IdxDiv&gt;</a>*&gt; &gt;* cIdxToCFIdxsPerDomain_;
<a name="l00687"></a>00687   <a class="code" href="classArray.html">Array&lt;Array&lt;double&gt;</a> &gt;* wtsPerDomain_; <span class="comment">//Used in PseudoLogLikelihood</span>
<a name="l00688"></a>00688   <a class="code" href="classArray.html">Array&lt;Array&lt;double&gt;</a> &gt;* gradsPerDomain_; <span class="comment">//Used in PseudoLogLikelihood</span>
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   <a class="code" href="classHashArray.html">ClauseHashArray</a>* clauseOrdering_; 
<a name="l00691"></a>00691   <a class="code" href="classHashArray.html">StringHashArray</a>* existFormulaOrdering_;
<a name="l00692"></a>00692 };
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 
<a name="l00695"></a>00695 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 14 15:15:18 2007 for Alchemy by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
